<div>
<p>Microsoft has discovered several vulnerabilities, collectively referred to as Nimbuspwn, that could allow an attacker to elevate privileges to root on many Linux desktop endpoints. The vulnerabilities can be chained together to gain root privileges on Linux systems, allowing attackers to deploy payloads, like a root backdoor, and perform other malicious actions via arbitrary root code execution. Moreover, the Nimbuspwn vulnerabilities could potentially be leveraged as a vector for root access by more sophisticated threats, such as malware or ransomware, to achieve greater impact on vulnerable devices.</p>
<p>We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through <a href="https://www.microsoft.com/msrc/cvd?rtc=1">Coordinated Vulnerability Disclosure</a> (CVD) via <a href="https://www.microsoft.com/msrc/msvr">Microsoft Security Vulnerability Research</a> (MSVR). Fixes for these vulnerabilities, now identified as <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-29799">CVE-2022-29799</a> and <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-29800">CVE-2022-29800</a>, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances.</p>
<p>As organizational environments continue to rely on a diverse range of devices and systems, they require comprehensive solutions that provide cross-platform protection and a holistic view of their security posture to mitigate threats, such as Nimbuspwn. The growing number of vulnerabilities on Linux environments emphasize the need for strong monitoring of the platform’s operating system and its components. Microsoft Defender for Endpoint enables organizations to gain this necessary visibility and detect such threats on <a href="https://docs.microsoft.com/microsoft-365/security/defender-endpoint/microsoft-defender-endpoint-linux?view=o365-worldwide">Linux devices</a>, allowing organizations to detect, manage, respond, and remediate vulnerabilities and threats across different platforms, including Windows, Linux, Mac, iOS, and Android.</p>
<p>In this blog post, we will share some information about the affected components and examine the vulnerabilities we uncovered. Detailing how our cross-domain visibility helps us uncover new and unknown threats to continually improve security, we are also sharing details from our research with the larger security community to underscore the importance of securing platforms and devices.</p>
<h2>Background – D-Bus</h2>
<p><a href="https://en.wikipedia.org/wiki/D-Bus">D-Bus</a> (short for “Desktop-Bus”) is an inter-process communication channel (IPC) mechanism developed by the <a href="https://www.freedesktop.org/">freedesktop.org</a> project. D-Bus is a software-bus and allows processes on the same endpoint to communicate by transmitting messages and responding to them. D-Bus supports two main ways of communicating:</p>
<ol type="a"><li>Methods – used for request-response communications.</li><li>Signals – used for publish/subscribe communications.</li></ol>
<p>An example of D-Bus usage would be receiving a video chat by a popular video conferencing app–once a video is established, the video conferencing app could send a D-bus signal publishing that a call has started. Apps listening to that message could respond appropriately–for example, mute their audio.</p>
<p>There are many D-Bus components shipped by default on popular Linux desktop environments. Since those components run at different privileges and respond to messages, D-Bus components are an attractive target for attackers. Indeed, there have been interesting vulnerabilities in the past related to buggy D-Bus services, including <a href="https://unit42.paloaltonetworks.com/usbcreator-d-bus-privilege-escalation-in-ubuntu-desktop/">USBCreator Elevation of Privilege</a>, <a href="https://bugzilla.redhat.com/show_bug.cgi?id=1892437">Blueman Elevation of Privilege by command injection</a>, and other similar scenarios.</p>
<p>D-Bus exposes a global System Bus and a per-session Session Bus. From an attacker’s perspective, the System Bus is more attractive since it will commonly have services that run as root listening to it.</p>
<h3>D-Bus name ownership</h3>
<p>When connecting to the D-Bus, components are assigned with a unique identifier, which mitigates against attacks abusing PID-recycling. The unique identifier starts with a colon and has numbers in it separated by dots, such as “:1.337”. Components can use the D-Bus API to own identifiable names such as “org.freedesktop.Avahi” or “com.ubuntu.SystemService”. For D-Bus to allow such ownership, the requesting process context must be allowed under the D-Bus configuration files. Those configuration files are <a href="https://dbus.freedesktop.org/doc/dbus-daemon.1.html">well documented</a> and maintained under /usr/local/share/dbus-1/system.conf and /usr/local/share/dbus-1/session.conf (on some systems under /usr/local/dbus-1 directly). Specifically, the default system.conf does not allow ownership unless specified otherwise in other included configuration files (commonly under /etc/dbus-1/system.d).</p>
<figure class="wp-block-image size-full"><img alt="Figure 1 displays different ownership policies for the System Bus and the Session Bus; " class="wp-image-112704" height="148" src="https://www.microsoft.com/security/blog/uploads/securityprod/2022/04/Figure-1-Different-ownership-policies-for-the-System-Bus-and-the-Session-Bus.png" style="max-width:800px;height:auto;width:auto;" width="800"/><figcaption>Figure 1: Different ownership policies for the System Bus and the Session Bus</figcaption></figure>
<p>Additionally, if the name requested already exists–the request will not be granted until the owning process releases the name.</p>
<h2>Vulnerability hunting</h2>
<p>Our team has started enumerating services that run as root and listen to messages on the System Bus, performing both code reviews and dynamic analysis. We have reported two information leak issues as a result:</p>
<ol type="1"><li><a href="https://github.com/blueman-project/blueman/security/advisories/GHSA-3r9p-m5c8-8mw8">Directory Info Disclosure in Blueman</a></li><li><a href="https://access.redhat.com/security/cve/cve-2022-0987">Directory Info Disclosure in PackageKit (CVE-2022-0987)</a></li></ol>
<p>While these are interesting, their severity is low – an attacker can list files under directories that require high permissions to list files under. Then we started noticing interesting patterns in a <a href="https://en.wikipedia.org/wiki/Systemd">systemd unit</a> called networkd-dispatcher. The goal of networkd-dispatcher is to dispatch network status changes and optionally perform different scripts based on the new status. Interestingly, it runs on boot as root:</p>
<figure class="wp-block-image size-full"><img alt="Figure 2 displays networkd-dispatcher running as root." class="wp-image-112707" height="44" src="https://www.microsoft.com/security/blog/uploads/securityprod/2022/04/Figure-2-networkd-dispatcher-running-as-root.png" style="max-width:800px;height:auto;width:auto;" width="800"/><figcaption>Figure 2: networkd-dispatcher running as root</figcaption></figure>
<h3>Code flow for networkd-dispatcher</h3>
<p>Upon examination of the networkd-dispatcher <a href="https://gitlab.com/craftyguy/networkd-dispatcher">source code</a>, we noticed an interesting flow:</p>
<ol type="1"><li>The register function registers a new signal receiver for the service “org.freedesktop.network1” on the System Bus, for the signal name ”PropertiesChanged”.</li><li>The ”_receive_signal“ signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new states–“OperationalState” and “AdministrativeState”–each fetched from the data. For any of those states–if they aren’t empty–the “handle_state” method will get invoked.</li><li>The “handle_state” method simply invokes “_handle_one_state“ for each of those two states.</li><li>“_handle_one_state” validates the state isn’t empty and checks if it’s different than the previous state. If it is, it will update the new state and invoke the “_run_hooks_for_state” method, which is responsible of discovering and running the scripts for the new state.</li><li>“_run_hooks_for_state” implements the following logic:<ul><li>Discovers the script list by invoking the “get_script_list” method (which gets the new state as a string). This method simply calls “scripts_in_path” which is intended to return all the files under “/etc/networkd-dispatcher/&lt;state&gt;.d” that are owned by the root user and the root group, and are executable.</li><li>Sorts the script list.</li><li>Runs each script with <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen">subprocess.Popen</a> while supplying custom environment variables.</li></ul></li></ol>
<figure class="wp-block-image size-full"><img alt="Figure 3 displays a snippet of the _run_hooks_for_state source code." class="wp-image-112710" height="427" src="https://www.microsoft.com/security/blog/uploads/securityprod/2022/04/Figure-3-_run_hooks_for_state-source-code-some-parts-omitted-for-brevity.png" style="max-width:800px;height:auto;width:auto;" width="800"/><figcaption>Figure 3: _run_hooks_for_state source code – some parts omitted for brevity</figcaption></figure>
<p>Step 5 has multiple security issues:</p>
<ol type="1"><li><a href="https://en.wikipedia.org/wiki/Directory_traversal_attack">Directory traversal </a>(<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-29799">CVE-2022-29799</a>): none of the functions in the flow sanitize the OperationalState or the AdministrativeState. Since the states are used to build the script path, it is possible that a state would contain directory traversal patterns (e.g. “../../”) to escape from the “/etc/networkd-dispatcher” base directory.</li><li><a href="https://en.wikipedia.org/wiki/Symlink_race">Symlink race</a>: both the script discovery and subprocess.Popen follow symbolic links.</li><li>Time-of-check-time-of-use (<a href="https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use">TOCTOU</a>) race condition (<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-29800">CVE-2022-29800</a>): there is a certain time between the scripts being discovered and them being run. An attacker can abuse this vulnerability to replace scripts that networkd-dispatcher believes to be owned by root to ones that are not.</li></ol>
<figure class="wp-block-image size-full"><img alt='Figure 4 displays building the script list in the "scripts_in_path" method, including the vulnerable code with "subdir" poisoned, which is highlighted with a red box over the text reading "os.path.join(one path, subdir, filename)".' class="wp-image-112713" height="386" src="https://www.microsoft.com/security/blog/uploads/securityprod/2022/04/6267e7bcdaac2-6267e7bcdaac3Figure-4-Building-the-script-list-in-the-scripts_in_path-method-including-the-vulnerable-code-with-subdir-poisoned..png.png" style="max-width:800px;height:auto;width:auto;" width="800"/><figcaption>Figure 4: Building the script list in the “scripts_in_path” method, including the vulnerable code with “subdir” poisoned.</figcaption></figure>
<h2>Exploitation</h2>
<p>Let us assume an adversary has a malicious D-Bus component that can send an arbitrary signal. An attacker can therefore do the following:</p>
<ol type="1"><li>Prepare a directory ”/tmp/nimbuspwn” and plant a symlink ”/tmp/nimbuspwn/poc.d“ to point to “/sbin”. The “/sbin” directory was chosen specifically because it has many executables owned by root that do not block if run without additional arguments. This will abuse the symlink race issue we mentioned earlier.</li><li>For every executable filename under “/sbin” owned by root, plant the same filename under “/tmp/nimbuspwn”. For example, if “/sbin/vgs” is executable and owned by root, plant an executable file “/tmp/nimbuspwn/vgs” with the desired payload. This will help the attacker win the race condition imposed by the TOCTOU vulnerability.</li><li>Send a signal with the OperationalState “../../../tmp/nimbuspwn/poc”. This abuses the directory traversal vulnerability and escapes the script directory.</li><li>The networkd-dispatcher signal handler kicks in and builds the script list from the directory “/etc/networkd-dispatcher/../../../tmp/nimbuspwn/poc.d”, which is really the symlink (“/tmp/nimbuspwn/poc.d”), which points to “/sbin”. Therefore, it creates a list composed of many executables owned by root.</li><li>Quickly change the symlink “/tmp/nimbuspwn/poc.d” to point to “/tmp/nimbuspwn”. This abuses the TOCTOU race condition vulnerability–the script path changes without networkd-dispatcher being aware.</li><li>The dispatcher starts running files that were initially under “/sbin” but in truth under the “/tmp/nimbuspwn” directory. Since the dispatcher “believes” those files are owned by root, it executes them blindly with subprocess.Popen as root. Therefore, our attacker has successfully exploited the vulnerability.</li></ol>
<p>Note that to win the TOCTOU race condition with high probability, we plant many files that can potentially run. Our experiments show three attempts were enough to win the TOCTOU race condition.</p>
<figure class="wp-block-image size-full"><img alt="Figure 5 displays a flow-chart of the attack in 3 stages. The first 3 steps are depicted in the top image, displaying the attacker's initial steps. The 4th step is depicted in the middle image, displaying how networkd-dispatcher processes the attacker's modifications. Steps 5 and 6 are depicted in the final image, displaying how the attacker abuses the TOCTOU race condition flaw so that the dispatcher ultimately permits the Nimbuspwn exploit. " class="wp-image-112716" height="996" src="https://www.microsoft.com/security/blog/uploads/securityprod/2022/04/Figure-5-Flow-chart-of-the-attack-in-three-stages.png" style="max-width:800px;height:auto;width:auto;" width="800"/><figcaption>Figure 5: Flow-chart of the attack in three stages</figcaption></figure>
<p>Since we do not wish to run the exploit every time we want to run as root, the payload that we ended up implementing leaves a root backdoor as such:</p>
<ol type="1"><li>Copies /bin/sh to /tmp/sh.</li><li>Turns the new /tmp/sh it into a <a href="https://attack.mitre.org/techniques/T1548/001/">Set-UID (SUID) binary</a>.</li><li>Run /tmp/sh -p. The “-p” flag is necessary since modern shells drop privileges by design.</li></ol>
<h3>Owning the bus name</h3>
<p>The astute reader will notice that the entire exploit elevates privileges assuming our exploit code can own the “org.freedesktop.network1” bus name. While this sounds non-trivial, we have found several environments where this happens. Specifically:</p>
<ol type="1"><li>On many environments (e.g. Linux Mint) the service systemd-networkd that normally owns the “org.freedesktop.network1” bus name does not start at boot by default.</li><li>Using <a href="https://docs.microsoft.com/microsoft-365/security/defender-endpoint/advanced-hunting-overview?view=o365-worldwide">advanced hunting in Microsoft Defender for Endpoint</a> we were able to spot several processes running as the systemd-network user (which is permitted to own the bus name we require) running arbitrary code from world-writable locations. These include several <a href="https://www.gnupg.org/documentation/manuals/gnupg/gpgv.html">gpgv</a> plugins (launched when <a href="https://linux.die.net/man/8/apt-get">apt-get</a> installs or upgrades) as well as the Erlang Port Mapper Daemon (<a href="https://www.erlang.org/doc/man/epmd.html">epmd</a>) which allows running arbitrary code under some scenarios.</li></ol>
<p>The query we used can also be run by Microsoft Defender for Endpoint customers:</p>
DeviceProcessEvents
| where Timestamp &gt; ago(5d)
 and AccountName == "systemd-network"
 and isnotempty(InitiatingProcessAccountName)
 and isnotempty(FileName)
| project DeviceId, FileName, FolderPath, ProcessCommandLine
<p>We were therefore able to exploit these scenarios and implement our own exploit:</p>
<figure class="wp-block-image size-full"><img alt="Figure 6 displays our successfully implemented exploit after winning the TOCTOU race condition. The title reads &quot;Nimbuspwn: networkd-dispatcher Linux EoP by Jonathan Bar Or ('JBO')&quot;. The processes are then displayed, reading top to bottom: &quot;Attempting to own dbus name org.freedesktop.network1&quot;, &quot;Validating name patterns&quot;, &quot;Planting base directory&quot;, &quot;Planting symlink&quot;, &quot;Planting payload&quot;, it then takes four attempts to &quot;win the (TOCTOU) race&quot; condition before stating &quot;Great, we now have a root backdoor. Hurray! Enjoy your root privileges&quot;. " class="wp-image-112719" height="598" src="https://www.microsoft.com/security/blog/uploads/securityprod/2022/04/Figure-6-Our-exploit-implemented-and-winning-the-TOCTOU-race.png" style="max-width:800px;height:auto;width:auto;" width="800"/><figcaption>Figure 6: Our exploit implemented and winning the TOCTOU race</figcaption></figure>
<p>While capable of running any arbitrary script as root, our exploit copies /bin/sh to the /tmp directory, sets /tmp/sh as a <a href="https://attack.mitre.org/techniques/T1548/001/">Set-UID (SUID) executable</a>, and then invokes “/tmp/sh -p”. Note that the “-p” flag is necessary to force the shell to not drop privileges.</p>
<h2>Hardening device security and detection strategy</h2>
<p>Despite the evolving threat landscape regularly delivering new threats, techniques, and attack capabilities, adversaries continue to focus on identifying and taking advantage of unpatched vulnerabilities and misconfigurations as a vector to access systems, networks, and sensitive information for malicious purposes. This constant bombardment of attacks spanning a wide range of platforms, devices, and other domains emphasizes the need for a comprehensive and proactive vulnerability management approach that can further identify and mitigate even previously unknown exploits and issues.</p>
<p>Microsoft’s <a href="https://docs.microsoft.com/microsoft-365/security/defender-endpoint/next-gen-threat-and-vuln-mgt?view=o365-worldwide">threat and vulnerability management</a> capabilities help organizations monitor their overall security posture, providing real-time insights into risk with continuous vulnerability discovery, contextualized intelligent prioritization, and seamless one-click flaw remediation. Leveraging our research into the Nimbuspwn vulnerabilities to improve solutions, our threat and vulnerability management already covers CVE-2022-29799 and CVE-2022-29800 and indicates such vulnerable devices in the threat and vulnerability module in <a href="https://www.microsoft.com/security/business/threat-protection/endpoint-defender?rtc=1">Microsoft Defender for Endpoint</a>.</p>
<p>To address the specific vulnerabilities at play, Microsoft Defender for Endpoint’s <a href="https://docs.microsoft.com/microsoft-365/security/defender-endpoint/overview-endpoint-detection-response?view=o365-worldwide">endpoint detection and response (EDR)</a> capabilities detect the directory traversal attack required to leverage Nimbuspwn. Additionally, the Microsoft Defender for Endpoint detection team has a generic detection for suspicious Set-UID process invocations, which detected our exploit without prior knowledge.</p>
<figure class="wp-block-image size-full"><img alt="Figure 7 displays Microsoft Defender for Endpoint detecting a suspicious SUID process used in our exploit - including the alert story and details of the detected activity. " class="wp-image-112722" height="426" src="https://www.microsoft.com/security/blog/uploads/securityprod/2022/04/Figure-7-Microsoft-Defender-for-Endpoint-detecting-a-suspicious-SUID-process-used-in-our-exploit.png" style="max-width:800px;height:auto;width:auto;" width="800"/><figcaption>Figure 7: Microsoft Defender for Endpoint detecting a suspicious SUID process used in our exploit</figcaption></figure>
<p>Defending against the evolving threat landscape requires the ability to protect and secure users’ computing experiences, be it a Windows or non-Windows device. Microsoft continuously enriches our protection technologies through robust research that protects users and organizations across all the major platforms every single day. This case displayed how the ability to coordinate such research via expert, cross-industry collaboration is vital to effectively mitigate issues, regardless of the vulnerable device or platform in use. By sharing our research and other forms of threat intelligence, we can continue to collaborate with the larger security community and strive to build better protection for all.</p>
<p>Jonathan Bar Or</p>
<p>Microsoft 365 Defender Research Team</p>
</div>