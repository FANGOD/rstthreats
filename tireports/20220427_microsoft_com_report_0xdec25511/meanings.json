{
    "title": "Microsoft finds new elevation of privilege Linux vulnerability, Nimbuspwn",
    "url": "https://www.microsoft.com/security/blog/2022/04/26/microsoft-finds-new-elevation-of-privilege-linux-vulnerability-nimbuspwn",
    "threats": {
        "Threat": [
            {
                "token": {
                    "id": "<THREAT_0x7bd8c1f4>",
                    "type": "Threat",
                    "value": "nimbuspwn_vuln"
                },
                "references": {
                    "sentences": [
                        "Microsoft has discovered several vulnerabilities, collectively referred to as Nimbuspwn, that could allow an attacker to elevate privileges to root on many Linux desktop endpoints. The vulnerabilities can be chained together to gain root privileges on Linux systems, allowing attackers to deploy payloads, like a root backdoor, and perform other malicious actions via arbitrary root code execution. Moreover, the Nimbuspwn vulnerabilities could potentially be leveraged as a vector for root access by more sophisticated threats, such as malware or ransomware, to achieve greater impact on vulnerable devices.",
                        "To address the specific vulnerabilities at play, Microsoft Defender for Endpoints endpoint detection and response (EDR) capabilities detect the directory traversal attack required to leverage Nimbuspwn. Additionally, the Microsoft Defender for Endpoint detection team has a generic detection for suspicious Set-UID process invocations, which detected our exploit without prior knowledge.",
                        "Microsofts threat and vulnerability management capabilities help organizations monitor their overall security posture, providing real-time insights into risk with continuous vulnerability discovery, contextualized intelligent prioritization, and seamless one-click flaw remediation. Leveraging our research into the Nimbuspwn vulnerabilities to improve solutions, our threat and vulnerability management already covers CVE-2022-29799 and CVE-2022-29800 and indicates such vulnerable devices in the threat and vulnerability module in Microsoft Defender for Endpoint.",
                        "Prepare a directory /tmp/nimbuspwn and plant a symlink /tmp/nimbuspwn/poc.d to point to /sbin. The /sbin directory was chosen specifically because it has many executables owned by root that do not block if run without additional arguments. This will abuse the symlink race issue we mentioned earlier.<crlf>For every executable filename under /sbin owned by root, plant the same filename under /tmp/nimbuspwn. For example, if /sbin/vgs is executable and owned by root, plant an executable file /tmp/nimbuspwn/vgs with the desired payload. This will help the attacker win the race condition imposed by the TOCTOU vulnerability.<crlf>Send a signal with the OperationalState ../../../tmp/nimbuspwn/poc. This abuses the directory traversal vulnerability and escapes the script directory.<crlf>The networkd-dispatcher signal handler kicks in and builds the script list from the directory /etc/networkd-dispatcher/../../../tmp/nimbuspwn/poc.d, which is really the symlink (/tmp/nimbuspwn/poc.d), which points to /sbin. Therefore, it creates a list composed of many executables owned by root.<crlf>Quickly change the symlink /tmp/nimbuspwn/poc.d to point to /tmp/nimbuspwn. This abuses the TOCTOU race condition vulnerabilitythe script path changes without networkd-dispatcher being aware.<crlf>The dispatcher starts running files that were initially under /sbin but in truth under the /tmp/nimbuspwn directory. Since the dispatcher believes those files are owned by root, it executes them blindly with subprocess.Popen as root. Therefore, our attacker has successfully exploited the vulnerability.",
                        "As organizational environments continue to rely on a diverse range of devices and systems, they require comprehensive solutions that provide cross-platform protection and a holistic view of their security posture to mitigate threats, such as Nimbuspwn. The growing number of vulnerabilities on Linux environments emphasize the need for strong monitoring of the platforms operating system and its components. Microsoft Defender for Endpoint enables organizations to gain this necessary visibility and detect such threats on Linux devices, allowing organizations to detect, manage, respond, and remediate vulnerabilities and threats across different platforms, including Windows, Linux, Mac, iOS, and Android."
                    ],
                    "titles": [
                        "Hardening device security and detection strategy",
                        "Exploitation",
                        "Microsoft finds new elevation of privilege Linux vulnerability, Nimbuspwn"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CVE_0xeecc9ca4>",
                            "type": "CVE",
                            "value": "cve-2022-0987"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x9dfcdb0e>",
                            "type": "File",
                            "value": "org.freedesktop.avahi"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xe146d464>",
                            "type": "File",
                            "value": "subprocess.popen"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xa179f90c>",
                            "type": "Category",
                            "value": "ransomware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    },
                    {
                        "src": {
                            "id": "<CVE_0x63a2b9f9>",
                            "type": "CVE",
                            "value": "cve-2022-29800"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    },
                    {
                        "src": {
                            "id": "<CVE_0xc1ef9e94>",
                            "type": "CVE",
                            "value": "cve-2022-29799"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    },
                    {
                        "src": {
                            "id": "<CVE_0xc1ef9e94>",
                            "type": "CVE",
                            "value": "cve-2022-29799"
                        },
                        "relation": "use_cve",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdabde5f0>",
                            "type": "File",
                            "value": "system.conf"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    },
                    {
                        "src": {
                            "id": "<CVE_0x63a2b9f9>",
                            "type": "CVE",
                            "value": "cve-2022-29800"
                        },
                        "relation": "use_cve",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x988076ce>",
                            "type": "Threat",
                            "value": "toctou_vuln"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<THREAT_0x988076ce>",
                    "type": "Threat",
                    "value": "toctou_vuln"
                },
                "references": {
                    "sentences": [
                        "Figure 6: Our exploit implemented and winning the TOCTOU race",
                        "Note that to win the TOCTOU race condition with high probability, we plant many files that can potentially run. Our experiments show three attempts were enough to win the TOCTOU race condition.",
                        "Prepare a directory /tmp/nimbuspwn and plant a symlink /tmp/nimbuspwn/poc.d to point to /sbin. The /sbin directory was chosen specifically because it has many executables owned by root that do not block if run without additional arguments. This will abuse the symlink race issue we mentioned earlier.<crlf>For every executable filename under /sbin owned by root, plant the same filename under /tmp/nimbuspwn. For example, if /sbin/vgs is executable and owned by root, plant an executable file /tmp/nimbuspwn/vgs with the desired payload. This will help the attacker win the race condition imposed by the TOCTOU vulnerability.<crlf>Send a signal with the OperationalState ../../../tmp/nimbuspwn/poc. This abuses the directory traversal vulnerability and escapes the script directory.<crlf>The networkd-dispatcher signal handler kicks in and builds the script list from the directory /etc/networkd-dispatcher/../../../tmp/nimbuspwn/poc.d, which is really the symlink (/tmp/nimbuspwn/poc.d), which points to /sbin. Therefore, it creates a list composed of many executables owned by root.<crlf>Quickly change the symlink /tmp/nimbuspwn/poc.d to point to /tmp/nimbuspwn. This abuses the TOCTOU race condition vulnerabilitythe script path changes without networkd-dispatcher being aware.<crlf>The dispatcher starts running files that were initially under /sbin but in truth under the /tmp/nimbuspwn directory. Since the dispatcher believes those files are owned by root, it executes them blindly with subprocess.Popen as root. Therefore, our attacker has successfully exploited the vulnerability.",
                        "Directory traversal (CVE-2022-29799): none of the functions in the flow sanitize the OperationalState or the AdministrativeState. Since the states are used to build the script path, it is possible that a state would contain directory traversal patterns (e.g. ../../) to escape from the /etc/networkd-dispatcher base directory.<crlf>Symlink race: both the script discovery and subprocess.Popen follow symbolic links.<crlf>Time-of-check-time-of-use (TOCTOU) race condition (CVE-2022-29800): there is a certain time between the scripts being discovered and them being run. An attacker can abuse this vulnerability to replace scripts that networkd-dispatcher believes to be owned by root to ones that are not."
                    ],
                    "titles": [
                        "Code flow for networkd-dispatcher",
                        "Exploitation",
                        "Owning the bus name"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CVE_0x63a2b9f9>",
                            "type": "CVE",
                            "value": "cve-2022-29800"
                        },
                        "relation": "use_cve",
                        "dst": {
                            "id": "<THREAT_0x988076ce>",
                            "type": "Threat",
                            "value": "toctou_vuln"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x988076ce>",
                            "type": "Threat",
                            "value": "toctou_vuln"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    }
                ]
            }
        ]
    },
    "ttps": {},
    "meanings": {
        "Category": [
            {
                "token": {
                    "id": "<CATEGORY_0x96121f83>",
                    "type": "Category",
                    "value": "backdoor"
                },
                "references": {
                    "sentences": [
                        "Microsoft has discovered several vulnerabilities, collectively referred to as Nimbuspwn, that could allow an attacker to elevate privileges to root on many Linux desktop endpoints. The vulnerabilities can be chained together to gain root privileges on Linux systems, allowing attackers to deploy payloads, like a root backdoor, and perform other malicious actions via arbitrary root code execution. Moreover, the Nimbuspwn vulnerabilities could potentially be leveraged as a vector for root access by more sophisticated threats, such as malware or ransomware, to achieve greater impact on vulnerable devices.",
                        "Since we do not wish to run the exploit every time we want to run as root, the payload that we ended up implementing leaves a root backdoor as such:"
                    ],
                    "titles": [
                        "Exploitation",
                        "Microsoft finds new elevation of privilege Linux vulnerability, Nimbuspwn"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0xf1a480bb>",
                    "type": "Category",
                    "value": "malware"
                },
                "references": {
                    "sentences": [
                        "Despite the evolving threat landscape regularly delivering new threats, techniques, and attack capabilities, adversaries continue to focus on identifying and taking advantage of unpatched vulnerabilities and misconfigurations as a vector to access systems, networks, and sensitive information for malicious purposes. This constant bombardment of attacks spanning a wide range of platforms, devices, and other domains emphasizes the need for a comprehensive and proactive vulnerability management approach that can further identify and mitigate even previously unknown exploits and issues.",
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances.",
                        "Let us assume an adversary has a malicious D-Bus component that can send an arbitrary signal. An attacker can therefore do the following:",
                        "Microsoft has discovered several vulnerabilities, collectively referred to as Nimbuspwn, that could allow an attacker to elevate privileges to root on many Linux desktop endpoints. The vulnerabilities can be chained together to gain root privileges on Linux systems, allowing attackers to deploy payloads, like a root backdoor, and perform other malicious actions via arbitrary root code execution. Moreover, the Nimbuspwn vulnerabilities could potentially be leveraged as a vector for root access by more sophisticated threats, such as malware or ransomware, to achieve greater impact on vulnerable devices."
                    ],
                    "titles": [
                        "Hardening device security and detection strategy",
                        "Exploitation",
                        "Microsoft finds new elevation of privilege Linux vulnerability, Nimbuspwn"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0xa179f90c>",
                    "type": "Category",
                    "value": "ransomware"
                },
                "references": {
                    "sentences": [
                        "Microsoft has discovered several vulnerabilities, collectively referred to as Nimbuspwn, that could allow an attacker to elevate privileges to root on many Linux desktop endpoints. The vulnerabilities can be chained together to gain root privileges on Linux systems, allowing attackers to deploy payloads, like a root backdoor, and perform other malicious actions via arbitrary root code execution. Moreover, the Nimbuspwn vulnerabilities could potentially be leveraged as a vector for root access by more sophisticated threats, such as malware or ransomware, to achieve greater impact on vulnerable devices."
                    ],
                    "titles": [
                        "Microsoft finds new elevation of privilege Linux vulnerability, Nimbuspwn"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0xa179f90c>",
                            "type": "Category",
                            "value": "ransomware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0xb68aa214>",
                    "type": "Category",
                    "value": "rat"
                },
                "references": {
                    "sentences": [
                        "While capable of running any arbitrary script as root, our exploit copies /bin/sh to the /tmp directory, sets /tmp/sh as a Set-UID (SUID) executable, and then invokes /tmp/sh -p. Note that the -p flag is necessary to force the shell to not drop privileges.",
                        "Copies /bin/sh to /tmp/sh.<crlf>Turns the new /tmp/sh it into a Set-UID (SUID) binary.<crlf>Run /tmp/sh -p. The -p flag is necessary since modern shells drop privileges by design."
                    ],
                    "titles": [
                        "Exploitation",
                        "Owning the bus name"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    }
                ]
            }
        ],
        "CVE": [
            {
                "token": {
                    "id": "<CVE_0xc1ef9e94>",
                    "type": "CVE",
                    "value": "cve-2022-29799"
                },
                "references": {
                    "sentences": [
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances.",
                        "Microsofts threat and vulnerability management capabilities help organizations monitor their overall security posture, providing real-time insights into risk with continuous vulnerability discovery, contextualized intelligent prioritization, and seamless one-click flaw remediation. Leveraging our research into the Nimbuspwn vulnerabilities to improve solutions, our threat and vulnerability management already covers CVE-2022-29799 and CVE-2022-29800 and indicates such vulnerable devices in the threat and vulnerability module in Microsoft Defender for Endpoint.",
                        "Directory traversal (CVE-2022-29799): none of the functions in the flow sanitize the OperationalState or the AdministrativeState. Since the states are used to build the script path, it is possible that a state would contain directory traversal patterns (e.g. ../../) to escape from the /etc/networkd-dispatcher base directory.<crlf>Symlink race: both the script discovery and subprocess.Popen follow symbolic links.<crlf>Time-of-check-time-of-use (TOCTOU) race condition (CVE-2022-29800): there is a certain time between the scripts being discovered and them being run. An attacker can abuse this vulnerability to replace scripts that networkd-dispatcher believes to be owned by root to ones that are not."
                    ],
                    "titles": [
                        "Code flow for networkd-dispatcher",
                        "Microsoft finds new elevation of privilege Linux vulnerability, Nimbuspwn",
                        "Hardening device security and detection strategy"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CVE_0xc1ef9e94>",
                            "type": "CVE",
                            "value": "cve-2022-29799"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    },
                    {
                        "src": {
                            "id": "<CVE_0xc1ef9e94>",
                            "type": "CVE",
                            "value": "cve-2022-29799"
                        },
                        "relation": "use_cve",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CVE_0x63a2b9f9>",
                    "type": "CVE",
                    "value": "cve-2022-29800"
                },
                "references": {
                    "sentences": [
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances.",
                        "Microsofts threat and vulnerability management capabilities help organizations monitor their overall security posture, providing real-time insights into risk with continuous vulnerability discovery, contextualized intelligent prioritization, and seamless one-click flaw remediation. Leveraging our research into the Nimbuspwn vulnerabilities to improve solutions, our threat and vulnerability management already covers CVE-2022-29799 and CVE-2022-29800 and indicates such vulnerable devices in the threat and vulnerability module in Microsoft Defender for Endpoint.",
                        "Directory traversal (CVE-2022-29799): none of the functions in the flow sanitize the OperationalState or the AdministrativeState. Since the states are used to build the script path, it is possible that a state would contain directory traversal patterns (e.g. ../../) to escape from the /etc/networkd-dispatcher base directory.<crlf>Symlink race: both the script discovery and subprocess.Popen follow symbolic links.<crlf>Time-of-check-time-of-use (TOCTOU) race condition (CVE-2022-29800): there is a certain time between the scripts being discovered and them being run. An attacker can abuse this vulnerability to replace scripts that networkd-dispatcher believes to be owned by root to ones that are not."
                    ],
                    "titles": [
                        "Hardening device security and detection strategy",
                        "Microsoft finds new elevation of privilege Linux vulnerability, Nimbuspwn",
                        "Code flow for networkd-dispatcher"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CVE_0x63a2b9f9>",
                            "type": "CVE",
                            "value": "cve-2022-29800"
                        },
                        "relation": "use_cve",
                        "dst": {
                            "id": "<THREAT_0x988076ce>",
                            "type": "Threat",
                            "value": "toctou_vuln"
                        }
                    },
                    {
                        "src": {
                            "id": "<CVE_0x63a2b9f9>",
                            "type": "CVE",
                            "value": "cve-2022-29800"
                        },
                        "relation": "use_cve",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    },
                    {
                        "src": {
                            "id": "<CVE_0x63a2b9f9>",
                            "type": "CVE",
                            "value": "cve-2022-29800"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CVE_0xeecc9ca4>",
                    "type": "CVE",
                    "value": "cve-2022-0987"
                },
                "references": {
                    "sentences": [
                        "Directory Info Disclosure in Blueman<crlf>Directory Info Disclosure in PackageKit (CVE-2022-0987)"
                    ],
                    "titles": [
                        "Vulnerability hunting"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CVE_0xeecc9ca4>",
                            "type": "CVE",
                            "value": "cve-2022-0987"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    }
                ]
            }
        ]
    },
    "iocs": {
        "File": [
            {
                "token": {
                    "id": "<FILE_0x9dfcdb0e>",
                    "type": "File",
                    "value": "org.freedesktop.avahi"
                },
                "references": {
                    "sentences": [
                        "When connecting to the D-Bus, components are assigned with a unique identifier, which mitigates against attacks abusing PID-recycling. The unique identifier starts with a colon and has numbers in it separated by dots, such as :1.337. Components can use the D-Bus API to own identifiable names such as org.freedesktop.Avahi or com.ubuntu.SystemService. For D-Bus to allow such ownership, the requesting process context must be allowed under the D-Bus configuration files. Those configuration files are well documented and maintained under /usr/local/share/dbus-1/system.conf and /usr/local/share/dbus-1/session.conf (on some systems under /usr/local/dbus-1 directly). Specifically, the default system.conf does not allow ownership unless specified otherwise in other included configuration files (commonly under /etc/dbus-1/system.d)."
                    ],
                    "titles": [
                        "D-Bus name ownership"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x9dfcdb0e>",
                            "type": "File",
                            "value": "org.freedesktop.avahi"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x81accd13>",
                            "type": "UnknownWord",
                            "value": "ubuntu"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x9dfcdb0e>",
                            "type": "File",
                            "value": "org.freedesktop.avahi"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x9dfcdb0e>",
                            "type": "File",
                            "value": "org.freedesktop.avahi"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8d82bd5e>",
                            "type": "UnknownWord",
                            "value": "systemservice"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x9dfcdb0e>",
                            "type": "File",
                            "value": "org.freedesktop.avahi"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x13ce95d7>",
                            "type": "UnknownWord",
                            "value": "d-bus"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0xdabde5f0>",
                    "type": "File",
                    "value": "system.conf"
                },
                "references": {
                    "sentences": [
                        "When connecting to the D-Bus, components are assigned with a unique identifier, which mitigates against attacks abusing PID-recycling. The unique identifier starts with a colon and has numbers in it separated by dots, such as :1.337. Components can use the D-Bus API to own identifiable names such as org.freedesktop.Avahi or com.ubuntu.SystemService. For D-Bus to allow such ownership, the requesting process context must be allowed under the D-Bus configuration files. Those configuration files are well documented and maintained under /usr/local/share/dbus-1/system.conf and /usr/local/share/dbus-1/session.conf (on some systems under /usr/local/dbus-1 directly). Specifically, the default system.conf does not allow ownership unless specified otherwise in other included configuration files (commonly under /etc/dbus-1/system.d)."
                    ],
                    "titles": [
                        "D-Bus name ownership"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdabde5f0>",
                            "type": "File",
                            "value": "system.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x28ca6807>",
                            "type": "UnknownWord",
                            "value": "dbus-1"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdabde5f0>",
                            "type": "File",
                            "value": "system.conf"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdabde5f0>",
                            "type": "File",
                            "value": "system.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc126d1be>",
                            "type": "UnknownWord",
                            "value": "unless"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0xe146d464>",
                    "type": "File",
                    "value": "subprocess.popen"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables.",
                        "Directory traversal (CVE-2022-29799): none of the functions in the flow sanitize the OperationalState or the AdministrativeState. Since the states are used to build the script path, it is possible that a state would contain directory traversal patterns (e.g. ../../) to escape from the /etc/networkd-dispatcher base directory.<crlf>Symlink race: both the script discovery and subprocess.Popen follow symbolic links.<crlf>Time-of-check-time-of-use (TOCTOU) race condition (CVE-2022-29800): there is a certain time between the scripts being discovered and them being run. An attacker can abuse this vulnerability to replace scripts that networkd-dispatcher believes to be owned by root to ones that are not.",
                        "Prepare a directory /tmp/nimbuspwn and plant a symlink /tmp/nimbuspwn/poc.d to point to /sbin. The /sbin directory was chosen specifically because it has many executables owned by root that do not block if run without additional arguments. This will abuse the symlink race issue we mentioned earlier.<crlf>For every executable filename under /sbin owned by root, plant the same filename under /tmp/nimbuspwn. For example, if /sbin/vgs is executable and owned by root, plant an executable file /tmp/nimbuspwn/vgs with the desired payload. This will help the attacker win the race condition imposed by the TOCTOU vulnerability.<crlf>Send a signal with the OperationalState ../../../tmp/nimbuspwn/poc. This abuses the directory traversal vulnerability and escapes the script directory.<crlf>The networkd-dispatcher signal handler kicks in and builds the script list from the directory /etc/networkd-dispatcher/../../../tmp/nimbuspwn/poc.d, which is really the symlink (/tmp/nimbuspwn/poc.d), which points to /sbin. Therefore, it creates a list composed of many executables owned by root.<crlf>Quickly change the symlink /tmp/nimbuspwn/poc.d to point to /tmp/nimbuspwn. This abuses the TOCTOU race condition vulnerabilitythe script path changes without networkd-dispatcher being aware.<crlf>The dispatcher starts running files that were initially under /sbin but in truth under the /tmp/nimbuspwn directory. Since the dispatcher believes those files are owned by root, it executes them blindly with subprocess.Popen as root. Therefore, our attacker has successfully exploited the vulnerability."
                    ],
                    "titles": [
                        "Code flow for networkd-dispatcher",
                        "Exploitation"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xe146d464>",
                            "type": "File",
                            "value": "subprocess.popen"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb62c6f50>",
                            "type": "UnknownWord",
                            "value": "supplying"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xe146d464>",
                            "type": "File",
                            "value": "subprocess.popen"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1cd21c02>",
                            "type": "UnknownWord",
                            "value": "symlink"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xe146d464>",
                            "type": "File",
                            "value": "subprocess.popen"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa772a71>",
                            "type": "UnknownWord",
                            "value": "symbolic"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xe146d464>",
                            "type": "File",
                            "value": "subprocess.popen"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe0fa9b2e>",
                            "type": "UnknownWord",
                            "value": "race"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xe146d464>",
                            "type": "File",
                            "value": "subprocess.popen"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x7bd8c1f4>",
                            "type": "Threat",
                            "value": "nimbuspwn_vuln"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xe146d464>",
                            "type": "File",
                            "value": "subprocess.popen"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x26ad5415>",
                            "type": "UnknownWord",
                            "value": "blindly"
                        }
                    }
                ]
            }
        ]
    },
    "unknownwords": {
        "UnknownWord": [
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x97b2feae>",
                    "type": "UnknownWord",
                    "value": "collectively"
                },
                "references": {
                    "sentences": [
                        "Microsoft has discovered several vulnerabilities, collectively referred to as Nimbuspwn, that could allow an attacker to elevate privileges to root on many Linux desktop endpoints. The vulnerabilities can be chained together to gain root privileges on Linux systems, allowing attackers to deploy payloads, like a root backdoor, and perform other malicious actions via arbitrary root code execution. Moreover, the Nimbuspwn vulnerabilities could potentially be leveraged as a vector for root access by more sophisticated threats, such as malware or ransomware, to achieve greater impact on vulnerable devices."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7cfa79ff>",
                    "type": "UnknownWord",
                    "value": "elevate"
                },
                "references": {
                    "sentences": [
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances.",
                        "Microsoft has discovered several vulnerabilities, collectively referred to as Nimbuspwn, that could allow an attacker to elevate privileges to root on many Linux desktop endpoints. The vulnerabilities can be chained together to gain root privileges on Linux systems, allowing attackers to deploy payloads, like a root backdoor, and perform other malicious actions via arbitrary root code execution. Moreover, the Nimbuspwn vulnerabilities could potentially be leveraged as a vector for root access by more sophisticated threats, such as malware or ransomware, to achieve greater impact on vulnerable devices."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb40aaaf6>",
                    "type": "UnknownWord",
                    "value": "chained"
                },
                "references": {
                    "sentences": [
                        "Microsoft has discovered several vulnerabilities, collectively referred to as Nimbuspwn, that could allow an attacker to elevate privileges to root on many Linux desktop endpoints. The vulnerabilities can be chained together to gain root privileges on Linux systems, allowing attackers to deploy payloads, like a root backdoor, and perform other malicious actions via arbitrary root code execution. Moreover, the Nimbuspwn vulnerabilities could potentially be leveraged as a vector for root access by more sophisticated threats, such as malware or ransomware, to achieve greater impact on vulnerable devices."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfb492bd3>",
                    "type": "UnknownWord",
                    "value": "listening"
                },
                "references": {
                    "sentences": [
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances.",
                        "D-Bus exposes a global System Bus and a per-session Session Bus. From an attackers perspective, the System Bus is more attractive since it will commonly have services that run as root listening to it.",
                        "An example of D-Bus usage would be receiving a video chat by a popular video conferencing apponce a video is established, the video conferencing app could send a D-bus signal publishing that a call has started. Apps listening to that message could respond appropriatelyfor example, mute their audio."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdf0e2633>",
                    "type": "UnknownWord",
                    "value": "bus"
                },
                "references": {
                    "sentences": [
                        "On many environments (e.g. Linux Mint) the service systemd-networkd that normally owns the org.freedesktop.network1 bus name does not start at boot by default.<crlf>Using advanced hunting in Microsoft Defender for Endpoint we were able to spot several processes running as the systemd-network user (which is permitted to own the bus name we require) running arbitrary code from world-writable locations. These include several gpgv plugins (launched when apt-get installs or upgrades) as well as the Erlang Port Mapper Daemon (epmd) which allows running arbitrary code under some scenarios.",
                        "Figure 1: Different ownership policies for the System Bus and the Session Bus",
                        "The astute reader will notice that the entire exploit elevates privileges assuming our exploit code can own the org.freedesktop.network1 bus name. While this sounds non-trivial, we have found several environments where this happens. Specifically:",
                        "Our team has started enumerating services that run as root and listen to messages on the System Bus, performing both code reviews and dynamic analysis. We have reported two information leak issues as a result:",
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables.",
                        "D-Bus exposes a global System Bus and a per-session Session Bus. From an attackers perspective, the System Bus is more attractive since it will commonly have services that run as root listening to it.",
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances."
                    ],
                    "titles": [
                        "Owning the bus name"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb33896>",
                    "type": "UnknownWord",
                    "value": "noticing"
                },
                "references": {
                    "sentences": [
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances.",
                        "While these are interesting, their severity is low an attacker can list files under directories that require high permissions to list files under. Then we started noticing interesting patterns in a systemd unit called networkd-dispatcher. The goal of networkd-dispatcher is to dispatch network status changes and optionally perform different scripts based on the new status. Interestingly, it runs on boot as root:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x613a46cc>",
                    "type": "UnknownWord",
                    "value": "systemd"
                },
                "references": {
                    "sentences": [
                        "While these are interesting, their severity is low an attacker can list files under directories that require high permissions to list files under. Then we started noticing interesting patterns in a systemd unit called networkd-dispatcher. The goal of networkd-dispatcher is to dispatch network status changes and optionally perform different scripts based on the new status. Interestingly, it runs on boot as root:",
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x20324604>",
                    "type": "UnknownWord",
                    "value": "networkd-dispatcher"
                },
                "references": {
                    "sentences": [
                        "Figure 2: networkd-dispatcher running as root",
                        "Directory traversal (CVE-2022-29799): none of the functions in the flow sanitize the OperationalState or the AdministrativeState. Since the states are used to build the script path, it is possible that a state would contain directory traversal patterns (e.g. ../../) to escape from the /etc/networkd-dispatcher base directory.<crlf>Symlink race: both the script discovery and subprocess.Popen follow symbolic links.<crlf>Time-of-check-time-of-use (TOCTOU) race condition (CVE-2022-29800): there is a certain time between the scripts being discovered and them being run. An attacker can abuse this vulnerability to replace scripts that networkd-dispatcher believes to be owned by root to ones that are not.",
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables.",
                        "Prepare a directory /tmp/nimbuspwn and plant a symlink /tmp/nimbuspwn/poc.d to point to /sbin. The /sbin directory was chosen specifically because it has many executables owned by root that do not block if run without additional arguments. This will abuse the symlink race issue we mentioned earlier.<crlf>For every executable filename under /sbin owned by root, plant the same filename under /tmp/nimbuspwn. For example, if /sbin/vgs is executable and owned by root, plant an executable file /tmp/nimbuspwn/vgs with the desired payload. This will help the attacker win the race condition imposed by the TOCTOU vulnerability.<crlf>Send a signal with the OperationalState ../../../tmp/nimbuspwn/poc. This abuses the directory traversal vulnerability and escapes the script directory.<crlf>The networkd-dispatcher signal handler kicks in and builds the script list from the directory /etc/networkd-dispatcher/../../../tmp/nimbuspwn/poc.d, which is really the symlink (/tmp/nimbuspwn/poc.d), which points to /sbin. Therefore, it creates a list composed of many executables owned by root.<crlf>Quickly change the symlink /tmp/nimbuspwn/poc.d to point to /tmp/nimbuspwn. This abuses the TOCTOU race condition vulnerabilitythe script path changes without networkd-dispatcher being aware.<crlf>The dispatcher starts running files that were initially under /sbin but in truth under the /tmp/nimbuspwn directory. Since the dispatcher believes those files are owned by root, it executes them blindly with subprocess.Popen as root. Therefore, our attacker has successfully exploited the vulnerability.",
                        "While these are interesting, their severity is low an attacker can list files under directories that require high permissions to list files under. Then we started noticing interesting patterns in a systemd unit called networkd-dispatcher. The goal of networkd-dispatcher is to dispatch network status changes and optionally perform different scripts based on the new status. Interestingly, it runs on boot as root:",
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances.",
                        "Upon examination of the networkd-dispatcher source code, we noticed an interesting flow:"
                    ],
                    "titles": [
                        "Code flow for networkd-dispatcher"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1cd21c02>",
                    "type": "UnknownWord",
                    "value": "symlink"
                },
                "references": {
                    "sentences": [
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances.",
                        "Prepare a directory /tmp/nimbuspwn and plant a symlink /tmp/nimbuspwn/poc.d to point to /sbin. The /sbin directory was chosen specifically because it has many executables owned by root that do not block if run without additional arguments. This will abuse the symlink race issue we mentioned earlier.<crlf>For every executable filename under /sbin owned by root, plant the same filename under /tmp/nimbuspwn. For example, if /sbin/vgs is executable and owned by root, plant an executable file /tmp/nimbuspwn/vgs with the desired payload. This will help the attacker win the race condition imposed by the TOCTOU vulnerability.<crlf>Send a signal with the OperationalState ../../../tmp/nimbuspwn/poc. This abuses the directory traversal vulnerability and escapes the script directory.<crlf>The networkd-dispatcher signal handler kicks in and builds the script list from the directory /etc/networkd-dispatcher/../../../tmp/nimbuspwn/poc.d, which is really the symlink (/tmp/nimbuspwn/poc.d), which points to /sbin. Therefore, it creates a list composed of many executables owned by root.<crlf>Quickly change the symlink /tmp/nimbuspwn/poc.d to point to /tmp/nimbuspwn. This abuses the TOCTOU race condition vulnerabilitythe script path changes without networkd-dispatcher being aware.<crlf>The dispatcher starts running files that were initially under /sbin but in truth under the /tmp/nimbuspwn directory. Since the dispatcher believes those files are owned by root, it executes them blindly with subprocess.Popen as root. Therefore, our attacker has successfully exploited the vulnerability.",
                        "Directory traversal (CVE-2022-29799): none of the functions in the flow sanitize the OperationalState or the AdministrativeState. Since the states are used to build the script path, it is possible that a state would contain directory traversal patterns (e.g. ../../) to escape from the /etc/networkd-dispatcher base directory.<crlf>Symlink race: both the script discovery and subprocess.Popen follow symbolic links.<crlf>Time-of-check-time-of-use (TOCTOU) race condition (CVE-2022-29800): there is a certain time between the scripts being discovered and them being run. An attacker can abuse this vulnerability to replace scripts that networkd-dispatcher believes to be owned by root to ones that are not."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xe146d464>",
                            "type": "File",
                            "value": "subprocess.popen"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1cd21c02>",
                            "type": "UnknownWord",
                            "value": "symlink"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe0fa9b2e>",
                    "type": "UnknownWord",
                    "value": "race"
                },
                "references": {
                    "sentences": [
                        "Figure 6: Our exploit implemented and winning the TOCTOU race",
                        "Directory traversal (CVE-2022-29799): none of the functions in the flow sanitize the OperationalState or the AdministrativeState. Since the states are used to build the script path, it is possible that a state would contain directory traversal patterns (e.g. ../../) to escape from the /etc/networkd-dispatcher base directory.<crlf>Symlink race: both the script discovery and subprocess.Popen follow symbolic links.<crlf>Time-of-check-time-of-use (TOCTOU) race condition (CVE-2022-29800): there is a certain time between the scripts being discovered and them being run. An attacker can abuse this vulnerability to replace scripts that networkd-dispatcher believes to be owned by root to ones that are not.",
                        "Prepare a directory /tmp/nimbuspwn and plant a symlink /tmp/nimbuspwn/poc.d to point to /sbin. The /sbin directory was chosen specifically because it has many executables owned by root that do not block if run without additional arguments. This will abuse the symlink race issue we mentioned earlier.<crlf>For every executable filename under /sbin owned by root, plant the same filename under /tmp/nimbuspwn. For example, if /sbin/vgs is executable and owned by root, plant an executable file /tmp/nimbuspwn/vgs with the desired payload. This will help the attacker win the race condition imposed by the TOCTOU vulnerability.<crlf>Send a signal with the OperationalState ../../../tmp/nimbuspwn/poc. This abuses the directory traversal vulnerability and escapes the script directory.<crlf>The networkd-dispatcher signal handler kicks in and builds the script list from the directory /etc/networkd-dispatcher/../../../tmp/nimbuspwn/poc.d, which is really the symlink (/tmp/nimbuspwn/poc.d), which points to /sbin. Therefore, it creates a list composed of many executables owned by root.<crlf>Quickly change the symlink /tmp/nimbuspwn/poc.d to point to /tmp/nimbuspwn. This abuses the TOCTOU race condition vulnerabilitythe script path changes without networkd-dispatcher being aware.<crlf>The dispatcher starts running files that were initially under /sbin but in truth under the /tmp/nimbuspwn directory. Since the dispatcher believes those files are owned by root, it executes them blindly with subprocess.Popen as root. Therefore, our attacker has successfully exploited the vulnerability.",
                        "Note that to win the TOCTOU race condition with high probability, we plant many files that can potentially run. Our experiments show three attempts were enough to win the TOCTOU race condition.",
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xe146d464>",
                            "type": "File",
                            "value": "subprocess.popen"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe0fa9b2e>",
                            "type": "UnknownWord",
                            "value": "race"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2f58749a>",
                    "type": "UnknownWord",
                    "value": "time-of-check-time-of-use"
                },
                "references": {
                    "sentences": [
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances.",
                        "Directory traversal (CVE-2022-29799): none of the functions in the flow sanitize the OperationalState or the AdministrativeState. Since the states are used to build the script path, it is possible that a state would contain directory traversal patterns (e.g. ../../) to escape from the /etc/networkd-dispatcher base directory.<crlf>Symlink race: both the script discovery and subprocess.Popen follow symbolic links.<crlf>Time-of-check-time-of-use (TOCTOU) race condition (CVE-2022-29800): there is a certain time between the scripts being discovered and them being run. An attacker can abuse this vulnerability to replace scripts that networkd-dispatcher believes to be owned by root to ones that are not."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7ca80d9>",
                    "type": "UnknownWord",
                    "value": "maintainers"
                },
                "references": {
                    "sentences": [
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbb43a460>",
                    "type": "UnknownWord",
                    "value": "cvd"
                },
                "references": {
                    "sentences": [
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x519018ad>",
                    "type": "UnknownWord",
                    "value": "msvr"
                },
                "references": {
                    "sentences": [
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x58848ede>",
                    "type": "UnknownWord",
                    "value": "fixes"
                },
                "references": {
                    "sentences": [
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x119f56d8>",
                    "type": "UnknownWord",
                    "value": "maintainer"
                },
                "references": {
                    "sentences": [
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x39043c28>",
                    "type": "UnknownWord",
                    "value": "clayton"
                },
                "references": {
                    "sentences": [
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2d46af10>",
                    "type": "UnknownWord",
                    "value": "craft"
                },
                "references": {
                    "sentences": [
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9b53e1a4>",
                    "type": "UnknownWord",
                    "value": "professionalism"
                },
                "references": {
                    "sentences": [
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x15bc2052>",
                    "type": "UnknownWord",
                    "value": "encouraged"
                },
                "references": {
                    "sentences": [
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd24de2a0>",
                    "type": "UnknownWord",
                    "value": "organizational"
                },
                "references": {
                    "sentences": [
                        "As organizational environments continue to rely on a diverse range of devices and systems, they require comprehensive solutions that provide cross-platform protection and a holistic view of their security posture to mitigate threats, such as Nimbuspwn. The growing number of vulnerabilities on Linux environments emphasize the need for strong monitoring of the platforms operating system and its components. Microsoft Defender for Endpoint enables organizations to gain this necessary visibility and detect such threats on Linux devices, allowing organizations to detect, manage, respond, and remediate vulnerabilities and threats across different platforms, including Windows, Linux, Mac, iOS, and Android."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x88241b63>",
                    "type": "UnknownWord",
                    "value": "cross-platform"
                },
                "references": {
                    "sentences": [
                        "As organizational environments continue to rely on a diverse range of devices and systems, they require comprehensive solutions that provide cross-platform protection and a holistic view of their security posture to mitigate threats, such as Nimbuspwn. The growing number of vulnerabilities on Linux environments emphasize the need for strong monitoring of the platforms operating system and its components. Microsoft Defender for Endpoint enables organizations to gain this necessary visibility and detect such threats on Linux devices, allowing organizations to detect, manage, respond, and remediate vulnerabilities and threats across different platforms, including Windows, Linux, Mac, iOS, and Android."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfd83b402>",
                    "type": "UnknownWord",
                    "value": "posture"
                },
                "references": {
                    "sentences": [
                        "Microsofts threat and vulnerability management capabilities help organizations monitor their overall security posture, providing real-time insights into risk with continuous vulnerability discovery, contextualized intelligent prioritization, and seamless one-click flaw remediation. Leveraging our research into the Nimbuspwn vulnerabilities to improve solutions, our threat and vulnerability management already covers CVE-2022-29799 and CVE-2022-29800 and indicates such vulnerable devices in the threat and vulnerability module in Microsoft Defender for Endpoint.",
                        "As organizational environments continue to rely on a diverse range of devices and systems, they require comprehensive solutions that provide cross-platform protection and a holistic view of their security posture to mitigate threats, such as Nimbuspwn. The growing number of vulnerabilities on Linux environments emphasize the need for strong monitoring of the platforms operating system and its components. Microsoft Defender for Endpoint enables organizations to gain this necessary visibility and detect such threats on Linux devices, allowing organizations to detect, manage, respond, and remediate vulnerabilities and threats across different platforms, including Windows, Linux, Mac, iOS, and Android."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8cecb4a6>",
                    "type": "UnknownWord",
                    "value": "emphasize"
                },
                "references": {
                    "sentences": [
                        "As organizational environments continue to rely on a diverse range of devices and systems, they require comprehensive solutions that provide cross-platform protection and a holistic view of their security posture to mitigate threats, such as Nimbuspwn. The growing number of vulnerabilities on Linux environments emphasize the need for strong monitoring of the platforms operating system and its components. Microsoft Defender for Endpoint enables organizations to gain this necessary visibility and detect such threats on Linux devices, allowing organizations to detect, manage, respond, and remediate vulnerabilities and threats across different platforms, including Windows, Linux, Mac, iOS, and Android."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf71197e5>",
                    "type": "UnknownWord",
                    "value": "cross-domain"
                },
                "references": {
                    "sentences": [
                        "In this blog post, we will share some information about the affected components and examine the vulnerabilities we uncovered. Detailing how our cross-domain visibility helps us uncover new and unknown threats to continually improve security, we are also sharing details from our research with the larger security community to underscore the importance of securing platforms and devices."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x51580b83>",
                    "type": "UnknownWord",
                    "value": "larger"
                },
                "references": {
                    "sentences": [
                        "Defending against the evolving threat landscape requires the ability to protect and secure users computing experiences, be it a Windows or non-Windows device. Microsoft continuously enriches our protection technologies through robust research that protects users and organizations across all the major platforms every single day. This case displayed how the ability to coordinate such research via expert, cross-industry collaboration is vital to effectively mitigate issues, regardless of the vulnerable device or platform in use. By sharing our research and other forms of threat intelligence, we can continue to collaborate with the larger security community and strive to build better protection for all.",
                        "In this blog post, we will share some information about the affected components and examine the vulnerabilities we uncovered. Detailing how our cross-domain visibility helps us uncover new and unknown threats to continually improve security, we are also sharing details from our research with the larger security community to underscore the importance of securing platforms and devices."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbf3dd14a>",
                    "type": "UnknownWord",
                    "value": "underscore"
                },
                "references": {
                    "sentences": [
                        "In this blog post, we will share some information about the affected components and examine the vulnerabilities we uncovered. Detailing how our cross-domain visibility helps us uncover new and unknown threats to continually improve security, we are also sharing details from our research with the larger security community to underscore the importance of securing platforms and devices."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4109689>",
                    "type": "UnknownWord",
                    "value": "securing"
                },
                "references": {
                    "sentences": [
                        "In this blog post, we will share some information about the affected components and examine the vulnerabilities we uncovered. Detailing how our cross-domain visibility helps us uncover new and unknown threats to continually improve security, we are also sharing details from our research with the larger security community to underscore the importance of securing platforms and devices."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4cead3f6>",
                    "type": "UnknownWord",
                    "value": "background d-bus"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Background D-Bus"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x86c97e0c>",
                    "type": "UnknownWord",
                    "value": "ipc"
                },
                "references": {
                    "sentences": [
                        "D-Bus (short for Desktop-Bus) is an inter-process communication channel (IPC) mechanism developed by the freedesktop.org project. D-Bus is a software-bus and allows processes on the same endpoint to communicate by transmitting messages and responding to them. D-Bus supports two main ways of communicating:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x13ce95d7>",
                    "type": "UnknownWord",
                    "value": "d-bus"
                },
                "references": {
                    "sentences": [
                        "Let us assume an adversary has a malicious D-Bus component that can send an arbitrary signal. An attacker can therefore do the following:",
                        "When connecting to the D-Bus, components are assigned with a unique identifier, which mitigates against attacks abusing PID-recycling. The unique identifier starts with a colon and has numbers in it separated by dots, such as :1.337. Components can use the D-Bus API to own identifiable names such as org.freedesktop.Avahi or com.ubuntu.SystemService. For D-Bus to allow such ownership, the requesting process context must be allowed under the D-Bus configuration files. Those configuration files are well documented and maintained under /usr/local/share/dbus-1/system.conf and /usr/local/share/dbus-1/session.conf (on some systems under /usr/local/dbus-1 directly). Specifically, the default system.conf does not allow ownership unless specified otherwise in other included configuration files (commonly under /etc/dbus-1/system.d).",
                        "D-Bus exposes a global System Bus and a per-session Session Bus. From an attackers perspective, the System Bus is more attractive since it will commonly have services that run as root listening to it.",
                        "There are many D-Bus components shipped by default on popular Linux desktop environments. Since those components run at different privileges and respond to messages, D-Bus components are an attractive target for attackers. Indeed, there have been interesting vulnerabilities in the past related to buggy D-Bus services, including USBCreator Elevation of Privilege, Blueman Elevation of Privilege by command injection, and other similar scenarios.",
                        "An example of D-Bus usage would be receiving a video chat by a popular video conferencing apponce a video is established, the video conferencing app could send a D-bus signal publishing that a call has started. Apps listening to that message could respond appropriatelyfor example, mute their audio.",
                        "D-Bus (short for Desktop-Bus) is an inter-process communication channel (IPC) mechanism developed by the freedesktop.org project. D-Bus is a software-bus and allows processes on the same endpoint to communicate by transmitting messages and responding to them. D-Bus supports two main ways of communicating:"
                    ],
                    "titles": [
                        "D-Bus name ownership"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x9dfcdb0e>",
                            "type": "File",
                            "value": "org.freedesktop.avahi"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x13ce95d7>",
                            "type": "UnknownWord",
                            "value": "d-bus"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x59c208f5>",
                    "type": "UnknownWord",
                    "value": "desktop-bus"
                },
                "references": {
                    "sentences": [
                        "D-Bus (short for Desktop-Bus) is an inter-process communication channel (IPC) mechanism developed by the freedesktop.org project. D-Bus is a software-bus and allows processes on the same endpoint to communicate by transmitting messages and responding to them. D-Bus supports two main ways of communicating:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x753dd8dc>",
                    "type": "UnknownWord",
                    "value": "inter-process"
                },
                "references": {
                    "sentences": [
                        "D-Bus (short for Desktop-Bus) is an inter-process communication channel (IPC) mechanism developed by the freedesktop.org project. D-Bus is a software-bus and allows processes on the same endpoint to communicate by transmitting messages and responding to them. D-Bus supports two main ways of communicating:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x476da971>",
                    "type": "UnknownWord",
                    "value": "software-bus"
                },
                "references": {
                    "sentences": [
                        "D-Bus (short for Desktop-Bus) is an inter-process communication channel (IPC) mechanism developed by the freedesktop.org project. D-Bus is a software-bus and allows processes on the same endpoint to communicate by transmitting messages and responding to them. D-Bus supports two main ways of communicating:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x97f9c186>",
                    "type": "UnknownWord",
                    "value": "transmitting"
                },
                "references": {
                    "sentences": [
                        "D-Bus (short for Desktop-Bus) is an inter-process communication channel (IPC) mechanism developed by the freedesktop.org project. D-Bus is a software-bus and allows processes on the same endpoint to communicate by transmitting messages and responding to them. D-Bus supports two main ways of communicating:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3016a860>",
                    "type": "UnknownWord",
                    "value": "request-response"
                },
                "references": {
                    "sentences": [
                        "Methods used for request-response communications.<crlf>Signals used for publish/subscribe communications."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbc736248>",
                    "type": "UnknownWord",
                    "value": "publish"
                },
                "references": {
                    "sentences": [
                        "Methods used for request-response communications.<crlf>Signals used for publish/subscribe communications."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfa606189>",
                    "type": "UnknownWord",
                    "value": "conferencing"
                },
                "references": {
                    "sentences": [
                        "An example of D-Bus usage would be receiving a video chat by a popular video conferencing apponce a video is established, the video conferencing app could send a D-bus signal publishing that a call has started. Apps listening to that message could respond appropriatelyfor example, mute their audio."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1d2efd3d>",
                    "type": "UnknownWord",
                    "value": "apponce"
                },
                "references": {
                    "sentences": [
                        "An example of D-Bus usage would be receiving a video chat by a popular video conferencing apponce a video is established, the video conferencing app could send a D-bus signal publishing that a call has started. Apps listening to that message could respond appropriatelyfor example, mute their audio."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbca5eaaa>",
                    "type": "UnknownWord",
                    "value": "publishing"
                },
                "references": {
                    "sentences": [
                        "An example of D-Bus usage would be receiving a video chat by a popular video conferencing apponce a video is established, the video conferencing app could send a D-bus signal publishing that a call has started. Apps listening to that message could respond appropriatelyfor example, mute their audio."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x55cf6b1e>",
                    "type": "UnknownWord",
                    "value": "appropriatelyfor"
                },
                "references": {
                    "sentences": [
                        "An example of D-Bus usage would be receiving a video chat by a popular video conferencing apponce a video is established, the video conferencing app could send a D-bus signal publishing that a call has started. Apps listening to that message could respond appropriatelyfor example, mute their audio."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5e6e4b9f>",
                    "type": "UnknownWord",
                    "value": "mute"
                },
                "references": {
                    "sentences": [
                        "An example of D-Bus usage would be receiving a video chat by a popular video conferencing apponce a video is established, the video conferencing app could send a D-bus signal publishing that a call has started. Apps listening to that message could respond appropriatelyfor example, mute their audio."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7a672a58>",
                    "type": "UnknownWord",
                    "value": "shipped"
                },
                "references": {
                    "sentences": [
                        "There are many D-Bus components shipped by default on popular Linux desktop environments. Since those components run at different privileges and respond to messages, D-Bus components are an attractive target for attackers. Indeed, there have been interesting vulnerabilities in the past related to buggy D-Bus services, including USBCreator Elevation of Privilege, Blueman Elevation of Privilege by command injection, and other similar scenarios."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1300c2d7>",
                    "type": "UnknownWord",
                    "value": "indeed"
                },
                "references": {
                    "sentences": [
                        "There are many D-Bus components shipped by default on popular Linux desktop environments. Since those components run at different privileges and respond to messages, D-Bus components are an attractive target for attackers. Indeed, there have been interesting vulnerabilities in the past related to buggy D-Bus services, including USBCreator Elevation of Privilege, Blueman Elevation of Privilege by command injection, and other similar scenarios."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe2b26f70>",
                    "type": "UnknownWord",
                    "value": "buggy"
                },
                "references": {
                    "sentences": [
                        "There are many D-Bus components shipped by default on popular Linux desktop environments. Since those components run at different privileges and respond to messages, D-Bus components are an attractive target for attackers. Indeed, there have been interesting vulnerabilities in the past related to buggy D-Bus services, including USBCreator Elevation of Privilege, Blueman Elevation of Privilege by command injection, and other similar scenarios."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8a67df54>",
                    "type": "UnknownWord",
                    "value": "usbcreator"
                },
                "references": {
                    "sentences": [
                        "There are many D-Bus components shipped by default on popular Linux desktop environments. Since those components run at different privileges and respond to messages, D-Bus components are an attractive target for attackers. Indeed, there have been interesting vulnerabilities in the past related to buggy D-Bus services, including USBCreator Elevation of Privilege, Blueman Elevation of Privilege by command injection, and other similar scenarios."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3d7c0a8d>",
                    "type": "UnknownWord",
                    "value": "per-session"
                },
                "references": {
                    "sentences": [
                        "D-Bus exposes a global System Bus and a per-session Session Bus. From an attackers perspective, the System Bus is more attractive since it will commonly have services that run as root listening to it."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9e37188f>",
                    "type": "UnknownWord",
                    "value": "pid-recycling"
                },
                "references": {
                    "sentences": [
                        "When connecting to the D-Bus, components are assigned with a unique identifier, which mitigates against attacks abusing PID-recycling. The unique identifier starts with a colon and has numbers in it separated by dots, such as :1.337. Components can use the D-Bus API to own identifiable names such as org.freedesktop.Avahi or com.ubuntu.SystemService. For D-Bus to allow such ownership, the requesting process context must be allowed under the D-Bus configuration files. Those configuration files are well documented and maintained under /usr/local/share/dbus-1/system.conf and /usr/local/share/dbus-1/session.conf (on some systems under /usr/local/dbus-1 directly). Specifically, the default system.conf does not allow ownership unless specified otherwise in other included configuration files (commonly under /etc/dbus-1/system.d)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x81accd13>",
                    "type": "UnknownWord",
                    "value": "ubuntu"
                },
                "references": {
                    "sentences": [
                        "When connecting to the D-Bus, components are assigned with a unique identifier, which mitigates against attacks abusing PID-recycling. The unique identifier starts with a colon and has numbers in it separated by dots, such as :1.337. Components can use the D-Bus API to own identifiable names such as org.freedesktop.Avahi or com.ubuntu.SystemService. For D-Bus to allow such ownership, the requesting process context must be allowed under the D-Bus configuration files. Those configuration files are well documented and maintained under /usr/local/share/dbus-1/system.conf and /usr/local/share/dbus-1/session.conf (on some systems under /usr/local/dbus-1 directly). Specifically, the default system.conf does not allow ownership unless specified otherwise in other included configuration files (commonly under /etc/dbus-1/system.d)."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x9dfcdb0e>",
                            "type": "File",
                            "value": "org.freedesktop.avahi"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x81accd13>",
                            "type": "UnknownWord",
                            "value": "ubuntu"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8d82bd5e>",
                    "type": "UnknownWord",
                    "value": "systemservice"
                },
                "references": {
                    "sentences": [
                        "When connecting to the D-Bus, components are assigned with a unique identifier, which mitigates against attacks abusing PID-recycling. The unique identifier starts with a colon and has numbers in it separated by dots, such as :1.337. Components can use the D-Bus API to own identifiable names such as org.freedesktop.Avahi or com.ubuntu.SystemService. For D-Bus to allow such ownership, the requesting process context must be allowed under the D-Bus configuration files. Those configuration files are well documented and maintained under /usr/local/share/dbus-1/system.conf and /usr/local/share/dbus-1/session.conf (on some systems under /usr/local/dbus-1 directly). Specifically, the default system.conf does not allow ownership unless specified otherwise in other included configuration files (commonly under /etc/dbus-1/system.d)."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x9dfcdb0e>",
                            "type": "File",
                            "value": "org.freedesktop.avahi"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8d82bd5e>",
                            "type": "UnknownWord",
                            "value": "systemservice"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x756ef343>",
                    "type": "UnknownWord",
                    "value": "requesting"
                },
                "references": {
                    "sentences": [
                        "When connecting to the D-Bus, components are assigned with a unique identifier, which mitigates against attacks abusing PID-recycling. The unique identifier starts with a colon and has numbers in it separated by dots, such as :1.337. Components can use the D-Bus API to own identifiable names such as org.freedesktop.Avahi or com.ubuntu.SystemService. For D-Bus to allow such ownership, the requesting process context must be allowed under the D-Bus configuration files. Those configuration files are well documented and maintained under /usr/local/share/dbus-1/system.conf and /usr/local/share/dbus-1/session.conf (on some systems under /usr/local/dbus-1 directly). Specifically, the default system.conf does not allow ownership unless specified otherwise in other included configuration files (commonly under /etc/dbus-1/system.d)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x42030cbf>",
                    "type": "UnknownWord",
                    "value": "usr"
                },
                "references": {
                    "sentences": [
                        "When connecting to the D-Bus, components are assigned with a unique identifier, which mitigates against attacks abusing PID-recycling. The unique identifier starts with a colon and has numbers in it separated by dots, such as :1.337. Components can use the D-Bus API to own identifiable names such as org.freedesktop.Avahi or com.ubuntu.SystemService. For D-Bus to allow such ownership, the requesting process context must be allowed under the D-Bus configuration files. Those configuration files are well documented and maintained under /usr/local/share/dbus-1/system.conf and /usr/local/share/dbus-1/session.conf (on some systems under /usr/local/dbus-1 directly). Specifically, the default system.conf does not allow ownership unless specified otherwise in other included configuration files (commonly under /etc/dbus-1/system.d)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x28ca6807>",
                    "type": "UnknownWord",
                    "value": "dbus-1"
                },
                "references": {
                    "sentences": [
                        "When connecting to the D-Bus, components are assigned with a unique identifier, which mitigates against attacks abusing PID-recycling. The unique identifier starts with a colon and has numbers in it separated by dots, such as :1.337. Components can use the D-Bus API to own identifiable names such as org.freedesktop.Avahi or com.ubuntu.SystemService. For D-Bus to allow such ownership, the requesting process context must be allowed under the D-Bus configuration files. Those configuration files are well documented and maintained under /usr/local/share/dbus-1/system.conf and /usr/local/share/dbus-1/session.conf (on some systems under /usr/local/dbus-1 directly). Specifically, the default system.conf does not allow ownership unless specified otherwise in other included configuration files (commonly under /etc/dbus-1/system.d)."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdabde5f0>",
                            "type": "File",
                            "value": "system.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x28ca6807>",
                            "type": "UnknownWord",
                            "value": "dbus-1"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2e4dd55e>",
                    "type": "UnknownWord",
                    "value": "conf"
                },
                "references": {
                    "sentences": [
                        "When connecting to the D-Bus, components are assigned with a unique identifier, which mitigates against attacks abusing PID-recycling. The unique identifier starts with a colon and has numbers in it separated by dots, such as :1.337. Components can use the D-Bus API to own identifiable names such as org.freedesktop.Avahi or com.ubuntu.SystemService. For D-Bus to allow such ownership, the requesting process context must be allowed under the D-Bus configuration files. Those configuration files are well documented and maintained under /usr/local/share/dbus-1/system.conf and /usr/local/share/dbus-1/session.conf (on some systems under /usr/local/dbus-1 directly). Specifically, the default system.conf does not allow ownership unless specified otherwise in other included configuration files (commonly under /etc/dbus-1/system.d)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc126d1be>",
                    "type": "UnknownWord",
                    "value": "unless"
                },
                "references": {
                    "sentences": [
                        "When connecting to the D-Bus, components are assigned with a unique identifier, which mitigates against attacks abusing PID-recycling. The unique identifier starts with a colon and has numbers in it separated by dots, such as :1.337. Components can use the D-Bus API to own identifiable names such as org.freedesktop.Avahi or com.ubuntu.SystemService. For D-Bus to allow such ownership, the requesting process context must be allowed under the D-Bus configuration files. Those configuration files are well documented and maintained under /usr/local/share/dbus-1/system.conf and /usr/local/share/dbus-1/session.conf (on some systems under /usr/local/dbus-1 directly). Specifically, the default system.conf does not allow ownership unless specified otherwise in other included configuration files (commonly under /etc/dbus-1/system.d)."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdabde5f0>",
                            "type": "File",
                            "value": "system.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc126d1be>",
                            "type": "UnknownWord",
                            "value": "unless"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8b771f59>",
                    "type": "UnknownWord",
                    "value": "existsthe"
                },
                "references": {
                    "sentences": [
                        "Additionally, if the name requested already existsthe request will not be granted until the owning process releases the name."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa27aca07>",
                    "type": "UnknownWord",
                    "value": "listen"
                },
                "references": {
                    "sentences": [
                        "Our team has started enumerating services that run as root and listen to messages on the System Bus, performing both code reviews and dynamic analysis. We have reported two information leak issues as a result:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x26be4d69>",
                    "type": "UnknownWord",
                    "value": "blueman"
                },
                "references": {
                    "sentences": [
                        "Directory Info Disclosure in Blueman<crlf>Directory Info Disclosure in PackageKit (CVE-2022-0987)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb17ebf6c>",
                    "type": "UnknownWord",
                    "value": "packagekit"
                },
                "references": {
                    "sentences": [
                        "Directory Info Disclosure in Blueman<crlf>Directory Info Disclosure in PackageKit (CVE-2022-0987)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6655b77e>",
                    "type": "UnknownWord",
                    "value": "optionally"
                },
                "references": {
                    "sentences": [
                        "While these are interesting, their severity is low an attacker can list files under directories that require high permissions to list files under. Then we started noticing interesting patterns in a systemd unit called networkd-dispatcher. The goal of networkd-dispatcher is to dispatch network status changes and optionally perform different scripts based on the new status. Interestingly, it runs on boot as root:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd9a52b71>",
                    "type": "UnknownWord",
                    "value": "freedesktop"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables.",
                        "On many environments (e.g. Linux Mint) the service systemd-networkd that normally owns the org.freedesktop.network1 bus name does not start at boot by default.<crlf>Using advanced hunting in Microsoft Defender for Endpoint we were able to spot several processes running as the systemd-network user (which is permitted to own the bus name we require) running arbitrary code from world-writable locations. These include several gpgv plugins (launched when apt-get installs or upgrades) as well as the Erlang Port Mapper Daemon (epmd) which allows running arbitrary code under some scenarios.",
                        "The astute reader will notice that the entire exploit elevates privileges assuming our exploit code can own the org.freedesktop.network1 bus name. While this sounds non-trivial, we have found several environments where this happens. Specifically:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc22877c7>",
                    "type": "UnknownWord",
                    "value": "network1"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables.",
                        "On many environments (e.g. Linux Mint) the service systemd-networkd that normally owns the org.freedesktop.network1 bus name does not start at boot by default.<crlf>Using advanced hunting in Microsoft Defender for Endpoint we were able to spot several processes running as the systemd-network user (which is permitted to own the bus name we require) running arbitrary code from world-writable locations. These include several gpgv plugins (launched when apt-get installs or upgrades) as well as the Erlang Port Mapper Daemon (epmd) which allows running arbitrary code under some scenarios.",
                        "The astute reader will notice that the entire exploit elevates privileges assuming our exploit code can own the org.freedesktop.network1 bus name. While this sounds non-trivial, we have found several environments where this happens. Specifically:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x132ecd37>",
                    "type": "UnknownWord",
                    "value": "propertieschanged"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7a3f7875>",
                    "type": "UnknownWord",
                    "value": "_receive_signal"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd6e4e2d5>",
                    "type": "UnknownWord",
                    "value": "handler"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables.",
                        "Prepare a directory /tmp/nimbuspwn and plant a symlink /tmp/nimbuspwn/poc.d to point to /sbin. The /sbin directory was chosen specifically because it has many executables owned by root that do not block if run without additional arguments. This will abuse the symlink race issue we mentioned earlier.<crlf>For every executable filename under /sbin owned by root, plant the same filename under /tmp/nimbuspwn. For example, if /sbin/vgs is executable and owned by root, plant an executable file /tmp/nimbuspwn/vgs with the desired payload. This will help the attacker win the race condition imposed by the TOCTOU vulnerability.<crlf>Send a signal with the OperationalState ../../../tmp/nimbuspwn/poc. This abuses the directory traversal vulnerability and escapes the script directory.<crlf>The networkd-dispatcher signal handler kicks in and builds the script list from the directory /etc/networkd-dispatcher/../../../tmp/nimbuspwn/poc.d, which is really the symlink (/tmp/nimbuspwn/poc.d), which points to /sbin. Therefore, it creates a list composed of many executables owned by root.<crlf>Quickly change the symlink /tmp/nimbuspwn/poc.d to point to /tmp/nimbuspwn. This abuses the TOCTOU race condition vulnerabilitythe script path changes without networkd-dispatcher being aware.<crlf>The dispatcher starts running files that were initially under /sbin but in truth under the /tmp/nimbuspwn directory. Since the dispatcher believes those files are owned by root, it executes them blindly with subprocess.Popen as root. Therefore, our attacker has successfully exploited the vulnerability."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1ac6e2c3>",
                    "type": "UnknownWord",
                    "value": "statesoperationalstate"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x398236dc>",
                    "type": "UnknownWord",
                    "value": "administrativestateeach"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x55b3a03a>",
                    "type": "UnknownWord",
                    "value": "fetched"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x18f5a0bd>",
                    "type": "UnknownWord",
                    "value": "statesif"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd3ff2770>",
                    "type": "UnknownWord",
                    "value": "arent"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcd72ea2d>",
                    "type": "UnknownWord",
                    "value": "emptythe"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7666633c>",
                    "type": "UnknownWord",
                    "value": "handle_state"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5323e639>",
                    "type": "UnknownWord",
                    "value": "invoked"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x93edd784>",
                    "type": "UnknownWord",
                    "value": "_handle_one_state"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdc7365c3>",
                    "type": "UnknownWord",
                    "value": "_run_hooks_for_state"
                },
                "references": {
                    "sentences": [
                        "Figure 3: _run_hooks_for_state source code some parts omitted for brevity",
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcbd059f9>",
                    "type": "UnknownWord",
                    "value": "discovering"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x185a3476>",
                    "type": "UnknownWord",
                    "value": "invoking"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf53c9476>",
                    "type": "UnknownWord",
                    "value": "get_script_list"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x72363cfb>",
                    "type": "UnknownWord",
                    "value": "scripts_in_path"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables.",
                        "Figure 4: Building the script list in the scripts_in_path method, including the vulnerable code with subdir poisoned."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6e26e80a>",
                    "type": "UnknownWord",
                    "value": "<state>"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf07bf123>",
                    "type": "UnknownWord",
                    "value": "sorts"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb62c6f50>",
                    "type": "UnknownWord",
                    "value": "supplying"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xe146d464>",
                            "type": "File",
                            "value": "subprocess.popen"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb62c6f50>",
                            "type": "UnknownWord",
                            "value": "supplying"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x44cba860>",
                    "type": "UnknownWord",
                    "value": "omitted"
                },
                "references": {
                    "sentences": [
                        "Figure 3: _run_hooks_for_state source code some parts omitted for brevity"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc7c52edf>",
                    "type": "UnknownWord",
                    "value": "brevity"
                },
                "references": {
                    "sentences": [
                        "Figure 3: _run_hooks_for_state source code some parts omitted for brevity"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc17139b2>",
                    "type": "UnknownWord",
                    "value": "sanitize"
                },
                "references": {
                    "sentences": [
                        "Directory traversal (CVE-2022-29799): none of the functions in the flow sanitize the OperationalState or the AdministrativeState. Since the states are used to build the script path, it is possible that a state would contain directory traversal patterns (e.g. ../../) to escape from the /etc/networkd-dispatcher base directory.<crlf>Symlink race: both the script discovery and subprocess.Popen follow symbolic links.<crlf>Time-of-check-time-of-use (TOCTOU) race condition (CVE-2022-29800): there is a certain time between the scripts being discovered and them being run. An attacker can abuse this vulnerability to replace scripts that networkd-dispatcher believes to be owned by root to ones that are not."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x227c629e>",
                    "type": "UnknownWord",
                    "value": "operationalstate"
                },
                "references": {
                    "sentences": [
                        "Directory traversal (CVE-2022-29799): none of the functions in the flow sanitize the OperationalState or the AdministrativeState. Since the states are used to build the script path, it is possible that a state would contain directory traversal patterns (e.g. ../../) to escape from the /etc/networkd-dispatcher base directory.<crlf>Symlink race: both the script discovery and subprocess.Popen follow symbolic links.<crlf>Time-of-check-time-of-use (TOCTOU) race condition (CVE-2022-29800): there is a certain time between the scripts being discovered and them being run. An attacker can abuse this vulnerability to replace scripts that networkd-dispatcher believes to be owned by root to ones that are not.",
                        "Prepare a directory /tmp/nimbuspwn and plant a symlink /tmp/nimbuspwn/poc.d to point to /sbin. The /sbin directory was chosen specifically because it has many executables owned by root that do not block if run without additional arguments. This will abuse the symlink race issue we mentioned earlier.<crlf>For every executable filename under /sbin owned by root, plant the same filename under /tmp/nimbuspwn. For example, if /sbin/vgs is executable and owned by root, plant an executable file /tmp/nimbuspwn/vgs with the desired payload. This will help the attacker win the race condition imposed by the TOCTOU vulnerability.<crlf>Send a signal with the OperationalState ../../../tmp/nimbuspwn/poc. This abuses the directory traversal vulnerability and escapes the script directory.<crlf>The networkd-dispatcher signal handler kicks in and builds the script list from the directory /etc/networkd-dispatcher/../../../tmp/nimbuspwn/poc.d, which is really the symlink (/tmp/nimbuspwn/poc.d), which points to /sbin. Therefore, it creates a list composed of many executables owned by root.<crlf>Quickly change the symlink /tmp/nimbuspwn/poc.d to point to /tmp/nimbuspwn. This abuses the TOCTOU race condition vulnerabilitythe script path changes without networkd-dispatcher being aware.<crlf>The dispatcher starts running files that were initially under /sbin but in truth under the /tmp/nimbuspwn directory. Since the dispatcher believes those files are owned by root, it executes them blindly with subprocess.Popen as root. Therefore, our attacker has successfully exploited the vulnerability."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8c28f2c0>",
                    "type": "UnknownWord",
                    "value": "administrativestate"
                },
                "references": {
                    "sentences": [
                        "Directory traversal (CVE-2022-29799): none of the functions in the flow sanitize the OperationalState or the AdministrativeState. Since the states are used to build the script path, it is possible that a state would contain directory traversal patterns (e.g. ../../) to escape from the /etc/networkd-dispatcher base directory.<crlf>Symlink race: both the script discovery and subprocess.Popen follow symbolic links.<crlf>Time-of-check-time-of-use (TOCTOU) race condition (CVE-2022-29800): there is a certain time between the scripts being discovered and them being run. An attacker can abuse this vulnerability to replace scripts that networkd-dispatcher believes to be owned by root to ones that are not."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa772a71>",
                    "type": "UnknownWord",
                    "value": "symbolic"
                },
                "references": {
                    "sentences": [
                        "Directory traversal (CVE-2022-29799): none of the functions in the flow sanitize the OperationalState or the AdministrativeState. Since the states are used to build the script path, it is possible that a state would contain directory traversal patterns (e.g. ../../) to escape from the /etc/networkd-dispatcher base directory.<crlf>Symlink race: both the script discovery and subprocess.Popen follow symbolic links.<crlf>Time-of-check-time-of-use (TOCTOU) race condition (CVE-2022-29800): there is a certain time between the scripts being discovered and them being run. An attacker can abuse this vulnerability to replace scripts that networkd-dispatcher believes to be owned by root to ones that are not."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xe146d464>",
                            "type": "File",
                            "value": "subprocess.popen"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa772a71>",
                            "type": "UnknownWord",
                            "value": "symbolic"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6433193a>",
                    "type": "UnknownWord",
                    "value": "subdir"
                },
                "references": {
                    "sentences": [
                        "Figure 4: Building the script list in the scripts_in_path method, including the vulnerable code with subdir poisoned."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf05c8e53>",
                    "type": "UnknownWord",
                    "value": "plant"
                },
                "references": {
                    "sentences": [
                        "Note that to win the TOCTOU race condition with high probability, we plant many files that can potentially run. Our experiments show three attempts were enough to win the TOCTOU race condition.",
                        "Prepare a directory /tmp/nimbuspwn and plant a symlink /tmp/nimbuspwn/poc.d to point to /sbin. The /sbin directory was chosen specifically because it has many executables owned by root that do not block if run without additional arguments. This will abuse the symlink race issue we mentioned earlier.<crlf>For every executable filename under /sbin owned by root, plant the same filename under /tmp/nimbuspwn. For example, if /sbin/vgs is executable and owned by root, plant an executable file /tmp/nimbuspwn/vgs with the desired payload. This will help the attacker win the race condition imposed by the TOCTOU vulnerability.<crlf>Send a signal with the OperationalState ../../../tmp/nimbuspwn/poc. This abuses the directory traversal vulnerability and escapes the script directory.<crlf>The networkd-dispatcher signal handler kicks in and builds the script list from the directory /etc/networkd-dispatcher/../../../tmp/nimbuspwn/poc.d, which is really the symlink (/tmp/nimbuspwn/poc.d), which points to /sbin. Therefore, it creates a list composed of many executables owned by root.<crlf>Quickly change the symlink /tmp/nimbuspwn/poc.d to point to /tmp/nimbuspwn. This abuses the TOCTOU race condition vulnerabilitythe script path changes without networkd-dispatcher being aware.<crlf>The dispatcher starts running files that were initially under /sbin but in truth under the /tmp/nimbuspwn directory. Since the dispatcher believes those files are owned by root, it executes them blindly with subprocess.Popen as root. Therefore, our attacker has successfully exploited the vulnerability."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x57e6ed8e>",
                    "type": "UnknownWord",
                    "value": "sbin"
                },
                "references": {
                    "sentences": [
                        "Prepare a directory /tmp/nimbuspwn and plant a symlink /tmp/nimbuspwn/poc.d to point to /sbin. The /sbin directory was chosen specifically because it has many executables owned by root that do not block if run without additional arguments. This will abuse the symlink race issue we mentioned earlier.<crlf>For every executable filename under /sbin owned by root, plant the same filename under /tmp/nimbuspwn. For example, if /sbin/vgs is executable and owned by root, plant an executable file /tmp/nimbuspwn/vgs with the desired payload. This will help the attacker win the race condition imposed by the TOCTOU vulnerability.<crlf>Send a signal with the OperationalState ../../../tmp/nimbuspwn/poc. This abuses the directory traversal vulnerability and escapes the script directory.<crlf>The networkd-dispatcher signal handler kicks in and builds the script list from the directory /etc/networkd-dispatcher/../../../tmp/nimbuspwn/poc.d, which is really the symlink (/tmp/nimbuspwn/poc.d), which points to /sbin. Therefore, it creates a list composed of many executables owned by root.<crlf>Quickly change the symlink /tmp/nimbuspwn/poc.d to point to /tmp/nimbuspwn. This abuses the TOCTOU race condition vulnerabilitythe script path changes without networkd-dispatcher being aware.<crlf>The dispatcher starts running files that were initially under /sbin but in truth under the /tmp/nimbuspwn directory. Since the dispatcher believes those files are owned by root, it executes them blindly with subprocess.Popen as root. Therefore, our attacker has successfully exploited the vulnerability."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xef583af9>",
                    "type": "UnknownWord",
                    "value": "vgs"
                },
                "references": {
                    "sentences": [
                        "Prepare a directory /tmp/nimbuspwn and plant a symlink /tmp/nimbuspwn/poc.d to point to /sbin. The /sbin directory was chosen specifically because it has many executables owned by root that do not block if run without additional arguments. This will abuse the symlink race issue we mentioned earlier.<crlf>For every executable filename under /sbin owned by root, plant the same filename under /tmp/nimbuspwn. For example, if /sbin/vgs is executable and owned by root, plant an executable file /tmp/nimbuspwn/vgs with the desired payload. This will help the attacker win the race condition imposed by the TOCTOU vulnerability.<crlf>Send a signal with the OperationalState ../../../tmp/nimbuspwn/poc. This abuses the directory traversal vulnerability and escapes the script directory.<crlf>The networkd-dispatcher signal handler kicks in and builds the script list from the directory /etc/networkd-dispatcher/../../../tmp/nimbuspwn/poc.d, which is really the symlink (/tmp/nimbuspwn/poc.d), which points to /sbin. Therefore, it creates a list composed of many executables owned by root.<crlf>Quickly change the symlink /tmp/nimbuspwn/poc.d to point to /tmp/nimbuspwn. This abuses the TOCTOU race condition vulnerabilitythe script path changes without networkd-dispatcher being aware.<crlf>The dispatcher starts running files that were initially under /sbin but in truth under the /tmp/nimbuspwn directory. Since the dispatcher believes those files are owned by root, it executes them blindly with subprocess.Popen as root. Therefore, our attacker has successfully exploited the vulnerability."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x77fcd70c>",
                    "type": "UnknownWord",
                    "value": "imposed"
                },
                "references": {
                    "sentences": [
                        "Prepare a directory /tmp/nimbuspwn and plant a symlink /tmp/nimbuspwn/poc.d to point to /sbin. The /sbin directory was chosen specifically because it has many executables owned by root that do not block if run without additional arguments. This will abuse the symlink race issue we mentioned earlier.<crlf>For every executable filename under /sbin owned by root, plant the same filename under /tmp/nimbuspwn. For example, if /sbin/vgs is executable and owned by root, plant an executable file /tmp/nimbuspwn/vgs with the desired payload. This will help the attacker win the race condition imposed by the TOCTOU vulnerability.<crlf>Send a signal with the OperationalState ../../../tmp/nimbuspwn/poc. This abuses the directory traversal vulnerability and escapes the script directory.<crlf>The networkd-dispatcher signal handler kicks in and builds the script list from the directory /etc/networkd-dispatcher/../../../tmp/nimbuspwn/poc.d, which is really the symlink (/tmp/nimbuspwn/poc.d), which points to /sbin. Therefore, it creates a list composed of many executables owned by root.<crlf>Quickly change the symlink /tmp/nimbuspwn/poc.d to point to /tmp/nimbuspwn. This abuses the TOCTOU race condition vulnerabilitythe script path changes without networkd-dispatcher being aware.<crlf>The dispatcher starts running files that were initially under /sbin but in truth under the /tmp/nimbuspwn directory. Since the dispatcher believes those files are owned by root, it executes them blindly with subprocess.Popen as root. Therefore, our attacker has successfully exploited the vulnerability."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc9356482>",
                    "type": "UnknownWord",
                    "value": "vulnerabilitythe"
                },
                "references": {
                    "sentences": [
                        "Prepare a directory /tmp/nimbuspwn and plant a symlink /tmp/nimbuspwn/poc.d to point to /sbin. The /sbin directory was chosen specifically because it has many executables owned by root that do not block if run without additional arguments. This will abuse the symlink race issue we mentioned earlier.<crlf>For every executable filename under /sbin owned by root, plant the same filename under /tmp/nimbuspwn. For example, if /sbin/vgs is executable and owned by root, plant an executable file /tmp/nimbuspwn/vgs with the desired payload. This will help the attacker win the race condition imposed by the TOCTOU vulnerability.<crlf>Send a signal with the OperationalState ../../../tmp/nimbuspwn/poc. This abuses the directory traversal vulnerability and escapes the script directory.<crlf>The networkd-dispatcher signal handler kicks in and builds the script list from the directory /etc/networkd-dispatcher/../../../tmp/nimbuspwn/poc.d, which is really the symlink (/tmp/nimbuspwn/poc.d), which points to /sbin. Therefore, it creates a list composed of many executables owned by root.<crlf>Quickly change the symlink /tmp/nimbuspwn/poc.d to point to /tmp/nimbuspwn. This abuses the TOCTOU race condition vulnerabilitythe script path changes without networkd-dispatcher being aware.<crlf>The dispatcher starts running files that were initially under /sbin but in truth under the /tmp/nimbuspwn directory. Since the dispatcher believes those files are owned by root, it executes them blindly with subprocess.Popen as root. Therefore, our attacker has successfully exploited the vulnerability."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x26ad5415>",
                    "type": "UnknownWord",
                    "value": "blindly"
                },
                "references": {
                    "sentences": [
                        "Prepare a directory /tmp/nimbuspwn and plant a symlink /tmp/nimbuspwn/poc.d to point to /sbin. The /sbin directory was chosen specifically because it has many executables owned by root that do not block if run without additional arguments. This will abuse the symlink race issue we mentioned earlier.<crlf>For every executable filename under /sbin owned by root, plant the same filename under /tmp/nimbuspwn. For example, if /sbin/vgs is executable and owned by root, plant an executable file /tmp/nimbuspwn/vgs with the desired payload. This will help the attacker win the race condition imposed by the TOCTOU vulnerability.<crlf>Send a signal with the OperationalState ../../../tmp/nimbuspwn/poc. This abuses the directory traversal vulnerability and escapes the script directory.<crlf>The networkd-dispatcher signal handler kicks in and builds the script list from the directory /etc/networkd-dispatcher/../../../tmp/nimbuspwn/poc.d, which is really the symlink (/tmp/nimbuspwn/poc.d), which points to /sbin. Therefore, it creates a list composed of many executables owned by root.<crlf>Quickly change the symlink /tmp/nimbuspwn/poc.d to point to /tmp/nimbuspwn. This abuses the TOCTOU race condition vulnerabilitythe script path changes without networkd-dispatcher being aware.<crlf>The dispatcher starts running files that were initially under /sbin but in truth under the /tmp/nimbuspwn directory. Since the dispatcher believes those files are owned by root, it executes them blindly with subprocess.Popen as root. Therefore, our attacker has successfully exploited the vulnerability."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xe146d464>",
                            "type": "File",
                            "value": "subprocess.popen"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x26ad5415>",
                            "type": "UnknownWord",
                            "value": "blindly"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa3bb6ec4>",
                    "type": "UnknownWord",
                    "value": "probability"
                },
                "references": {
                    "sentences": [
                        "Note that to win the TOCTOU race condition with high probability, we plant many files that can potentially run. Our experiments show three attempts were enough to win the TOCTOU race condition."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x41a542a4>",
                    "type": "UnknownWord",
                    "value": "flow-chart"
                },
                "references": {
                    "sentences": [
                        "Figure 5: Flow-chart of the attack in three stages"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbab26bb5>",
                    "type": "UnknownWord",
                    "value": "copies bin"
                },
                "references": {
                    "sentences": [
                        "Copies /bin/sh to /tmp/sh.<crlf>Turns the new /tmp/sh it into a Set-UID (SUID) binary.<crlf>Run /tmp/sh -p. The -p flag is necessary since modern shells drop privileges by design."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa355dd20>",
                    "type": "UnknownWord",
                    "value": "set-uid"
                },
                "references": {
                    "sentences": [
                        "While capable of running any arbitrary script as root, our exploit copies /bin/sh to the /tmp directory, sets /tmp/sh as a Set-UID (SUID) executable, and then invokes /tmp/sh -p. Note that the -p flag is necessary to force the shell to not drop privileges.",
                        "Copies /bin/sh to /tmp/sh.<crlf>Turns the new /tmp/sh it into a Set-UID (SUID) binary.<crlf>Run /tmp/sh -p. The -p flag is necessary since modern shells drop privileges by design.",
                        "To address the specific vulnerabilities at play, Microsoft Defender for Endpoints endpoint detection and response (EDR) capabilities detect the directory traversal attack required to leverage Nimbuspwn. Additionally, the Microsoft Defender for Endpoint detection team has a generic detection for suspicious Set-UID process invocations, which detected our exploit without prior knowledge."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1b7f046b>",
                    "type": "UnknownWord",
                    "value": "suid"
                },
                "references": {
                    "sentences": [
                        "Copies /bin/sh to /tmp/sh.<crlf>Turns the new /tmp/sh it into a Set-UID (SUID) binary.<crlf>Run /tmp/sh -p. The -p flag is necessary since modern shells drop privileges by design.",
                        "While capable of running any arbitrary script as root, our exploit copies /bin/sh to the /tmp directory, sets /tmp/sh as a Set-UID (SUID) executable, and then invokes /tmp/sh -p. Note that the -p flag is necessary to force the shell to not drop privileges.",
                        "Figure 7: Microsoft Defender for Endpoint detecting a suspicious SUID process used in our exploit"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4cf328a6>",
                    "type": "UnknownWord",
                    "value": "-p"
                },
                "references": {
                    "sentences": [
                        "While capable of running any arbitrary script as root, our exploit copies /bin/sh to the /tmp directory, sets /tmp/sh as a Set-UID (SUID) executable, and then invokes /tmp/sh -p. Note that the -p flag is necessary to force the shell to not drop privileges.",
                        "Copies /bin/sh to /tmp/sh.<crlf>Turns the new /tmp/sh it into a Set-UID (SUID) binary.<crlf>Run /tmp/sh -p. The -p flag is necessary since modern shells drop privileges by design."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x898086d4>",
                    "type": "UnknownWord",
                    "value": "astute"
                },
                "references": {
                    "sentences": [
                        "The astute reader will notice that the entire exploit elevates privileges assuming our exploit code can own the org.freedesktop.network1 bus name. While this sounds non-trivial, we have found several environments where this happens. Specifically:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe8571577>",
                    "type": "UnknownWord",
                    "value": "elevates"
                },
                "references": {
                    "sentences": [
                        "The astute reader will notice that the entire exploit elevates privileges assuming our exploit code can own the org.freedesktop.network1 bus name. While this sounds non-trivial, we have found several environments where this happens. Specifically:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1f22ec20>",
                    "type": "UnknownWord",
                    "value": "sounds"
                },
                "references": {
                    "sentences": [
                        "The astute reader will notice that the entire exploit elevates privileges assuming our exploit code can own the org.freedesktop.network1 bus name. While this sounds non-trivial, we have found several environments where this happens. Specifically:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7442d533>",
                    "type": "UnknownWord",
                    "value": "non-trivial"
                },
                "references": {
                    "sentences": [
                        "The astute reader will notice that the entire exploit elevates privileges assuming our exploit code can own the org.freedesktop.network1 bus name. While this sounds non-trivial, we have found several environments where this happens. Specifically:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3a925c6c>",
                    "type": "UnknownWord",
                    "value": "mint"
                },
                "references": {
                    "sentences": [
                        "On many environments (e.g. Linux Mint) the service systemd-networkd that normally owns the org.freedesktop.network1 bus name does not start at boot by default.<crlf>Using advanced hunting in Microsoft Defender for Endpoint we were able to spot several processes running as the systemd-network user (which is permitted to own the bus name we require) running arbitrary code from world-writable locations. These include several gpgv plugins (launched when apt-get installs or upgrades) as well as the Erlang Port Mapper Daemon (epmd) which allows running arbitrary code under some scenarios."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7000bdd0>",
                    "type": "UnknownWord",
                    "value": "systemd-networkd"
                },
                "references": {
                    "sentences": [
                        "On many environments (e.g. Linux Mint) the service systemd-networkd that normally owns the org.freedesktop.network1 bus name does not start at boot by default.<crlf>Using advanced hunting in Microsoft Defender for Endpoint we were able to spot several processes running as the systemd-network user (which is permitted to own the bus name we require) running arbitrary code from world-writable locations. These include several gpgv plugins (launched when apt-get installs or upgrades) as well as the Erlang Port Mapper Daemon (epmd) which allows running arbitrary code under some scenarios."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3f27288e>",
                    "type": "UnknownWord",
                    "value": "normally"
                },
                "references": {
                    "sentences": [
                        "On many environments (e.g. Linux Mint) the service systemd-networkd that normally owns the org.freedesktop.network1 bus name does not start at boot by default.<crlf>Using advanced hunting in Microsoft Defender for Endpoint we were able to spot several processes running as the systemd-network user (which is permitted to own the bus name we require) running arbitrary code from world-writable locations. These include several gpgv plugins (launched when apt-get installs or upgrades) as well as the Erlang Port Mapper Daemon (epmd) which allows running arbitrary code under some scenarios."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf85b8877>",
                    "type": "UnknownWord",
                    "value": "spot"
                },
                "references": {
                    "sentences": [
                        "On many environments (e.g. Linux Mint) the service systemd-networkd that normally owns the org.freedesktop.network1 bus name does not start at boot by default.<crlf>Using advanced hunting in Microsoft Defender for Endpoint we were able to spot several processes running as the systemd-network user (which is permitted to own the bus name we require) running arbitrary code from world-writable locations. These include several gpgv plugins (launched when apt-get installs or upgrades) as well as the Erlang Port Mapper Daemon (epmd) which allows running arbitrary code under some scenarios."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcf620048>",
                    "type": "UnknownWord",
                    "value": "systemd-network"
                },
                "references": {
                    "sentences": [
                        "On many environments (e.g. Linux Mint) the service systemd-networkd that normally owns the org.freedesktop.network1 bus name does not start at boot by default.<crlf>Using advanced hunting in Microsoft Defender for Endpoint we were able to spot several processes running as the systemd-network user (which is permitted to own the bus name we require) running arbitrary code from world-writable locations. These include several gpgv plugins (launched when apt-get installs or upgrades) as well as the Erlang Port Mapper Daemon (epmd) which allows running arbitrary code under some scenarios.",
                        "DeviceProcessEvents<crlf>| where Timestamp > ago(5d)<crlf>and AccountName == \"systemd-network\"<crlf>and isnotempty(InitiatingProcessAccountName)<crlf>and isnotempty(FileName)<crlf>| project DeviceId, FileName, FolderPath, ProcessCommandLine"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x15d0f330>",
                    "type": "UnknownWord",
                    "value": "permitted"
                },
                "references": {
                    "sentences": [
                        "On many environments (e.g. Linux Mint) the service systemd-networkd that normally owns the org.freedesktop.network1 bus name does not start at boot by default.<crlf>Using advanced hunting in Microsoft Defender for Endpoint we were able to spot several processes running as the systemd-network user (which is permitted to own the bus name we require) running arbitrary code from world-writable locations. These include several gpgv plugins (launched when apt-get installs or upgrades) as well as the Erlang Port Mapper Daemon (epmd) which allows running arbitrary code under some scenarios."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3cb76839>",
                    "type": "UnknownWord",
                    "value": "world-writable"
                },
                "references": {
                    "sentences": [
                        "On many environments (e.g. Linux Mint) the service systemd-networkd that normally owns the org.freedesktop.network1 bus name does not start at boot by default.<crlf>Using advanced hunting in Microsoft Defender for Endpoint we were able to spot several processes running as the systemd-network user (which is permitted to own the bus name we require) running arbitrary code from world-writable locations. These include several gpgv plugins (launched when apt-get installs or upgrades) as well as the Erlang Port Mapper Daemon (epmd) which allows running arbitrary code under some scenarios."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe51d59c0>",
                    "type": "UnknownWord",
                    "value": "gpgv"
                },
                "references": {
                    "sentences": [
                        "On many environments (e.g. Linux Mint) the service systemd-networkd that normally owns the org.freedesktop.network1 bus name does not start at boot by default.<crlf>Using advanced hunting in Microsoft Defender for Endpoint we were able to spot several processes running as the systemd-network user (which is permitted to own the bus name we require) running arbitrary code from world-writable locations. These include several gpgv plugins (launched when apt-get installs or upgrades) as well as the Erlang Port Mapper Daemon (epmd) which allows running arbitrary code under some scenarios."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfba61ebd>",
                    "type": "UnknownWord",
                    "value": "apt-get"
                },
                "references": {
                    "sentences": [
                        "On many environments (e.g. Linux Mint) the service systemd-networkd that normally owns the org.freedesktop.network1 bus name does not start at boot by default.<crlf>Using advanced hunting in Microsoft Defender for Endpoint we were able to spot several processes running as the systemd-network user (which is permitted to own the bus name we require) running arbitrary code from world-writable locations. These include several gpgv plugins (launched when apt-get installs or upgrades) as well as the Erlang Port Mapper Daemon (epmd) which allows running arbitrary code under some scenarios."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2a0a5b66>",
                    "type": "UnknownWord",
                    "value": "erlang"
                },
                "references": {
                    "sentences": [
                        "On many environments (e.g. Linux Mint) the service systemd-networkd that normally owns the org.freedesktop.network1 bus name does not start at boot by default.<crlf>Using advanced hunting in Microsoft Defender for Endpoint we were able to spot several processes running as the systemd-network user (which is permitted to own the bus name we require) running arbitrary code from world-writable locations. These include several gpgv plugins (launched when apt-get installs or upgrades) as well as the Erlang Port Mapper Daemon (epmd) which allows running arbitrary code under some scenarios."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x94b6c1a3>",
                    "type": "UnknownWord",
                    "value": "mapper"
                },
                "references": {
                    "sentences": [
                        "On many environments (e.g. Linux Mint) the service systemd-networkd that normally owns the org.freedesktop.network1 bus name does not start at boot by default.<crlf>Using advanced hunting in Microsoft Defender for Endpoint we were able to spot several processes running as the systemd-network user (which is permitted to own the bus name we require) running arbitrary code from world-writable locations. These include several gpgv plugins (launched when apt-get installs or upgrades) as well as the Erlang Port Mapper Daemon (epmd) which allows running arbitrary code under some scenarios."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x68140ced>",
                    "type": "UnknownWord",
                    "value": "epmd"
                },
                "references": {
                    "sentences": [
                        "On many environments (e.g. Linux Mint) the service systemd-networkd that normally owns the org.freedesktop.network1 bus name does not start at boot by default.<crlf>Using advanced hunting in Microsoft Defender for Endpoint we were able to spot several processes running as the systemd-network user (which is permitted to own the bus name we require) running arbitrary code from world-writable locations. These include several gpgv plugins (launched when apt-get installs or upgrades) as well as the Erlang Port Mapper Daemon (epmd) which allows running arbitrary code under some scenarios."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd0ad045a>",
                    "type": "UnknownWord",
                    "value": "deviceprocessevents"
                },
                "references": {
                    "sentences": [
                        "DeviceProcessEvents<crlf>| where Timestamp > ago(5d)<crlf>and AccountName == \"systemd-network\"<crlf>and isnotempty(InitiatingProcessAccountName)<crlf>and isnotempty(FileName)<crlf>| project DeviceId, FileName, FolderPath, ProcessCommandLine"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe679099>",
                    "type": "UnknownWord",
                    "value": "accountname"
                },
                "references": {
                    "sentences": [
                        "DeviceProcessEvents<crlf>| where Timestamp > ago(5d)<crlf>and AccountName == \"systemd-network\"<crlf>and isnotempty(InitiatingProcessAccountName)<crlf>and isnotempty(FileName)<crlf>| project DeviceId, FileName, FolderPath, ProcessCommandLine"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6aba7f44>",
                    "type": "UnknownWord",
                    "value": "isnotempty"
                },
                "references": {
                    "sentences": [
                        "DeviceProcessEvents<crlf>| where Timestamp > ago(5d)<crlf>and AccountName == \"systemd-network\"<crlf>and isnotempty(InitiatingProcessAccountName)<crlf>and isnotempty(FileName)<crlf>| project DeviceId, FileName, FolderPath, ProcessCommandLine"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa7a193d>",
                    "type": "UnknownWord",
                    "value": "initiatingprocessaccountname"
                },
                "references": {
                    "sentences": [
                        "DeviceProcessEvents<crlf>| where Timestamp > ago(5d)<crlf>and AccountName == \"systemd-network\"<crlf>and isnotempty(InitiatingProcessAccountName)<crlf>and isnotempty(FileName)<crlf>| project DeviceId, FileName, FolderPath, ProcessCommandLine"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbebaa0a6>",
                    "type": "UnknownWord",
                    "value": "deviceid"
                },
                "references": {
                    "sentences": [
                        "DeviceProcessEvents<crlf>| where Timestamp > ago(5d)<crlf>and AccountName == \"systemd-network\"<crlf>and isnotempty(InitiatingProcessAccountName)<crlf>and isnotempty(FileName)<crlf>| project DeviceId, FileName, FolderPath, ProcessCommandLine"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xaf2f0a9e>",
                    "type": "UnknownWord",
                    "value": "folderpath"
                },
                "references": {
                    "sentences": [
                        "DeviceProcessEvents<crlf>| where Timestamp > ago(5d)<crlf>and AccountName == \"systemd-network\"<crlf>and isnotempty(InitiatingProcessAccountName)<crlf>and isnotempty(FileName)<crlf>| project DeviceId, FileName, FolderPath, ProcessCommandLine"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbbe44895>",
                    "type": "UnknownWord",
                    "value": "processcommandline"
                },
                "references": {
                    "sentences": [
                        "DeviceProcessEvents<crlf>| where Timestamp > ago(5d)<crlf>and AccountName == \"systemd-network\"<crlf>and isnotempty(InitiatingProcessAccountName)<crlf>and isnotempty(FileName)<crlf>| project DeviceId, FileName, FolderPath, ProcessCommandLine"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x178400fc>",
                    "type": "UnknownWord",
                    "value": "winning"
                },
                "references": {
                    "sentences": [
                        "Figure 6: Our exploit implemented and winning the TOCTOU race"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa20c5875>",
                    "type": "UnknownWord",
                    "value": "hardening"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Hardening device security and detection strategy"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x59a5f8f>",
                    "type": "UnknownWord",
                    "value": "misconfigurations"
                },
                "references": {
                    "sentences": [
                        "Despite the evolving threat landscape regularly delivering new threats, techniques, and attack capabilities, adversaries continue to focus on identifying and taking advantage of unpatched vulnerabilities and misconfigurations as a vector to access systems, networks, and sensitive information for malicious purposes. This constant bombardment of attacks spanning a wide range of platforms, devices, and other domains emphasizes the need for a comprehensive and proactive vulnerability management approach that can further identify and mitigate even previously unknown exploits and issues."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbae95e2d>",
                    "type": "UnknownWord",
                    "value": "bombardment"
                },
                "references": {
                    "sentences": [
                        "Despite the evolving threat landscape regularly delivering new threats, techniques, and attack capabilities, adversaries continue to focus on identifying and taking advantage of unpatched vulnerabilities and misconfigurations as a vector to access systems, networks, and sensitive information for malicious purposes. This constant bombardment of attacks spanning a wide range of platforms, devices, and other domains emphasizes the need for a comprehensive and proactive vulnerability management approach that can further identify and mitigate even previously unknown exploits and issues."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc5a1f69d>",
                    "type": "UnknownWord",
                    "value": "emphasizes"
                },
                "references": {
                    "sentences": [
                        "Despite the evolving threat landscape regularly delivering new threats, techniques, and attack capabilities, adversaries continue to focus on identifying and taking advantage of unpatched vulnerabilities and misconfigurations as a vector to access systems, networks, and sensitive information for malicious purposes. This constant bombardment of attacks spanning a wide range of platforms, devices, and other domains emphasizes the need for a comprehensive and proactive vulnerability management approach that can further identify and mitigate even previously unknown exploits and issues."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xaf221e12>",
                    "type": "UnknownWord",
                    "value": "proactive"
                },
                "references": {
                    "sentences": [
                        "Despite the evolving threat landscape regularly delivering new threats, techniques, and attack capabilities, adversaries continue to focus on identifying and taking advantage of unpatched vulnerabilities and misconfigurations as a vector to access systems, networks, and sensitive information for malicious purposes. This constant bombardment of attacks spanning a wide range of platforms, devices, and other domains emphasizes the need for a comprehensive and proactive vulnerability management approach that can further identify and mitigate even previously unknown exploits and issues."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1cb3f091>",
                    "type": "UnknownWord",
                    "value": "prioritization"
                },
                "references": {
                    "sentences": [
                        "Microsofts threat and vulnerability management capabilities help organizations monitor their overall security posture, providing real-time insights into risk with continuous vulnerability discovery, contextualized intelligent prioritization, and seamless one-click flaw remediation. Leveraging our research into the Nimbuspwn vulnerabilities to improve solutions, our threat and vulnerability management already covers CVE-2022-29799 and CVE-2022-29800 and indicates such vulnerable devices in the threat and vulnerability module in Microsoft Defender for Endpoint."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x236c7c4b>",
                    "type": "UnknownWord",
                    "value": "one-click"
                },
                "references": {
                    "sentences": [
                        "Microsofts threat and vulnerability management capabilities help organizations monitor their overall security posture, providing real-time insights into risk with continuous vulnerability discovery, contextualized intelligent prioritization, and seamless one-click flaw remediation. Leveraging our research into the Nimbuspwn vulnerabilities to improve solutions, our threat and vulnerability management already covers CVE-2022-29799 and CVE-2022-29800 and indicates such vulnerable devices in the threat and vulnerability module in Microsoft Defender for Endpoint."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa9ee070c>",
                    "type": "UnknownWord",
                    "value": "invocations"
                },
                "references": {
                    "sentences": [
                        "To address the specific vulnerabilities at play, Microsoft Defender for Endpoints endpoint detection and response (EDR) capabilities detect the directory traversal attack required to leverage Nimbuspwn. Additionally, the Microsoft Defender for Endpoint detection team has a generic detection for suspicious Set-UID process invocations, which detected our exploit without prior knowledge."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x677501c4>",
                    "type": "UnknownWord",
                    "value": "non-windows"
                },
                "references": {
                    "sentences": [
                        "Defending against the evolving threat landscape requires the ability to protect and secure users computing experiences, be it a Windows or non-Windows device. Microsoft continuously enriches our protection technologies through robust research that protects users and organizations across all the major platforms every single day. This case displayed how the ability to coordinate such research via expert, cross-industry collaboration is vital to effectively mitigate issues, regardless of the vulnerable device or platform in use. By sharing our research and other forms of threat intelligence, we can continue to collaborate with the larger security community and strive to build better protection for all."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9ad47007>",
                    "type": "UnknownWord",
                    "value": "enriches"
                },
                "references": {
                    "sentences": [
                        "Defending against the evolving threat landscape requires the ability to protect and secure users computing experiences, be it a Windows or non-Windows device. Microsoft continuously enriches our protection technologies through robust research that protects users and organizations across all the major platforms every single day. This case displayed how the ability to coordinate such research via expert, cross-industry collaboration is vital to effectively mitigate issues, regardless of the vulnerable device or platform in use. By sharing our research and other forms of threat intelligence, we can continue to collaborate with the larger security community and strive to build better protection for all."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x53a38019>",
                    "type": "UnknownWord",
                    "value": "coordinate"
                },
                "references": {
                    "sentences": [
                        "Defending against the evolving threat landscape requires the ability to protect and secure users computing experiences, be it a Windows or non-Windows device. Microsoft continuously enriches our protection technologies through robust research that protects users and organizations across all the major platforms every single day. This case displayed how the ability to coordinate such research via expert, cross-industry collaboration is vital to effectively mitigate issues, regardless of the vulnerable device or platform in use. By sharing our research and other forms of threat intelligence, we can continue to collaborate with the larger security community and strive to build better protection for all."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x868dbd69>",
                    "type": "UnknownWord",
                    "value": "cross-industry"
                },
                "references": {
                    "sentences": [
                        "Defending against the evolving threat landscape requires the ability to protect and secure users computing experiences, be it a Windows or non-Windows device. Microsoft continuously enriches our protection technologies through robust research that protects users and organizations across all the major platforms every single day. This case displayed how the ability to coordinate such research via expert, cross-industry collaboration is vital to effectively mitigate issues, regardless of the vulnerable device or platform in use. By sharing our research and other forms of threat intelligence, we can continue to collaborate with the larger security community and strive to build better protection for all."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8e2d7bac>",
                    "type": "UnknownWord",
                    "value": "vital"
                },
                "references": {
                    "sentences": [
                        "Defending against the evolving threat landscape requires the ability to protect and secure users computing experiences, be it a Windows or non-Windows device. Microsoft continuously enriches our protection technologies through robust research that protects users and organizations across all the major platforms every single day. This case displayed how the ability to coordinate such research via expert, cross-industry collaboration is vital to effectively mitigate issues, regardless of the vulnerable device or platform in use. By sharing our research and other forms of threat intelligence, we can continue to collaborate with the larger security community and strive to build better protection for all."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc6db175>",
                    "type": "UnknownWord",
                    "value": "collaborate"
                },
                "references": {
                    "sentences": [
                        "Defending against the evolving threat landscape requires the ability to protect and secure users computing experiences, be it a Windows or non-Windows device. Microsoft continuously enriches our protection technologies through robust research that protects users and organizations across all the major platforms every single day. This case displayed how the ability to coordinate such research via expert, cross-industry collaboration is vital to effectively mitigate issues, regardless of the vulnerable device or platform in use. By sharing our research and other forms of threat intelligence, we can continue to collaborate with the larger security community and strive to build better protection for all."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x535f9878>",
                    "type": "UnknownWord",
                    "value": "strive"
                },
                "references": {
                    "sentences": [
                        "Defending against the evolving threat landscape requires the ability to protect and secure users computing experiences, be it a Windows or non-Windows device. Microsoft continuously enriches our protection technologies through robust research that protects users and organizations across all the major platforms every single day. This case displayed how the ability to coordinate such research via expert, cross-industry collaboration is vital to effectively mitigate issues, regardless of the vulnerable device or platform in use. By sharing our research and other forms of threat intelligence, we can continue to collaborate with the larger security community and strive to build better protection for all."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x64d31321>",
                    "type": "UnknownWord",
                    "value": "jonathan"
                },
                "references": {
                    "sentences": [
                        "Jonathan Bar Or"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa573c9c0>",
                    "type": "UnknownWord",
                    "value": "bar"
                },
                "references": {
                    "sentences": [
                        "Jonathan Bar Or"
                    ],
                    "titles": []
                }
            }
        ]
    },
    "other_links": [],
    "info": {
        "potential_threats": {
            "<UNKNOWNWORD_0x39043c28>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x39043c28>",
                    "type": "UnknownWord",
                    "value": "clayton"
                },
                "references": {
                    "sentences": [
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x2d46af10>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x2d46af10>",
                    "type": "UnknownWord",
                    "value": "craft"
                },
                "references": {
                    "sentences": [
                        "We discovered the vulnerabilities by listening to messages on the System Bus while performing code reviews and dynamic analysis on services that run as root, noticing an odd pattern in a systemd unit called networkd-dispatcher. Reviewing the code flow for networkd-dispatcher revealed multiple security concerns, including directory traversal, symlink race, and time-of-check-time-of-use race condition issues, which could be leveraged to elevate privileges and deploy malware or carry out other malicious activities. We shared these vulnerabilities with the relevant maintainers through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). Fixes for these vulnerabilities, now identified as CVE-2022-29799 and CVE-2022-29800, have been successfully deployed by the maintainer of the networkd-dispatcher, Clayton Craft. We wish to thank Clayton for his professionalism and collaboration in resolving those issues. Users of networkd-dispatcher are encouraged to update their instances."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x59c208f5>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x59c208f5>",
                    "type": "UnknownWord",
                    "value": "desktop-bus"
                },
                "references": {
                    "sentences": [
                        "D-Bus (short for Desktop-Bus) is an inter-process communication channel (IPC) mechanism developed by the freedesktop.org project. D-Bus is a software-bus and allows processes on the same endpoint to communicate by transmitting messages and responding to them. D-Bus supports two main ways of communicating:"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x8a67df54>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x8a67df54>",
                    "type": "UnknownWord",
                    "value": "usbcreator"
                },
                "references": {
                    "sentences": [
                        "There are many D-Bus components shipped by default on popular Linux desktop environments. Since those components run at different privileges and respond to messages, D-Bus components are an attractive target for attackers. Indeed, there have been interesting vulnerabilities in the past related to buggy D-Bus services, including USBCreator Elevation of Privilege, Blueman Elevation of Privilege by command injection, and other similar scenarios."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x9e37188f>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x9e37188f>",
                    "type": "UnknownWord",
                    "value": "pid-recycling"
                },
                "references": {
                    "sentences": [
                        "When connecting to the D-Bus, components are assigned with a unique identifier, which mitigates against attacks abusing PID-recycling. The unique identifier starts with a colon and has numbers in it separated by dots, such as :1.337. Components can use the D-Bus API to own identifiable names such as org.freedesktop.Avahi or com.ubuntu.SystemService. For D-Bus to allow such ownership, the requesting process context must be allowed under the D-Bus configuration files. Those configuration files are well documented and maintained under /usr/local/share/dbus-1/system.conf and /usr/local/share/dbus-1/session.conf (on some systems under /usr/local/dbus-1 directly). Specifically, the default system.conf does not allow ownership unless specified otherwise in other included configuration files (commonly under /etc/dbus-1/system.d)."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x26be4d69>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x26be4d69>",
                    "type": "UnknownWord",
                    "value": "blueman"
                },
                "references": {
                    "sentences": [
                        "Directory Info Disclosure in Blueman<crlf>Directory Info Disclosure in PackageKit (CVE-2022-0987)"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xb17ebf6c>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xb17ebf6c>",
                    "type": "UnknownWord",
                    "value": "packagekit"
                },
                "references": {
                    "sentences": [
                        "Directory Info Disclosure in Blueman<crlf>Directory Info Disclosure in PackageKit (CVE-2022-0987)"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x132ecd37>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x132ecd37>",
                    "type": "UnknownWord",
                    "value": "propertieschanged"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x1ac6e2c3>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x1ac6e2c3>",
                    "type": "UnknownWord",
                    "value": "statesoperationalstate"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x398236dc>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x398236dc>",
                    "type": "UnknownWord",
                    "value": "administrativestateeach"
                },
                "references": {
                    "sentences": [
                        "The register function registers a new signal receiver for the service org.freedesktop.network1 on the System Bus, for the signal name PropertiesChanged.<crlf>The _receive_signal signal handler will perform some basic checks on the object type being sent, concludes the changed network interface based on the object path being sent, and then concludes its new statesOperationalState and AdministrativeStateeach fetched from the data. For any of those statesif they arent emptythe handle_state method will get invoked.<crlf>The handle_state method simply invokes _handle_one_state for each of those two states.<crlf>_handle_one_state validates the state isnt empty and checks if its different than the previous state. If it is, it will update the new state and invoke the _run_hooks_for_state method, which is responsible of discovering and running the scripts for the new state.<crlf>_run_hooks_for_state implements the following logic:Discovers the script list by invoking the get_script_list method (which gets the new state as a string). This method simply calls scripts_in_path which is intended to return all the files under /etc/networkd-dispatcher/<state>.d that are owned by the root user and the root group, and are executable. Sorts the script list. Runs each script with subprocess.Popen while supplying custom environment variables."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x227c629e>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x227c629e>",
                    "type": "UnknownWord",
                    "value": "operationalstate"
                },
                "references": {
                    "sentences": [
                        "Directory traversal (CVE-2022-29799): none of the functions in the flow sanitize the OperationalState or the AdministrativeState. Since the states are used to build the script path, it is possible that a state would contain directory traversal patterns (e.g. ../../) to escape from the /etc/networkd-dispatcher base directory.<crlf>Symlink race: both the script discovery and subprocess.Popen follow symbolic links.<crlf>Time-of-check-time-of-use (TOCTOU) race condition (CVE-2022-29800): there is a certain time between the scripts being discovered and them being run. An attacker can abuse this vulnerability to replace scripts that networkd-dispatcher believes to be owned by root to ones that are not.",
                        "Prepare a directory /tmp/nimbuspwn and plant a symlink /tmp/nimbuspwn/poc.d to point to /sbin. The /sbin directory was chosen specifically because it has many executables owned by root that do not block if run without additional arguments. This will abuse the symlink race issue we mentioned earlier.<crlf>For every executable filename under /sbin owned by root, plant the same filename under /tmp/nimbuspwn. For example, if /sbin/vgs is executable and owned by root, plant an executable file /tmp/nimbuspwn/vgs with the desired payload. This will help the attacker win the race condition imposed by the TOCTOU vulnerability.<crlf>Send a signal with the OperationalState ../../../tmp/nimbuspwn/poc. This abuses the directory traversal vulnerability and escapes the script directory.<crlf>The networkd-dispatcher signal handler kicks in and builds the script list from the directory /etc/networkd-dispatcher/../../../tmp/nimbuspwn/poc.d, which is really the symlink (/tmp/nimbuspwn/poc.d), which points to /sbin. Therefore, it creates a list composed of many executables owned by root.<crlf>Quickly change the symlink /tmp/nimbuspwn/poc.d to point to /tmp/nimbuspwn. This abuses the TOCTOU race condition vulnerabilitythe script path changes without networkd-dispatcher being aware.<crlf>The dispatcher starts running files that were initially under /sbin but in truth under the /tmp/nimbuspwn directory. Since the dispatcher believes those files are owned by root, it executes them blindly with subprocess.Popen as root. Therefore, our attacker has successfully exploited the vulnerability."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x8c28f2c0>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x8c28f2c0>",
                    "type": "UnknownWord",
                    "value": "administrativestate"
                },
                "references": {
                    "sentences": [
                        "Directory traversal (CVE-2022-29799): none of the functions in the flow sanitize the OperationalState or the AdministrativeState. Since the states are used to build the script path, it is possible that a state would contain directory traversal patterns (e.g. ../../) to escape from the /etc/networkd-dispatcher base directory.<crlf>Symlink race: both the script discovery and subprocess.Popen follow symbolic links.<crlf>Time-of-check-time-of-use (TOCTOU) race condition (CVE-2022-29800): there is a certain time between the scripts being discovered and them being run. An attacker can abuse this vulnerability to replace scripts that networkd-dispatcher believes to be owned by root to ones that are not."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x41a542a4>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x41a542a4>",
                    "type": "UnknownWord",
                    "value": "flow-chart"
                },
                "references": {
                    "sentences": [
                        "Figure 5: Flow-chart of the attack in three stages"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xa355dd20>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xa355dd20>",
                    "type": "UnknownWord",
                    "value": "set-uid"
                },
                "references": {
                    "sentences": [
                        "While capable of running any arbitrary script as root, our exploit copies /bin/sh to the /tmp directory, sets /tmp/sh as a Set-UID (SUID) executable, and then invokes /tmp/sh -p. Note that the -p flag is necessary to force the shell to not drop privileges.",
                        "Copies /bin/sh to /tmp/sh.<crlf>Turns the new /tmp/sh it into a Set-UID (SUID) binary.<crlf>Run /tmp/sh -p. The -p flag is necessary since modern shells drop privileges by design.",
                        "To address the specific vulnerabilities at play, Microsoft Defender for Endpoints endpoint detection and response (EDR) capabilities detect the directory traversal attack required to leverage Nimbuspwn. Additionally, the Microsoft Defender for Endpoint detection team has a generic detection for suspicious Set-UID process invocations, which detected our exploit without prior knowledge."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x2a0a5b66>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x2a0a5b66>",
                    "type": "UnknownWord",
                    "value": "erlang"
                },
                "references": {
                    "sentences": [
                        "On many environments (e.g. Linux Mint) the service systemd-networkd that normally owns the org.freedesktop.network1 bus name does not start at boot by default.<crlf>Using advanced hunting in Microsoft Defender for Endpoint we were able to spot several processes running as the systemd-network user (which is permitted to own the bus name we require) running arbitrary code from world-writable locations. These include several gpgv plugins (launched when apt-get installs or upgrades) as well as the Erlang Port Mapper Daemon (epmd) which allows running arbitrary code under some scenarios."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x94b6c1a3>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x94b6c1a3>",
                    "type": "UnknownWord",
                    "value": "mapper"
                },
                "references": {
                    "sentences": [
                        "On many environments (e.g. Linux Mint) the service systemd-networkd that normally owns the org.freedesktop.network1 bus name does not start at boot by default.<crlf>Using advanced hunting in Microsoft Defender for Endpoint we were able to spot several processes running as the systemd-network user (which is permitted to own the bus name we require) running arbitrary code from world-writable locations. These include several gpgv plugins (launched when apt-get installs or upgrades) as well as the Erlang Port Mapper Daemon (epmd) which allows running arbitrary code under some scenarios."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xe679099>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xe679099>",
                    "type": "UnknownWord",
                    "value": "accountname"
                },
                "references": {
                    "sentences": [
                        "DeviceProcessEvents<crlf>| where Timestamp > ago(5d)<crlf>and AccountName == \"systemd-network\"<crlf>and isnotempty(InitiatingProcessAccountName)<crlf>and isnotempty(FileName)<crlf>| project DeviceId, FileName, FolderPath, ProcessCommandLine"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xa7a193d>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xa7a193d>",
                    "type": "UnknownWord",
                    "value": "initiatingprocessaccountname"
                },
                "references": {
                    "sentences": [
                        "DeviceProcessEvents<crlf>| where Timestamp > ago(5d)<crlf>and AccountName == \"systemd-network\"<crlf>and isnotempty(InitiatingProcessAccountName)<crlf>and isnotempty(FileName)<crlf>| project DeviceId, FileName, FolderPath, ProcessCommandLine"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xbebaa0a6>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xbebaa0a6>",
                    "type": "UnknownWord",
                    "value": "deviceid"
                },
                "references": {
                    "sentences": [
                        "DeviceProcessEvents<crlf>| where Timestamp > ago(5d)<crlf>and AccountName == \"systemd-network\"<crlf>and isnotempty(InitiatingProcessAccountName)<crlf>and isnotempty(FileName)<crlf>| project DeviceId, FileName, FolderPath, ProcessCommandLine"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xaf2f0a9e>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xaf2f0a9e>",
                    "type": "UnknownWord",
                    "value": "folderpath"
                },
                "references": {
                    "sentences": [
                        "DeviceProcessEvents<crlf>| where Timestamp > ago(5d)<crlf>and AccountName == \"systemd-network\"<crlf>and isnotempty(InitiatingProcessAccountName)<crlf>and isnotempty(FileName)<crlf>| project DeviceId, FileName, FolderPath, ProcessCommandLine"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xbbe44895>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xbbe44895>",
                    "type": "UnknownWord",
                    "value": "processcommandline"
                },
                "references": {
                    "sentences": [
                        "DeviceProcessEvents<crlf>| where Timestamp > ago(5d)<crlf>and AccountName == \"systemd-network\"<crlf>and isnotempty(InitiatingProcessAccountName)<crlf>and isnotempty(FileName)<crlf>| project DeviceId, FileName, FolderPath, ProcessCommandLine"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x677501c4>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x677501c4>",
                    "type": "UnknownWord",
                    "value": "non-windows"
                },
                "references": {
                    "sentences": [
                        "Defending against the evolving threat landscape requires the ability to protect and secure users computing experiences, be it a Windows or non-Windows device. Microsoft continuously enriches our protection technologies through robust research that protects users and organizations across all the major platforms every single day. This case displayed how the ability to coordinate such research via expert, cross-industry collaboration is vital to effectively mitigate issues, regardless of the vulnerable device or platform in use. By sharing our research and other forms of threat intelligence, we can continue to collaborate with the larger security community and strive to build better protection for all."
                    ],
                    "titles": []
                }
            }
        },
        "sigma": false,
        "yara": false
    },
    "keywords": {
        "classified": [],
        "dubbed": [],
        "associated": [],
        "targets": [
            "When connecting to the D-Bus, components are assigned with a unique identifier, which mitigates against attacks abusing PID-recycling",
            "Defending against the evolving threat landscape requires the ability to protect and secure users computing experiences, be it a Windows or non-Windows device"
        ],
        "attributed": []
    },
    "resources": {
        "links": {
            "github": [
                "https://github.com/blueman-project/blueman/security/advisories/GHSA-3r9p-m5c8-8mw8"
            ],
            "pastebin": [],
            "text_files": [],
            "other": [
                "https://www.microsoft.com/msrc/cvd?rtc=1",
                "https://www.microsoft.com/msrc/msvr",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-29799",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-29800",
                "https://docs.microsoft.com/microsoft-365/security/defender-endpoint/microsoft-defender-endpoint-linux?view=o365-worldwide",
                "https://en.wikipedia.org/wiki/D-Bus",
                "https://www.freedesktop.org/",
                "https://unit42.paloaltonetworks.com/usbcreator-d-bus-privilege-escalation-in-ubuntu-desktop/",
                "https://bugzilla.redhat.com/show_bug.cgi?id=1892437",
                "https://dbus.freedesktop.org/doc/dbus-daemon.1.html",
                "https://access.redhat.com/security/cve/cve-2022-0987",
                "https://en.wikipedia.org/wiki/Systemd",
                "https://gitlab.com/craftyguy/networkd-dispatcher",
                "https://docs.python.org/3/library/subprocess.html#subprocess.Popen",
                "https://en.wikipedia.org/wiki/Directory_traversal_attack",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-29799",
                "https://en.wikipedia.org/wiki/Symlink_race",
                "https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-29800",
                "https://attack.mitre.org/techniques/T1548/001/",
                "https://docs.microsoft.com/microsoft-365/security/defender-endpoint/advanced-hunting-overview?view=o365-worldwide",
                "https://www.gnupg.org/documentation/manuals/gnupg/gpgv.html",
                "https://linux.die.net/man/8/apt-get",
                "https://www.erlang.org/doc/man/epmd.html",
                "https://attack.mitre.org/techniques/T1548/001/",
                "https://docs.microsoft.com/microsoft-365/security/defender-endpoint/next-gen-threat-and-vuln-mgt?view=o365-worldwide",
                "https://www.microsoft.com/security/business/threat-protection/endpoint-defender?rtc=1",
                "https://docs.microsoft.com/microsoft-365/security/defender-endpoint/overview-endpoint-detection-response?view=o365-worldwide"
            ]
        },
        "images": [
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/04/Figure-1-Different-ownership-policies-for-the-System-Bus-and-the-Session-Bus.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/04/Figure-2-networkd-dispatcher-running-as-root.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/04/Figure-3-_run_hooks_for_state-source-code-some-parts-omitted-for-brevity.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/04/6267e7bcdaac2-6267e7bcdaac3Figure-4-Building-the-script-list-in-the-scripts_in_path-method-including-the-vulnerable-code-with-subdir-poisoned..png.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/04/Figure-5-Flow-chart-of-the-attack-in-three-stages.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/04/Figure-6-Our-exploit-implemented-and-winning-the-TOCTOU-race.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/04/Figure-7-Microsoft-Defender-for-Endpoint-detecting-a-suspicious-SUID-process-used-in-our-exploit.png"
        ]
    }
}