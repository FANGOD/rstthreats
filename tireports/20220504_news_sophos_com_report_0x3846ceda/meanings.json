{
    "title": "Attacking Emotets Control Flow Flattening",
    "url": "https://news.sophos.com/en-us/2022/05/04/attacking-emotets-control-flow-flattening",
    "threats": {
        "Threat": [
            {
                "token": {
                    "id": "<THREAT_0x8bd5383c>",
                    "type": "Threat",
                    "value": "emotet"
                },
                "references": {
                    "sentences": [
                        "In addition to Emotets delivery mechanism and prevalence, we also analyze the final payload in depth. Thus, we noticed Control Flow Flattening in an unpacked Emotet sample. Control Flow Flattening hides program flow by putting all function blocks next to each other. It is a well-known obfuscation technique used to conceal the purpose of software. While extracting the original code from a flattened binary is inherently challenging, we have successfully adapted some existing toolsets to deobfuscate the majority of Emotet payload functionality.",
                        "Unflattening Emotet",
                        "In Figure 5 you can see the decompiled output and CFG of a function in an unpacked Emotet sample. Excluding the Control Flow Flattening applied here, the output might seem confusing, because Emotet applies more than just one obfuscation technique. (If you are not familiar with those other techniques, an appendix at the end of this article briefly explains the other obfuscation techniques .)",
                        "Emotet: Resurgence and Tenacity",
                        "emotet",
                        "When sharing the decompiled output of functions in an Emotet sample, it is impossible not to encounter other Emotet obfuscation techniques beyond CFF. This appendix covers the most prevalent obfuscation techniques we have identified in an unpacked Emotet sample. Keep in mind that Emotet is usually delivered in a packed form and needs to be unpacked first.",
                        "Emotet contains encrypted strings in its unpacked form. Before usage, strings will be decrypted and freed again right after each serves its purpose.",
                        "Overall, we recommend that researchers always cross-check their results and not trust the output blindly. Control Flow Flattening used in conjunction with other obfuscation techniques certainly complicates the process of reverse engineering Emotet, but the technique weve described helps to even the odds against researchers examining this high-profile malware.",
                        "Emotet uses API Hashing to conceal the usage of API functions. The malware calculates the hash of exported function names for a given DLL. If the calculated hash matches the constant pushed onto the stack at method invocation, the pointer to the exported function will be retrieved.",
                        "Control Flow Flattening is a complex topic, and the purpose of this article is to share our experience and results attacking Emotets Control Flow Flattening. While we made multiple adjustments and met with some success, our solution is not able to deobfuscate all functions completely. Among the outstanding issues:",
                        "Emotet embeds junk instructions to confuse reverse engineers. Junk instructions are instructions that do not serve any purpose except to complicate and slow down analysis. Figure 11 below shows an example of a junk instruction block.",
                        "To deobfuscate Emotets use of Control Flow Flattening, we started with a review of existing tools and research on CFG deobfuscation. Some of those include:",
                        "Another interesting technique that confuses the IDA decompiler is the way in which Emotet passes parameters to functions. In Figure 12 below, we show how DYN_BCryptEncrypt is invoked.",
                        "Emotets internals have been covered by many researchers, but we have not seen discussions on de-obfuscating its use of Control Flow Flattening so far.",
                        "Emotet has been one of the most professional and long-lasting cybercrime services and malware infections in the threat landscape. Notorious since shortly after its debut in 2014, the botnet was disrupted in January 2021 by a multinational law enforcement effort that sidelined its activity for almost a year. Unfortunately, in November 2021 the botnet re-emerged and once again began to appear on Sophos radar.",
                        "Figure 1: Timeline of 2022 Emotet detections in SophosLabs sandbox systems",
                        "Figure 11: Example of junk instructions in unpacked Emotet sample",
                        "Figure 1 shows the volume of Emotet payloads detected in our sandbox systems in the first quarter of 2022. As the chart shows, we receive multiple Emotet submissions daily; we believe that the recurring larger spikes result from large-scale campaigns being kicked off by the malwares distributors. This is a sensible assumption; Emotet is mainly distributed via email spam, and more malicious emails naturally lead to more sandbox submissions.",
                        "To protect our customers, SophosLabs is always looking for the most significant techniques, tactics, and procedures used to distribute and deliver Emotet. In this post, well look at Control Flow Flattening (CFF), one of several obfuscation tactics Emotets developers use to make detection and reverse engineering of the malwares payload more difficult. Well provide a brief example of CFF applied to a simple hello-world program, and then discuss how Sophos researchers address CFF in Emotets code. Well finish by summarizing the challenges and problems we encountered during research."
                    ],
                    "titles": [
                        "Appendix: Emotet and Code Obfuscation",
                        "Attacking Emotets Control Flow Flattening"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xcd2d204d>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "9a0286ec0a3e7ea346759c9497c8b5c7c212fa2c780a1cabb094134bf492a51b"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x8bd5383c>",
                            "type": "Threat",
                            "value": "emotet"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x3e4901d2>",
                            "type": "Category",
                            "value": "spam"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x8bd5383c>",
                            "type": "Threat",
                            "value": "emotet"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x999f91f8>",
                            "type": "Threat",
                            "value": "stone_panda_group"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x8bd5383c>",
                            "type": "Threat",
                            "value": "emotet"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x90d25b1f>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "1bbce395c839c737fdc983534b963a1521ab9693a5b585f15b8a4950adea5973"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x8bd5383c>",
                            "type": "Threat",
                            "value": "emotet"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xd91561a2>",
                            "type": "Category",
                            "value": "botnet"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x8bd5383c>",
                            "type": "Threat",
                            "value": "emotet"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x8bd5383c>",
                            "type": "Threat",
                            "value": "emotet"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x1d99d07f>",
                            "type": "Threat",
                            "value": "stantinko"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x8bd5383c>",
                            "type": "Threat",
                            "value": "emotet"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<THREAT_0x999f91f8>",
                    "type": "Threat",
                    "value": "stone_panda_group"
                },
                "references": {
                    "sentences": [
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard"
                    ],
                    "titles": [
                        "Attacking Emotets Control Flow Flattening"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<THREAT_0x999f91f8>",
                            "type": "Threat",
                            "value": "stone_panda_group"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x8bd5383c>",
                            "type": "Threat",
                            "value": "emotet"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<THREAT_0x1d99d07f>",
                    "type": "Threat",
                    "value": "stantinko"
                },
                "references": {
                    "sentences": [
                        "Our unflattening tool is now available on the SophosLabs Github. (For those interested in such things, we also recommend to your attention a CFF-unpacking tool released by ESET several years back to address control-flow flattening in the Stantinko botnet another example of why, since attackers freely share tactics, techniques, and procedures among themselves, defenders are wise to do the same.)"
                    ],
                    "titles": [
                        "Attacking Emotets Control Flow Flattening"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<THREAT_0x1d99d07f>",
                            "type": "Threat",
                            "value": "stantinko"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x8bd5383c>",
                            "type": "Threat",
                            "value": "emotet"
                        }
                    }
                ]
            }
        ]
    },
    "ttps": {},
    "meanings": {
        "Category": [
            {
                "token": {
                    "id": "<CATEGORY_0xf1a480bb>",
                    "type": "Category",
                    "value": "malware"
                },
                "references": {
                    "sentences": [
                        "Sweeping aside one obfuscation technique in a notorious strain of malware<crlf>Written by",
                        "Overall, we recommend that researchers always cross-check their results and not trust the output blindly. Control Flow Flattening used in conjunction with other obfuscation techniques certainly complicates the process of reverse engineering Emotet, but the technique weve described helps to even the odds against researchers examining this high-profile malware.",
                        "To protect our customers, SophosLabs is always looking for the most significant techniques, tactics, and procedures used to distribute and deliver Emotet. In this post, well look at Control Flow Flattening (CFF), one of several obfuscation tactics Emotets developers use to make detection and reverse engineering of the malwares payload more difficult. Well provide a brief example of CFF applied to a simple hello-world program, and then discuss how Sophos researchers address CFF in Emotets code. Well finish by summarizing the challenges and problems we encountered during research.",
                        "Emotet uses API Hashing to conceal the usage of API functions. The malware calculates the hash of exported function names for a given DLL. If the calculated hash matches the constant pushed onto the stack at method invocation, the pointer to the exported function will be retrieved.",
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard",
                        "Figure 1 shows the volume of Emotet payloads detected in our sandbox systems in the first quarter of 2022. As the chart shows, we receive multiple Emotet submissions daily; we believe that the recurring larger spikes result from large-scale campaigns being kicked off by the malwares distributors. This is a sensible assumption; Emotet is mainly distributed via email spam, and more malicious emails naturally lead to more sandbox submissions.",
                        "Emotet has been one of the most professional and long-lasting cybercrime services and malware infections in the threat landscape. Notorious since shortly after its debut in 2014, the botnet was disrupted in January 2021 by a multinational law enforcement effort that sidelined its activity for almost a year. Unfortunately, in November 2021 the botnet re-emerged and once again began to appear on Sophos radar."
                    ],
                    "titles": [
                        "Appendix: Emotet and Code Obfuscation",
                        "Attacking Emotets Control Flow Flattening"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x8bd5383c>",
                            "type": "Threat",
                            "value": "emotet"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0xd91561a2>",
                    "type": "Category",
                    "value": "botnet"
                },
                "references": {
                    "sentences": [
                        "Our unflattening tool is now available on the SophosLabs Github. (For those interested in such things, we also recommend to your attention a CFF-unpacking tool released by ESET several years back to address control-flow flattening in the Stantinko botnet another example of why, since attackers freely share tactics, techniques, and procedures among themselves, defenders are wise to do the same.)",
                        "Emotet has been one of the most professional and long-lasting cybercrime services and malware infections in the threat landscape. Notorious since shortly after its debut in 2014, the botnet was disrupted in January 2021 by a multinational law enforcement effort that sidelined its activity for almost a year. Unfortunately, in November 2021 the botnet re-emerged and once again began to appear on Sophos radar."
                    ],
                    "titles": [
                        "Attacking Emotets Control Flow Flattening"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0xd91561a2>",
                            "type": "Category",
                            "value": "botnet"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x8bd5383c>",
                            "type": "Threat",
                            "value": "emotet"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0x3e4901d2>",
                    "type": "Category",
                    "value": "spam"
                },
                "references": {
                    "sentences": [
                        "Figure 1 shows the volume of Emotet payloads detected in our sandbox systems in the first quarter of 2022. As the chart shows, we receive multiple Emotet submissions daily; we believe that the recurring larger spikes result from large-scale campaigns being kicked off by the malwares distributors. This is a sensible assumption; Emotet is mainly distributed via email spam, and more malicious emails naturally lead to more sandbox submissions."
                    ],
                    "titles": [
                        "Attacking Emotets Control Flow Flattening"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0x3e4901d2>",
                            "type": "Category",
                            "value": "spam"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x8bd5383c>",
                            "type": "Threat",
                            "value": "emotet"
                        }
                    }
                ]
            }
        ]
    },
    "iocs": {
        "Hash": [
            {
                "token": {
                    "id": "<SHA256_0xcd2d204d>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "9a0286ec0a3e7ea346759c9497c8b5c7c212fa2c780a1cabb094134bf492a51b"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Attacking Emotets Control Flow Flattening"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xcd2d204d>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "9a0286ec0a3e7ea346759c9497c8b5c7c212fa2c780a1cabb094134bf492a51b"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x8bd5383c>",
                            "type": "Threat",
                            "value": "emotet"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xcd2d204d>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "9a0286ec0a3e7ea346759c9497c8b5c7c212fa2c780a1cabb094134bf492a51b"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xea1f5834>",
                            "type": "UnknownWord",
                            "value": "packed"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0x90d25b1f>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "1bbce395c839c737fdc983534b963a1521ab9693a5b585f15b8a4950adea5973"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Attacking Emotets Control Flow Flattening"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x90d25b1f>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "1bbce395c839c737fdc983534b963a1521ab9693a5b585f15b8a4950adea5973"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x8bd5383c>",
                            "type": "Threat",
                            "value": "emotet"
                        }
                    }
                ]
            }
        ]
    },
    "unknownwords": {
        "UnknownWord": [
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xaad9bd3e>",
                    "type": "UnknownWord",
                    "value": "klopsch"
                },
                "references": {
                    "sentences": [
                        "Andreas Klopsch"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd1cbef2c>",
                    "type": "UnknownWord",
                    "value": "andreas"
                },
                "references": {
                    "sentences": [
                        "Andreas Klopsch"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9e35c96c>",
                    "type": "UnknownWord",
                    "value": "uncut"
                },
                "references": {
                    "sentences": [
                        "SophosLabs Uncut"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2d38e606>",
                    "type": "UnknownWord",
                    "value": "secops"
                },
                "references": {
                    "sentences": [
                        "SecOps"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5a9f636>",
                    "type": "UnknownWord",
                    "value": "long-lasting"
                },
                "references": {
                    "sentences": [
                        "Emotet has been one of the most professional and long-lasting cybercrime services and malware infections in the threat landscape. Notorious since shortly after its debut in 2014, the botnet was disrupted in January 2021 by a multinational law enforcement effort that sidelined its activity for almost a year. Unfortunately, in November 2021 the botnet re-emerged and once again began to appear on Sophos radar."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3bc75fbf>",
                    "type": "UnknownWord",
                    "value": "debut"
                },
                "references": {
                    "sentences": [
                        "Emotet has been one of the most professional and long-lasting cybercrime services and malware infections in the threat landscape. Notorious since shortly after its debut in 2014, the botnet was disrupted in January 2021 by a multinational law enforcement effort that sidelined its activity for almost a year. Unfortunately, in November 2021 the botnet re-emerged and once again began to appear on Sophos radar."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd936030d>",
                    "type": "UnknownWord",
                    "value": "multinational"
                },
                "references": {
                    "sentences": [
                        "Emotet has been one of the most professional and long-lasting cybercrime services and malware infections in the threat landscape. Notorious since shortly after its debut in 2014, the botnet was disrupted in January 2021 by a multinational law enforcement effort that sidelined its activity for almost a year. Unfortunately, in November 2021 the botnet re-emerged and once again began to appear on Sophos radar."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8db9f54f>",
                    "type": "UnknownWord",
                    "value": "sidelined"
                },
                "references": {
                    "sentences": [
                        "Emotet has been one of the most professional and long-lasting cybercrime services and malware infections in the threat landscape. Notorious since shortly after its debut in 2014, the botnet was disrupted in January 2021 by a multinational law enforcement effort that sidelined its activity for almost a year. Unfortunately, in November 2021 the botnet re-emerged and once again began to appear on Sophos radar."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x41fc1d4d>",
                    "type": "UnknownWord",
                    "value": "re-emerged"
                },
                "references": {
                    "sentences": [
                        "Emotet has been one of the most professional and long-lasting cybercrime services and malware infections in the threat landscape. Notorious since shortly after its debut in 2014, the botnet was disrupted in January 2021 by a multinational law enforcement effort that sidelined its activity for almost a year. Unfortunately, in November 2021 the botnet re-emerged and once again began to appear on Sophos radar."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6e4a9a9b>",
                    "type": "UnknownWord",
                    "value": "hello-world"
                },
                "references": {
                    "sentences": [
                        "To protect our customers, SophosLabs is always looking for the most significant techniques, tactics, and procedures used to distribute and deliver Emotet. In this post, well look at Control Flow Flattening (CFF), one of several obfuscation tactics Emotets developers use to make detection and reverse engineering of the malwares payload more difficult. Well provide a brief example of CFF applied to a simple hello-world program, and then discuss how Sophos researchers address CFF in Emotets code. Well finish by summarizing the challenges and problems we encountered during research."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x653a3e1b>",
                    "type": "UnknownWord",
                    "value": "de-obfuscating"
                },
                "references": {
                    "sentences": [
                        "Emotets internals have been covered by many researchers, but we have not seen discussions on de-obfuscating its use of Control Flow Flattening so far."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1118b4d3>",
                    "type": "UnknownWord",
                    "value": "tenacity"
                },
                "references": {
                    "sentences": [
                        "Emotet: Resurgence and Tenacity"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbde3b766>",
                    "type": "UnknownWord",
                    "value": "quarter"
                },
                "references": {
                    "sentences": [
                        "Figure 1 shows the volume of Emotet payloads detected in our sandbox systems in the first quarter of 2022. As the chart shows, we receive multiple Emotet submissions daily; we believe that the recurring larger spikes result from large-scale campaigns being kicked off by the malwares distributors. This is a sensible assumption; Emotet is mainly distributed via email spam, and more malicious emails naturally lead to more sandbox submissions."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd98e9a19>",
                    "type": "UnknownWord",
                    "value": "recurring"
                },
                "references": {
                    "sentences": [
                        "Figure 1 shows the volume of Emotet payloads detected in our sandbox systems in the first quarter of 2022. As the chart shows, we receive multiple Emotet submissions daily; we believe that the recurring larger spikes result from large-scale campaigns being kicked off by the malwares distributors. This is a sensible assumption; Emotet is mainly distributed via email spam, and more malicious emails naturally lead to more sandbox submissions."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x51580b83>",
                    "type": "UnknownWord",
                    "value": "larger"
                },
                "references": {
                    "sentences": [
                        "The control flow is concealed. Instead of being able to follow the blocks, a control flow dispatcher block is implemented. This block determines which blocks are executed next.<crlf>A state variable annotated as stateVar in the decompiled output is updated with high entropy variables throughout the function. The state variable is used by the control flow dispatcher to decide which block gets executed next.<crlf>The two problems above lead to a highly complex decompiled output. While it is still possible to follow the execution flow, the time and effort needed to understand the function is significantly larger than it would be compared to the decompiled output in Figure 3.",
                        "Figure 1 shows the volume of Emotet payloads detected in our sandbox systems in the first quarter of 2022. As the chart shows, we receive multiple Emotet submissions daily; we believe that the recurring larger spikes result from large-scale campaigns being kicked off by the malwares distributors. This is a sensible assumption; Emotet is mainly distributed via email spam, and more malicious emails naturally lead to more sandbox submissions."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9d520040>",
                    "type": "UnknownWord",
                    "value": "kicked"
                },
                "references": {
                    "sentences": [
                        "Figure 1 shows the volume of Emotet payloads detected in our sandbox systems in the first quarter of 2022. As the chart shows, we receive multiple Emotet submissions daily; we believe that the recurring larger spikes result from large-scale campaigns being kicked off by the malwares distributors. This is a sensible assumption; Emotet is mainly distributed via email spam, and more malicious emails naturally lead to more sandbox submissions."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x53842ad0>",
                    "type": "UnknownWord",
                    "value": "distributors"
                },
                "references": {
                    "sentences": [
                        "Figure 1 shows the volume of Emotet payloads detected in our sandbox systems in the first quarter of 2022. As the chart shows, we receive multiple Emotet submissions daily; we believe that the recurring larger spikes result from large-scale campaigns being kicked off by the malwares distributors. This is a sensible assumption; Emotet is mainly distributed via email spam, and more malicious emails naturally lead to more sandbox submissions."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x56f662d9>",
                    "type": "UnknownWord",
                    "value": "sensible"
                },
                "references": {
                    "sentences": [
                        "Figure 1 shows the volume of Emotet payloads detected in our sandbox systems in the first quarter of 2022. As the chart shows, we receive multiple Emotet submissions daily; we believe that the recurring larger spikes result from large-scale campaigns being kicked off by the malwares distributors. This is a sensible assumption; Emotet is mainly distributed via email spam, and more malicious emails naturally lead to more sandbox submissions."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe7c7e42e>",
                    "type": "UnknownWord",
                    "value": "assumption"
                },
                "references": {
                    "sentences": [
                        "Figure 1 shows the volume of Emotet payloads detected in our sandbox systems in the first quarter of 2022. As the chart shows, we receive multiple Emotet submissions daily; we believe that the recurring larger spikes result from large-scale campaigns being kicked off by the malwares distributors. This is a sensible assumption; Emotet is mainly distributed via email spam, and more malicious emails naturally lead to more sandbox submissions."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x16eec167>",
                    "type": "UnknownWord",
                    "value": "naturally"
                },
                "references": {
                    "sentences": [
                        "Figure 1 shows the volume of Emotet payloads detected in our sandbox systems in the first quarter of 2022. As the chart shows, we receive multiple Emotet submissions daily; we believe that the recurring larger spikes result from large-scale campaigns being kicked off by the malwares distributors. This is a sensible assumption; Emotet is mainly distributed via email spam, and more malicious emails naturally lead to more sandbox submissions."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcb4e28d7>",
                    "type": "UnknownWord",
                    "value": "prevalence"
                },
                "references": {
                    "sentences": [
                        "In addition to Emotets delivery mechanism and prevalence, we also analyze the final payload in depth. Thus, we noticed Control Flow Flattening in an unpacked Emotet sample. Control Flow Flattening hides program flow by putting all function blocks next to each other. It is a well-known obfuscation technique used to conceal the purpose of software. While extracting the original code from a flattened binary is inherently challenging, we have successfully adapted some existing toolsets to deobfuscate the majority of Emotet payload functionality."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf36ba403>",
                    "type": "UnknownWord",
                    "value": "conceal"
                },
                "references": {
                    "sentences": [
                        "In addition to Emotets delivery mechanism and prevalence, we also analyze the final payload in depth. Thus, we noticed Control Flow Flattening in an unpacked Emotet sample. Control Flow Flattening hides program flow by putting all function blocks next to each other. It is a well-known obfuscation technique used to conceal the purpose of software. While extracting the original code from a flattened binary is inherently challenging, we have successfully adapted some existing toolsets to deobfuscate the majority of Emotet payload functionality.",
                        "Emotet uses API Hashing to conceal the usage of API functions. The malware calculates the hash of exported function names for a given DLL. If the calculated hash matches the constant pushed onto the stack at method invocation, the pointer to the exported function will be retrieved."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf54a2820>",
                    "type": "UnknownWord",
                    "value": "flattened"
                },
                "references": {
                    "sentences": [
                        "In addition to Emotets delivery mechanism and prevalence, we also analyze the final payload in depth. Thus, we noticed Control Flow Flattening in an unpacked Emotet sample. Control Flow Flattening hides program flow by putting all function blocks next to each other. It is a well-known obfuscation technique used to conceal the purpose of software. While extracting the original code from a flattened binary is inherently challenging, we have successfully adapted some existing toolsets to deobfuscate the majority of Emotet payload functionality.",
                        "A flattened block might be implemented by multiple microcode blocks. To find the end of the region, the original algorithm by Rolf Rolles generates a dominator tree and uses the generated information to determine the end of a region, or the beginning of a cluster. In some cases, the algorithm failed to find the cluster head. We added an additional function to determine the cluster head as a fallback. We believe that the original algorithm by Rolf Rolles is more reliable; however, evaluation showed that the fallback algorithm still led to good results and improved the decompiled output.",
                        "Figure 2: Comparing a flattened and non-flattened control flow graph (CFG)",
                        "Out of 254 functions, we categorized 68 functions as flattened. From these 68 functions, we were able to unflatten 38 successfully. Nineteen functions were partially flattened, and 11 functions failed. By unflattened successfully, we mean cases in which our script failed to unflatten a maximum of 3 states. Partially unflattened means that most of the function remains flattened, but our tool was able to unflatten some blocks. Finally, failed means that we were not able to deobfuscate a single block in the function.",
                        "In some cases, the existing logic failed in patching all flattened blocks. After analyzing multiple functions, we identified various patterns that reoccurred throughout the whole binary. We added additional logic to identify and unflatten blocks following these patterns to the existing code base. Finally, we adjusted the overall code a little. Some of the changes include:",
                        "Figure 5: Annotated example of a flattened function",
                        "Figure 4: Annotated example of a flattened function",
                        "The IDAPython fork of Rolf Rolles HexRaysDeob tool was based on Python2.7. We updated several parts of the code to match Python3 standards.<crlf>In the original version of the tool, if the run function was invoked once, the plugin got activated and if the tool determined the function as flattened via an algorithm, it attempted to unflatten it. During implementation and testing, we experienced crashes of IDA Pro when using the IDAPython microcode API. This might lead to a corrupted IDB database. As an additional safety mechanism, the address of the target function must be added to the array white_list to allow unflattening. Overall, we recommend saving often and keeping a separate IDB copy when using the tool."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x46561443>",
                    "type": "UnknownWord",
                    "value": "challenging"
                },
                "references": {
                    "sentences": [
                        "In addition to Emotets delivery mechanism and prevalence, we also analyze the final payload in depth. Thus, we noticed Control Flow Flattening in an unpacked Emotet sample. Control Flow Flattening hides program flow by putting all function blocks next to each other. It is a well-known obfuscation technique used to conceal the purpose of software. While extracting the original code from a flattened binary is inherently challenging, we have successfully adapted some existing toolsets to deobfuscate the majority of Emotet payload functionality."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdae5f87e>",
                    "type": "UnknownWord",
                    "value": "adapted"
                },
                "references": {
                    "sentences": [
                        "In addition to Emotets delivery mechanism and prevalence, we also analyze the final payload in depth. Thus, we noticed Control Flow Flattening in an unpacked Emotet sample. Control Flow Flattening hides program flow by putting all function blocks next to each other. It is a well-known obfuscation technique used to conceal the purpose of software. While extracting the original code from a flattened binary is inherently challenging, we have successfully adapted some existing toolsets to deobfuscate the majority of Emotet payload functionality."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x78a8f3b7>",
                    "type": "UnknownWord",
                    "value": "tidy"
                },
                "references": {
                    "sentences": [
                        "Control Flow Flattening is a technique that aims to obfuscate program flow by taking away tidy program structures in favor of putting the program blocks inside a loop with a single switch statement controlling program flow."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe4a96bb7>",
                    "type": "UnknownWord",
                    "value": "favor"
                },
                "references": {
                    "sentences": [
                        "Control Flow Flattening is a technique that aims to obfuscate program flow by taking away tidy program structures in favor of putting the program blocks inside a loop with a single switch statement controlling program flow."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7f4e91f3>",
                    "type": "UnknownWord",
                    "value": "visualization"
                },
                "references": {
                    "sentences": [
                        "First, the body of the function is broken into basic blocks, and then the blocks are put next to each other on the same level. A visualization of this transformation can be seen in Figure 2. Control Flow Flattening can be combined with other obfuscation techniques, such as API Hashing or String Encryption. Some of the most prominent obfuscators for flattening functions are OLLVM and Tigress."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8069fe91>",
                    "type": "UnknownWord",
                    "value": "transformation"
                },
                "references": {
                    "sentences": [
                        "First, the body of the function is broken into basic blocks, and then the blocks are put next to each other on the same level. A visualization of this transformation can be seen in Figure 2. Control Flow Flattening can be combined with other obfuscation techniques, such as API Hashing or String Encryption. Some of the most prominent obfuscators for flattening functions are OLLVM and Tigress."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8010afd5>",
                    "type": "UnknownWord",
                    "value": "ollvm"
                },
                "references": {
                    "sentences": [
                        "First, the body of the function is broken into basic blocks, and then the blocks are put next to each other on the same level. A visualization of this transformation can be seen in Figure 2. Control Flow Flattening can be combined with other obfuscation techniques, such as API Hashing or String Encryption. Some of the most prominent obfuscators for flattening functions are OLLVM and Tigress."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x885460cc>",
                    "type": "UnknownWord",
                    "value": "tigress"
                },
                "references": {
                    "sentences": [
                        "First, the body of the function is broken into basic blocks, and then the blocks are put next to each other on the same level. A visualization of this transformation can be seen in Figure 2. Control Flow Flattening can be combined with other obfuscation techniques, such as API Hashing or String Encryption. Some of the most prominent obfuscators for flattening functions are OLLVM and Tigress."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1b553963>",
                    "type": "UnknownWord",
                    "value": "non-flattened"
                },
                "references": {
                    "sentences": [
                        "Figure 2: Comparing a flattened and non-flattened control flow graph (CFG)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1629f65c>",
                    "type": "UnknownWord",
                    "value": "simplified"
                },
                "references": {
                    "sentences": [
                        "Lets take a quick look at a simplified example of CFF in action."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x540cec0c>",
                    "type": "UnknownWord",
                    "value": "hello"
                },
                "references": {
                    "sentences": [
                        "Flattening Hello World"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5fc27870>",
                    "type": "UnknownWord",
                    "value": "demonstration"
                },
                "references": {
                    "sentences": [
                        "For demonstration purposes, weve compiled a simple program written in C. On the left side of Figure 3, an annotated control flow graph (CFG) of the binary is shown. On the right side you can see the decompiled output generated by the Hex-Rays Decompiler."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd2102ce3>",
                    "type": "UnknownWord",
                    "value": "annotated"
                },
                "references": {
                    "sentences": [
                        "For demonstration purposes, weve compiled a simple program written in C. On the left side of Figure 3, an annotated control flow graph (CFG) of the binary is shown. On the right side you can see the decompiled output generated by the Hex-Rays Decompiler.",
                        "Figure 5: Annotated example of a flattened function",
                        "The control flow is concealed. Instead of being able to follow the blocks, a control flow dispatcher block is implemented. This block determines which blocks are executed next.<crlf>A state variable annotated as stateVar in the decompiled output is updated with high entropy variables throughout the function. The state variable is used by the control flow dispatcher to decide which block gets executed next.<crlf>The two problems above lead to a highly complex decompiled output. While it is still possible to follow the execution flow, the time and effort needed to understand the function is significantly larger than it would be compared to the decompiled output in Figure 3.",
                        "If we compare the decompiled output of Figure 3 and Figure 4, we can see multiple similarities, and we can identify the CFG dispatcher again. In the decompiled output, we see a variable we annotated as stateVar. Like the output in Figure 3, this is our state variable that is constantly updated and used by the dispatcher to determine which block is executed next.",
                        "Figure 4: Annotated example of a flattened function"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9053fc72>",
                    "type": "UnknownWord",
                    "value": "hex-rays"
                },
                "references": {
                    "sentences": [
                        "For demonstration purposes, weve compiled a simple program written in C. On the left side of Figure 3, an annotated control flow graph (CFG) of the binary is shown. On the right side you can see the decompiled output generated by the Hex-Rays Decompiler.",
                        "In this figure, no obfuscation techniques have been applied. The Hex-Rays Decompiler has no trouble generating an easy-to-read high-level language representation of the disassembly. Even without a decompiler, an experienced reverse engineer can simply follow the control flow graph to understand its purpose.",
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard",
                        "Instead of patching and operating on the disassembly directly, we make use of the Hex-Rays Microcode API. Microcode is an intermediate language used by the Hex-Rays decompiler. During decompilation, the decompiler steps through different maturity phases. The different phases are displayed in Figure 6 below. The API allows us to hook the decompilation progress and operate on the microcode instead of patching the disassembly directly."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x43981ade>",
                    "type": "UnknownWord",
                    "value": "trouble"
                },
                "references": {
                    "sentences": [
                        "In this figure, no obfuscation techniques have been applied. The Hex-Rays Decompiler has no trouble generating an easy-to-read high-level language representation of the disassembly. Even without a decompiler, an experienced reverse engineer can simply follow the control flow graph to understand its purpose."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xaac7d25c>",
                    "type": "UnknownWord",
                    "value": "easy-to-read"
                },
                "references": {
                    "sentences": [
                        "In this figure, no obfuscation techniques have been applied. The Hex-Rays Decompiler has no trouble generating an easy-to-read high-level language representation of the disassembly. Even without a decompiler, an experienced reverse engineer can simply follow the control flow graph to understand its purpose."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x722ad64a>",
                    "type": "UnknownWord",
                    "value": "flatten"
                },
                "references": {
                    "sentences": [
                        "Now well flatten the function and compare the results. Figure 4 displays the CFG and decompiled output after Control Flow Flattening was applied. On the left side, we see that the number of basic blocks has more than doubled, and reading the decompiled output is not possible any more without spending a significant amount of time analyzing it."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x60175ff2>",
                    "type": "UnknownWord",
                    "value": "doubled"
                },
                "references": {
                    "sentences": [
                        "Now well flatten the function and compare the results. Figure 4 displays the CFG and decompiled output after Control Flow Flattening was applied. On the left side, we see that the number of basic blocks has more than doubled, and reading the decompiled output is not possible any more without spending a significant amount of time analyzing it."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbcad1266>",
                    "type": "UnknownWord",
                    "value": "spending"
                },
                "references": {
                    "sentences": [
                        "Now well flatten the function and compare the results. Figure 4 displays the CFG and decompiled output after Control Flow Flattening was applied. On the left side, we see that the number of basic blocks has more than doubled, and reading the decompiled output is not possible any more without spending a significant amount of time analyzing it."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe534bc00>",
                    "type": "UnknownWord",
                    "value": "hamper"
                },
                "references": {
                    "sentences": [
                        "Overall, CFF introduces the following problems to hamper our analysis:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7876f6b6>",
                    "type": "UnknownWord",
                    "value": "concealed"
                },
                "references": {
                    "sentences": [
                        "The control flow is concealed. Instead of being able to follow the blocks, a control flow dispatcher block is implemented. This block determines which blocks are executed next.<crlf>A state variable annotated as stateVar in the decompiled output is updated with high entropy variables throughout the function. The state variable is used by the control flow dispatcher to decide which block gets executed next.<crlf>The two problems above lead to a highly complex decompiled output. While it is still possible to follow the execution flow, the time and effort needed to understand the function is significantly larger than it would be compared to the decompiled output in Figure 3."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x325bcbf3>",
                    "type": "UnknownWord",
                    "value": "statevar"
                },
                "references": {
                    "sentences": [
                        "If we compare the decompiled output of Figure 3 and Figure 4, we can see multiple similarities, and we can identify the CFG dispatcher again. In the decompiled output, we see a variable we annotated as stateVar. Like the output in Figure 3, this is our state variable that is constantly updated and used by the dispatcher to determine which block is executed next.",
                        "The control flow is concealed. Instead of being able to follow the blocks, a control flow dispatcher block is implemented. This block determines which blocks are executed next.<crlf>A state variable annotated as stateVar in the decompiled output is updated with high entropy variables throughout the function. The state variable is used by the control flow dispatcher to decide which block gets executed next.<crlf>The two problems above lead to a highly complex decompiled output. While it is still possible to follow the execution flow, the time and effort needed to understand the function is significantly larger than it would be compared to the decompiled output in Figure 3."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe42e0cf1>",
                    "type": "UnknownWord",
                    "value": "decide"
                },
                "references": {
                    "sentences": [
                        "The control flow is concealed. Instead of being able to follow the blocks, a control flow dispatcher block is implemented. This block determines which blocks are executed next.<crlf>A state variable annotated as stateVar in the decompiled output is updated with high entropy variables throughout the function. The state variable is used by the control flow dispatcher to decide which block gets executed next.<crlf>The two problems above lead to a highly complex decompiled output. While it is still possible to follow the execution flow, the time and effort needed to understand the function is significantly larger than it would be compared to the decompiled output in Figure 3."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2be53d>",
                    "type": "UnknownWord",
                    "value": "unflattening"
                },
                "references": {
                    "sentences": [
                        "Unflattening Emotet",
                        "Our unflattening tool is now available on the SophosLabs Github. (For those interested in such things, we also recommend to your attention a CFF-unpacking tool released by ESET several years back to address control-flow flattening in the Stantinko botnet another example of why, since attackers freely share tactics, techniques, and procedures among themselves, defenders are wise to do the same.)",
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard",
                        "Figure 8: Analyzed function after the CFG unflattening tool was applied",
                        "The IDAPython fork of Rolf Rolles HexRaysDeob tool was based on Python2.7. We updated several parts of the code to match Python3 standards.<crlf>In the original version of the tool, if the run function was invoked once, the plugin got activated and if the tool determined the function as flattened via an algorithm, it attempted to unflatten it. During implementation and testing, we experienced crashes of IDA Pro when using the IDAPython microcode API. This might lead to a corrupted IDB database. As an additional safety mechanism, the address of the target function must be added to the array white_list to allow unflattening. Overall, we recommend saving often and keeping a separate IDB copy when using the tool.",
                        "For deeper dives into the algorithm behind CFG Unflattening, the articles referenced above provide a wealth of information."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf837a113>",
                    "type": "UnknownWord",
                    "value": "deobfuscation"
                },
                "references": {
                    "sentences": [
                        "To deobfuscate Emotets use of Control Flow Flattening, we started with a review of existing tools and research on CFG deobfuscation. Some of those include:",
                        "In multiple functions, running the deobfuscation algorithm on a single dispatcher did not generate an output we were satisfied with. Analysis showed that more complex functions might contain multiple nested dispatchers instead of one. We added additional logic to identify and run the algorithm on multiple dispatchers. This option can be turned on or off by setting the RUN_MLTPL_DISPATCHERS flag to True or False. In Figure 7 below, you can see an example of a function with two potential dispatchers.",
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x375dafd0>",
                    "type": "UnknownWord",
                    "value": "microcode"
                },
                "references": {
                    "sentences": [
                        "A flattened block might be implemented by multiple microcode blocks. To find the end of the region, the original algorithm by Rolf Rolles generates a dominator tree and uses the generated information to determine the end of a region, or the beginning of a cluster. In some cases, the algorithm failed to find the cluster head. We added an additional function to determine the cluster head as a fallback. We believe that the original algorithm by Rolf Rolles is more reliable; however, evaluation showed that the fallback algorithm still led to good results and improved the decompiled output.",
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard",
                        "Instead of patching and operating on the disassembly directly, we make use of the Hex-Rays Microcode API. Microcode is an intermediate language used by the Hex-Rays decompiler. During decompilation, the decompiler steps through different maturity phases. The different phases are displayed in Figure 6 below. The API allows us to hook the decompilation progress and operate on the microcode instead of patching the disassembly directly.",
                        "The algorithm to detect nested dispatchers is simple. Therefore, we have added an option to turn it on and off. In rare cases, a faulty output is generated if the nested dispatcher is enabled.<crlf>In many functions, we had to deal with conditional states. Depending on the outcome of, for example, a WINAPI function, the state variable changes to a different value at runtime. Additional patching and insertion of microcode instructions would be needed to unflatten these conditional blocks.<crlf>Our main approach was to add logic for reoccurring patterns in the binary. As our work progressed, we realized that a microcode emulator might have been a better choice, or would have been an adjustment that led to more unflattened blocks.<crlf>During development and evaluation, we experienced multiple crashes. We are all humans and we make mistakes, so some crashes will result from bugs in our code. However, judging from the error messages, we believe that there is a deeper-rooted problem in the Python port of the Microcode API. Therefore, we recommend saving often and keeping a copy of the IDB file.",
                        "Figure 6: IDA Microcode maturity levels",
                        "The IDAPython fork of Rolf Rolles HexRaysDeob tool was based on Python2.7. We updated several parts of the code to match Python3 standards.<crlf>In the original version of the tool, if the run function was invoked once, the plugin got activated and if the tool determined the function as flattened via an algorithm, it attempted to unflatten it. During implementation and testing, we experienced crashes of IDA Pro when using the IDAPython microcode API. This might lead to a corrupted IDB database. As an additional safety mechanism, the address of the target function must be added to the array white_list to allow unflattening. Overall, we recommend saving often and keeping a separate IDB copy when using the tool."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7a6e3b73>",
                    "type": "UnknownWord",
                    "value": "rolf"
                },
                "references": {
                    "sentences": [
                        "A flattened block might be implemented by multiple microcode blocks. To find the end of the region, the original algorithm by Rolf Rolles generates a dominator tree and uses the generated information to determine the end of a region, or the beginning of a cluster. In some cases, the algorithm failed to find the cluster head. We added an additional function to determine the cluster head as a fallback. We believe that the original algorithm by Rolf Rolles is more reliable; however, evaluation showed that the fallback algorithm still led to good results and improved the decompiled output.",
                        "We used an IDAPython fork of the Rolf Rolles HexRaysDeob tool as our foundation. Like the fork, we are operating solely on the maturity level MMAT_LOCOPT, the third level in the figure above. As seen in Figure 6, that maturity level includes information about inbound and outbound blocks, which are necessary to correctly identify dispatcher blocks. Furthermore, the original code was based around the MMAT_LOCOPT layer. Changing the layer would have required plenty more investigation, verification, and adjustments of the existing code than keeping the layer. Below is a summarization of changes we applied on the existing code base.",
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard",
                        "The IDAPython fork of Rolf Rolles HexRaysDeob tool was based on Python2.7. We updated several parts of the code to match Python3 standards.<crlf>In the original version of the tool, if the run function was invoked once, the plugin got activated and if the tool determined the function as flattened via an algorithm, it attempted to unflatten it. During implementation and testing, we experienced crashes of IDA Pro when using the IDAPython microcode API. This might lead to a corrupted IDB database. As an additional safety mechanism, the address of the target function must be added to the array white_list to allow unflattening. Overall, we recommend saving often and keeping a separate IDB copy when using the tool."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x350acc35>",
                    "type": "UnknownWord",
                    "value": "rolles"
                },
                "references": {
                    "sentences": [
                        "A flattened block might be implemented by multiple microcode blocks. To find the end of the region, the original algorithm by Rolf Rolles generates a dominator tree and uses the generated information to determine the end of a region, or the beginning of a cluster. In some cases, the algorithm failed to find the cluster head. We added an additional function to determine the cluster head as a fallback. We believe that the original algorithm by Rolf Rolles is more reliable; however, evaluation showed that the fallback algorithm still led to good results and improved the decompiled output.",
                        "We used an IDAPython fork of the Rolf Rolles HexRaysDeob tool as our foundation. Like the fork, we are operating solely on the maturity level MMAT_LOCOPT, the third level in the figure above. As seen in Figure 6, that maturity level includes information about inbound and outbound blocks, which are necessary to correctly identify dispatcher blocks. Furthermore, the original code was based around the MMAT_LOCOPT layer. Changing the layer would have required plenty more investigation, verification, and adjustments of the existing code than keeping the layer. Below is a summarization of changes we applied on the existing code base.",
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard",
                        "The IDAPython fork of Rolf Rolles HexRaysDeob tool was based on Python2.7. We updated several parts of the code to match Python3 standards.<crlf>In the original version of the tool, if the run function was invoked once, the plugin got activated and if the tool determined the function as flattened via an algorithm, it attempted to unflatten it. During implementation and testing, we experienced crashes of IDA Pro when using the IDAPython microcode API. This might lead to a corrupted IDB database. As an additional safety mechanism, the address of the target function must be added to the array white_list to allow unflattening. Overall, we recommend saving often and keeping a separate IDB copy when using the tool."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xec3b977f>",
                    "type": "UnknownWord",
                    "value": "compiler-level"
                },
                "references": {
                    "sentences": [
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc545d16a>",
                    "type": "UnknownWord",
                    "value": "recovering"
                },
                "references": {
                    "sentences": [
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3ac5036e>",
                    "type": "UnknownWord",
                    "value": "ollvm-protected"
                },
                "references": {
                    "sentences": [
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x88f1154f>",
                    "type": "UnknownWord",
                    "value": "francis"
                },
                "references": {
                    "sentences": [
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdc605ea2>",
                    "type": "UnknownWord",
                    "value": "gabriel"
                },
                "references": {
                    "sentences": [
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x565dad30>",
                    "type": "UnknownWord",
                    "value": "quarkslab"
                },
                "references": {
                    "sentences": [
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3d78b765>",
                    "type": "UnknownWord",
                    "value": "boris batteaux"
                },
                "references": {
                    "sentences": [
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xac0df4fc>",
                    "type": "UnknownWord",
                    "value": "d810"
                },
                "references": {
                    "sentences": [
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf2f73ab2>",
                    "type": "UnknownWord",
                    "value": "eshard"
                },
                "references": {
                    "sentences": [
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x92c049f3>",
                    "type": "UnknownWord",
                    "value": "wealth"
                },
                "references": {
                    "sentences": [
                        "For deeper dives into the algorithm behind CFG Unflattening, the articles referenced above provide a wealth of information."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd248f180>",
                    "type": "UnknownWord",
                    "value": "confusing"
                },
                "references": {
                    "sentences": [
                        "In Figure 5 you can see the decompiled output and CFG of a function in an unpacked Emotet sample. Excluding the Control Flow Flattening applied here, the output might seem confusing, because Emotet applies more than just one obfuscation technique. (If you are not familiar with those other techniques, an appendix at the end of this article briefly explains the other obfuscation techniques .)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x77ae46fb>",
                    "type": "UnknownWord",
                    "value": "applies"
                },
                "references": {
                    "sentences": [
                        "In Figure 5 you can see the decompiled output and CFG of a function in an unpacked Emotet sample. Excluding the Control Flow Flattening applied here, the output might seem confusing, because Emotet applies more than just one obfuscation technique. (If you are not familiar with those other techniques, an appendix at the end of this article briefly explains the other obfuscation techniques .)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcc974fc7>",
                    "type": "UnknownWord",
                    "value": "briefly"
                },
                "references": {
                    "sentences": [
                        "In Figure 5 you can see the decompiled output and CFG of a function in an unpacked Emotet sample. Excluding the Control Flow Flattening applied here, the output might seem confusing, because Emotet applies more than just one obfuscation technique. (If you are not familiar with those other techniques, an appendix at the end of this article briefly explains the other obfuscation techniques .)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe84701a7>",
                    "type": "UnknownWord",
                    "value": "openscmanagera"
                },
                "references": {
                    "sentences": [
                        "First, the function calls OpenSCManagerA to retrieve a handle to the Service Control Manager. Next, it calls OpenServiceW to open an existing service. If opening the service succeeds, the opened service will be deleted via DeleteService. Finally, the opened handles will be closed. If the service was deleted successfully, the function returns 1, otherwise 0."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x533ce732>",
                    "type": "UnknownWord",
                    "value": "handle"
                },
                "references": {
                    "sentences": [
                        "First, the function calls OpenSCManagerA to retrieve a handle to the Service Control Manager. Next, it calls OpenServiceW to open an existing service. If opening the service succeeds, the opened service will be deleted via DeleteService. Finally, the opened handles will be closed. If the service was deleted successfully, the function returns 1, otherwise 0."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6b0633f4>",
                    "type": "UnknownWord",
                    "value": "openservicew"
                },
                "references": {
                    "sentences": [
                        "First, the function calls OpenSCManagerA to retrieve a handle to the Service Control Manager. Next, it calls OpenServiceW to open an existing service. If opening the service succeeds, the opened service will be deleted via DeleteService. Finally, the opened handles will be closed. If the service was deleted successfully, the function returns 1, otherwise 0."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x77b8a205>",
                    "type": "UnknownWord",
                    "value": "deleteservice"
                },
                "references": {
                    "sentences": [
                        "First, the function calls OpenSCManagerA to retrieve a handle to the Service Control Manager. Next, it calls OpenServiceW to open an existing service. If opening the service succeeds, the opened service will be deleted via DeleteService. Finally, the opened handles will be closed. If the service was deleted successfully, the function returns 1, otherwise 0."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x336d009c>",
                    "type": "UnknownWord",
                    "value": "decompilation"
                },
                "references": {
                    "sentences": [
                        "Instead of patching and operating on the disassembly directly, we make use of the Hex-Rays Microcode API. Microcode is an intermediate language used by the Hex-Rays decompiler. During decompilation, the decompiler steps through different maturity phases. The different phases are displayed in Figure 6 below. The API allows us to hook the decompilation progress and operate on the microcode instead of patching the disassembly directly."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9c473be6>",
                    "type": "UnknownWord",
                    "value": "maturity"
                },
                "references": {
                    "sentences": [
                        "Figure 6: IDA Microcode maturity levels",
                        "We used an IDAPython fork of the Rolf Rolles HexRaysDeob tool as our foundation. Like the fork, we are operating solely on the maturity level MMAT_LOCOPT, the third level in the figure above. As seen in Figure 6, that maturity level includes information about inbound and outbound blocks, which are necessary to correctly identify dispatcher blocks. Furthermore, the original code was based around the MMAT_LOCOPT layer. Changing the layer would have required plenty more investigation, verification, and adjustments of the existing code than keeping the layer. Below is a summarization of changes we applied on the existing code base.",
                        "Instead of patching and operating on the disassembly directly, we make use of the Hex-Rays Microcode API. Microcode is an intermediate language used by the Hex-Rays decompiler. During decompilation, the decompiler steps through different maturity phases. The different phases are displayed in Figure 6 below. The API allows us to hook the decompilation progress and operate on the microcode instead of patching the disassembly directly."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x11388b20>",
                    "type": "UnknownWord",
                    "value": "adjusting"
                },
                "references": {
                    "sentences": [
                        "Adjusting the Tool"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x77e6cd09>",
                    "type": "UnknownWord",
                    "value": "fork"
                },
                "references": {
                    "sentences": [
                        "We used an IDAPython fork of the Rolf Rolles HexRaysDeob tool as our foundation. Like the fork, we are operating solely on the maturity level MMAT_LOCOPT, the third level in the figure above. As seen in Figure 6, that maturity level includes information about inbound and outbound blocks, which are necessary to correctly identify dispatcher blocks. Furthermore, the original code was based around the MMAT_LOCOPT layer. Changing the layer would have required plenty more investigation, verification, and adjustments of the existing code than keeping the layer. Below is a summarization of changes we applied on the existing code base.",
                        "The IDAPython fork of Rolf Rolles HexRaysDeob tool was based on Python2.7. We updated several parts of the code to match Python3 standards.<crlf>In the original version of the tool, if the run function was invoked once, the plugin got activated and if the tool determined the function as flattened via an algorithm, it attempted to unflatten it. During implementation and testing, we experienced crashes of IDA Pro when using the IDAPython microcode API. This might lead to a corrupted IDB database. As an additional safety mechanism, the address of the target function must be added to the array white_list to allow unflattening. Overall, we recommend saving often and keeping a separate IDB copy when using the tool."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x89395974>",
                    "type": "UnknownWord",
                    "value": "hexraysdeob"
                },
                "references": {
                    "sentences": [
                        "The IDAPython fork of Rolf Rolles HexRaysDeob tool was based on Python2.7. We updated several parts of the code to match Python3 standards.<crlf>In the original version of the tool, if the run function was invoked once, the plugin got activated and if the tool determined the function as flattened via an algorithm, it attempted to unflatten it. During implementation and testing, we experienced crashes of IDA Pro when using the IDAPython microcode API. This might lead to a corrupted IDB database. As an additional safety mechanism, the address of the target function must be added to the array white_list to allow unflattening. Overall, we recommend saving often and keeping a separate IDB copy when using the tool.",
                        "We used an IDAPython fork of the Rolf Rolles HexRaysDeob tool as our foundation. Like the fork, we are operating solely on the maturity level MMAT_LOCOPT, the third level in the figure above. As seen in Figure 6, that maturity level includes information about inbound and outbound blocks, which are necessary to correctly identify dispatcher blocks. Furthermore, the original code was based around the MMAT_LOCOPT layer. Changing the layer would have required plenty more investigation, verification, and adjustments of the existing code than keeping the layer. Below is a summarization of changes we applied on the existing code base."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xda33937e>",
                    "type": "UnknownWord",
                    "value": "mmat_locopt"
                },
                "references": {
                    "sentences": [
                        "We used an IDAPython fork of the Rolf Rolles HexRaysDeob tool as our foundation. Like the fork, we are operating solely on the maturity level MMAT_LOCOPT, the third level in the figure above. As seen in Figure 6, that maturity level includes information about inbound and outbound blocks, which are necessary to correctly identify dispatcher blocks. Furthermore, the original code was based around the MMAT_LOCOPT layer. Changing the layer would have required plenty more investigation, verification, and adjustments of the existing code than keeping the layer. Below is a summarization of changes we applied on the existing code base."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x57cd007c>",
                    "type": "UnknownWord",
                    "value": "correctly"
                },
                "references": {
                    "sentences": [
                        "We used an IDAPython fork of the Rolf Rolles HexRaysDeob tool as our foundation. Like the fork, we are operating solely on the maturity level MMAT_LOCOPT, the third level in the figure above. As seen in Figure 6, that maturity level includes information about inbound and outbound blocks, which are necessary to correctly identify dispatcher blocks. Furthermore, the original code was based around the MMAT_LOCOPT layer. Changing the layer would have required plenty more investigation, verification, and adjustments of the existing code than keeping the layer. Below is a summarization of changes we applied on the existing code base."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x54affc24>",
                    "type": "UnknownWord",
                    "value": "furthermore"
                },
                "references": {
                    "sentences": [
                        "We used an IDAPython fork of the Rolf Rolles HexRaysDeob tool as our foundation. Like the fork, we are operating solely on the maturity level MMAT_LOCOPT, the third level in the figure above. As seen in Figure 6, that maturity level includes information about inbound and outbound blocks, which are necessary to correctly identify dispatcher blocks. Furthermore, the original code was based around the MMAT_LOCOPT layer. Changing the layer would have required plenty more investigation, verification, and adjustments of the existing code than keeping the layer. Below is a summarization of changes we applied on the existing code base."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xec11d785>",
                    "type": "UnknownWord",
                    "value": "plenty"
                },
                "references": {
                    "sentences": [
                        "We used an IDAPython fork of the Rolf Rolles HexRaysDeob tool as our foundation. Like the fork, we are operating solely on the maturity level MMAT_LOCOPT, the third level in the figure above. As seen in Figure 6, that maturity level includes information about inbound and outbound blocks, which are necessary to correctly identify dispatcher blocks. Furthermore, the original code was based around the MMAT_LOCOPT layer. Changing the layer would have required plenty more investigation, verification, and adjustments of the existing code than keeping the layer. Below is a summarization of changes we applied on the existing code base."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x51f7bcaa>",
                    "type": "UnknownWord",
                    "value": "adjustments"
                },
                "references": {
                    "sentences": [
                        "Control Flow Flattening is a complex topic, and the purpose of this article is to share our experience and results attacking Emotets Control Flow Flattening. While we made multiple adjustments and met with some success, our solution is not able to deobfuscate all functions completely. Among the outstanding issues:",
                        "We used an IDAPython fork of the Rolf Rolles HexRaysDeob tool as our foundation. Like the fork, we are operating solely on the maturity level MMAT_LOCOPT, the third level in the figure above. As seen in Figure 6, that maturity level includes information about inbound and outbound blocks, which are necessary to correctly identify dispatcher blocks. Furthermore, the original code was based around the MMAT_LOCOPT layer. Changing the layer would have required plenty more investigation, verification, and adjustments of the existing code than keeping the layer. Below is a summarization of changes we applied on the existing code base."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfadf20cd>",
                    "type": "UnknownWord",
                    "value": "summarization"
                },
                "references": {
                    "sentences": [
                        "We used an IDAPython fork of the Rolf Rolles HexRaysDeob tool as our foundation. Like the fork, we are operating solely on the maturity level MMAT_LOCOPT, the third level in the figure above. As seen in Figure 6, that maturity level includes information about inbound and outbound blocks, which are necessary to correctly identify dispatcher blocks. Furthermore, the original code was based around the MMAT_LOCOPT layer. Changing the layer would have required plenty more investigation, verification, and adjustments of the existing code than keeping the layer. Below is a summarization of changes we applied on the existing code base."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x43af6c16>",
                    "type": "UnknownWord",
                    "value": "satisfied"
                },
                "references": {
                    "sentences": [
                        "In multiple functions, running the deobfuscation algorithm on a single dispatcher did not generate an output we were satisfied with. Analysis showed that more complex functions might contain multiple nested dispatchers instead of one. We added additional logic to identify and run the algorithm on multiple dispatchers. This option can be turned on or off by setting the RUN_MLTPL_DISPATCHERS flag to True or False. In Figure 7 below, you can see an example of a function with two potential dispatchers."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x13384480>",
                    "type": "UnknownWord",
                    "value": "nested"
                },
                "references": {
                    "sentences": [
                        "The algorithm to detect nested dispatchers is simple. Therefore, we have added an option to turn it on and off. In rare cases, a faulty output is generated if the nested dispatcher is enabled.<crlf>In many functions, we had to deal with conditional states. Depending on the outcome of, for example, a WINAPI function, the state variable changes to a different value at runtime. Additional patching and insertion of microcode instructions would be needed to unflatten these conditional blocks.<crlf>Our main approach was to add logic for reoccurring patterns in the binary. As our work progressed, we realized that a microcode emulator might have been a better choice, or would have been an adjustment that led to more unflattened blocks.<crlf>During development and evaluation, we experienced multiple crashes. We are all humans and we make mistakes, so some crashes will result from bugs in our code. However, judging from the error messages, we believe that there is a deeper-rooted problem in the Python port of the Microcode API. Therefore, we recommend saving often and keeping a copy of the IDB file.",
                        "In multiple functions, running the deobfuscation algorithm on a single dispatcher did not generate an output we were satisfied with. Analysis showed that more complex functions might contain multiple nested dispatchers instead of one. We added additional logic to identify and run the algorithm on multiple dispatchers. This option can be turned on or off by setting the RUN_MLTPL_DISPATCHERS flag to True or False. In Figure 7 below, you can see an example of a function with two potential dispatchers."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc2eddf26>",
                    "type": "UnknownWord",
                    "value": "run_mltpl_dispatchers"
                },
                "references": {
                    "sentences": [
                        "In multiple functions, running the deobfuscation algorithm on a single dispatcher did not generate an output we were satisfied with. Analysis showed that more complex functions might contain multiple nested dispatchers instead of one. We added additional logic to identify and run the algorithm on multiple dispatchers. This option can be turned on or off by setting the RUN_MLTPL_DISPATCHERS flag to True or False. In Figure 7 below, you can see an example of a function with two potential dispatchers."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xad1fc598>",
                    "type": "UnknownWord",
                    "value": "dominator"
                },
                "references": {
                    "sentences": [
                        "A flattened block might be implemented by multiple microcode blocks. To find the end of the region, the original algorithm by Rolf Rolles generates a dominator tree and uses the generated information to determine the end of a region, or the beginning of a cluster. In some cases, the algorithm failed to find the cluster head. We added an additional function to determine the cluster head as a fallback. We believe that the original algorithm by Rolf Rolles is more reliable; however, evaluation showed that the fallback algorithm still led to good results and improved the decompiled output."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd0752dd8>",
                    "type": "UnknownWord",
                    "value": "tree"
                },
                "references": {
                    "sentences": [
                        "A flattened block might be implemented by multiple microcode blocks. To find the end of the region, the original algorithm by Rolf Rolles generates a dominator tree and uses the generated information to determine the end of a region, or the beginning of a cluster. In some cases, the algorithm failed to find the cluster head. We added an additional function to determine the cluster head as a fallback. We believe that the original algorithm by Rolf Rolles is more reliable; however, evaluation showed that the fallback algorithm still led to good results and improved the decompiled output."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9764f553>",
                    "type": "UnknownWord",
                    "value": "fallback"
                },
                "references": {
                    "sentences": [
                        "A flattened block might be implemented by multiple microcode blocks. To find the end of the region, the original algorithm by Rolf Rolles generates a dominator tree and uses the generated information to determine the end of a region, or the beginning of a cluster. In some cases, the algorithm failed to find the cluster head. We added an additional function to determine the cluster head as a fallback. We believe that the original algorithm by Rolf Rolles is more reliable; however, evaluation showed that the fallback algorithm still led to good results and improved the decompiled output."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xae1ba092>",
                    "type": "UnknownWord",
                    "value": "evaluation"
                },
                "references": {
                    "sentences": [
                        "A flattened block might be implemented by multiple microcode blocks. To find the end of the region, the original algorithm by Rolf Rolles generates a dominator tree and uses the generated information to determine the end of a region, or the beginning of a cluster. In some cases, the algorithm failed to find the cluster head. We added an additional function to determine the cluster head as a fallback. We believe that the original algorithm by Rolf Rolles is more reliable; however, evaluation showed that the fallback algorithm still led to good results and improved the decompiled output.",
                        "The algorithm to detect nested dispatchers is simple. Therefore, we have added an option to turn it on and off. In rare cases, a faulty output is generated if the nested dispatcher is enabled.<crlf>In many functions, we had to deal with conditional states. Depending on the outcome of, for example, a WINAPI function, the state variable changes to a different value at runtime. Additional patching and insertion of microcode instructions would be needed to unflatten these conditional blocks.<crlf>Our main approach was to add logic for reoccurring patterns in the binary. As our work progressed, we realized that a microcode emulator might have been a better choice, or would have been an adjustment that led to more unflattened blocks.<crlf>During development and evaluation, we experienced multiple crashes. We are all humans and we make mistakes, so some crashes will result from bugs in our code. However, judging from the error messages, we believe that there is a deeper-rooted problem in the Python port of the Microcode API. Therefore, we recommend saving often and keeping a copy of the IDB file."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3261af03>",
                    "type": "UnknownWord",
                    "value": "reoccurred"
                },
                "references": {
                    "sentences": [
                        "In some cases, the existing logic failed in patching all flattened blocks. After analyzing multiple functions, we identified various patterns that reoccurred throughout the whole binary. We added additional logic to identify and unflatten blocks following these patterns to the existing code base. Finally, we adjusted the overall code a little. Some of the changes include:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9af1c408>",
                    "type": "UnknownWord",
                    "value": "unflatten"
                },
                "references": {
                    "sentences": [
                        "The algorithm to detect nested dispatchers is simple. Therefore, we have added an option to turn it on and off. In rare cases, a faulty output is generated if the nested dispatcher is enabled.<crlf>In many functions, we had to deal with conditional states. Depending on the outcome of, for example, a WINAPI function, the state variable changes to a different value at runtime. Additional patching and insertion of microcode instructions would be needed to unflatten these conditional blocks.<crlf>Our main approach was to add logic for reoccurring patterns in the binary. As our work progressed, we realized that a microcode emulator might have been a better choice, or would have been an adjustment that led to more unflattened blocks.<crlf>During development and evaluation, we experienced multiple crashes. We are all humans and we make mistakes, so some crashes will result from bugs in our code. However, judging from the error messages, we believe that there is a deeper-rooted problem in the Python port of the Microcode API. Therefore, we recommend saving often and keeping a copy of the IDB file.",
                        "Out of 254 functions, we categorized 68 functions as flattened. From these 68 functions, we were able to unflatten 38 successfully. Nineteen functions were partially flattened, and 11 functions failed. By unflattened successfully, we mean cases in which our script failed to unflatten a maximum of 3 states. Partially unflattened means that most of the function remains flattened, but our tool was able to unflatten some blocks. Finally, failed means that we were not able to deobfuscate a single block in the function.",
                        "In some cases, the existing logic failed in patching all flattened blocks. After analyzing multiple functions, we identified various patterns that reoccurred throughout the whole binary. We added additional logic to identify and unflatten blocks following these patterns to the existing code base. Finally, we adjusted the overall code a little. Some of the changes include:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9c9f9a0c>",
                    "type": "UnknownWord",
                    "value": "adjusted"
                },
                "references": {
                    "sentences": [
                        "In some cases, the existing logic failed in patching all flattened blocks. After analyzing multiple functions, we identified various patterns that reoccurred throughout the whole binary. We added additional logic to identify and unflatten blocks following these patterns to the existing code base. Finally, we adjusted the overall code a little. Some of the changes include:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xaddf48ab>",
                    "type": "UnknownWord",
                    "value": "python2"
                },
                "references": {
                    "sentences": [
                        "The IDAPython fork of Rolf Rolles HexRaysDeob tool was based on Python2.7. We updated several parts of the code to match Python3 standards.<crlf>In the original version of the tool, if the run function was invoked once, the plugin got activated and if the tool determined the function as flattened via an algorithm, it attempted to unflatten it. During implementation and testing, we experienced crashes of IDA Pro when using the IDAPython microcode API. This might lead to a corrupted IDB database. As an additional safety mechanism, the address of the target function must be added to the array white_list to allow unflattening. Overall, we recommend saving often and keeping a separate IDB copy when using the tool."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x736fa90b>",
                    "type": "UnknownWord",
                    "value": "python3"
                },
                "references": {
                    "sentences": [
                        "The IDAPython fork of Rolf Rolles HexRaysDeob tool was based on Python2.7. We updated several parts of the code to match Python3 standards.<crlf>In the original version of the tool, if the run function was invoked once, the plugin got activated and if the tool determined the function as flattened via an algorithm, it attempted to unflatten it. During implementation and testing, we experienced crashes of IDA Pro when using the IDAPython microcode API. This might lead to a corrupted IDB database. As an additional safety mechanism, the address of the target function must be added to the array white_list to allow unflattening. Overall, we recommend saving often and keeping a separate IDB copy when using the tool."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5323e639>",
                    "type": "UnknownWord",
                    "value": "invoked"
                },
                "references": {
                    "sentences": [
                        "Figure 12: Multiple values being pushed onto the stack before DYN_BCryptEncrypt is invoked",
                        "The IDAPython fork of Rolf Rolles HexRaysDeob tool was based on Python2.7. We updated several parts of the code to match Python3 standards.<crlf>In the original version of the tool, if the run function was invoked once, the plugin got activated and if the tool determined the function as flattened via an algorithm, it attempted to unflatten it. During implementation and testing, we experienced crashes of IDA Pro when using the IDAPython microcode API. This might lead to a corrupted IDB database. As an additional safety mechanism, the address of the target function must be added to the array white_list to allow unflattening. Overall, we recommend saving often and keeping a separate IDB copy when using the tool.",
                        "Another interesting technique that confuses the IDA decompiler is the way in which Emotet passes parameters to functions. In Figure 12 below, we show how DYN_BCryptEncrypt is invoked."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1151c225>",
                    "type": "UnknownWord",
                    "value": "corrupted"
                },
                "references": {
                    "sentences": [
                        "The IDAPython fork of Rolf Rolles HexRaysDeob tool was based on Python2.7. We updated several parts of the code to match Python3 standards.<crlf>In the original version of the tool, if the run function was invoked once, the plugin got activated and if the tool determined the function as flattened via an algorithm, it attempted to unflatten it. During implementation and testing, we experienced crashes of IDA Pro when using the IDAPython microcode API. This might lead to a corrupted IDB database. As an additional safety mechanism, the address of the target function must be added to the array white_list to allow unflattening. Overall, we recommend saving often and keeping a separate IDB copy when using the tool."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1ea39caa>",
                    "type": "UnknownWord",
                    "value": "idb"
                },
                "references": {
                    "sentences": [
                        "The algorithm to detect nested dispatchers is simple. Therefore, we have added an option to turn it on and off. In rare cases, a faulty output is generated if the nested dispatcher is enabled.<crlf>In many functions, we had to deal with conditional states. Depending on the outcome of, for example, a WINAPI function, the state variable changes to a different value at runtime. Additional patching and insertion of microcode instructions would be needed to unflatten these conditional blocks.<crlf>Our main approach was to add logic for reoccurring patterns in the binary. As our work progressed, we realized that a microcode emulator might have been a better choice, or would have been an adjustment that led to more unflattened blocks.<crlf>During development and evaluation, we experienced multiple crashes. We are all humans and we make mistakes, so some crashes will result from bugs in our code. However, judging from the error messages, we believe that there is a deeper-rooted problem in the Python port of the Microcode API. Therefore, we recommend saving often and keeping a copy of the IDB file.",
                        "The IDAPython fork of Rolf Rolles HexRaysDeob tool was based on Python2.7. We updated several parts of the code to match Python3 standards.<crlf>In the original version of the tool, if the run function was invoked once, the plugin got activated and if the tool determined the function as flattened via an algorithm, it attempted to unflatten it. During implementation and testing, we experienced crashes of IDA Pro when using the IDAPython microcode API. This might lead to a corrupted IDB database. As an additional safety mechanism, the address of the target function must be added to the array white_list to allow unflattening. Overall, we recommend saving often and keeping a separate IDB copy when using the tool."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x215a08c9>",
                    "type": "UnknownWord",
                    "value": "white_list"
                },
                "references": {
                    "sentences": [
                        "The IDAPython fork of Rolf Rolles HexRaysDeob tool was based on Python2.7. We updated several parts of the code to match Python3 standards.<crlf>In the original version of the tool, if the run function was invoked once, the plugin got activated and if the tool determined the function as flattened via an algorithm, it attempted to unflatten it. During implementation and testing, we experienced crashes of IDA Pro when using the IDAPython microcode API. This might lead to a corrupted IDB database. As an additional safety mechanism, the address of the target function must be added to the array white_list to allow unflattening. Overall, we recommend saving often and keeping a separate IDB copy when using the tool."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe4f321ea>",
                    "type": "UnknownWord",
                    "value": "nineteen"
                },
                "references": {
                    "sentences": [
                        "Out of 254 functions, we categorized 68 functions as flattened. From these 68 functions, we were able to unflatten 38 successfully. Nineteen functions were partially flattened, and 11 functions failed. By unflattened successfully, we mean cases in which our script failed to unflatten a maximum of 3 states. Partially unflattened means that most of the function remains flattened, but our tool was able to unflatten some blocks. Finally, failed means that we were not able to deobfuscate a single block in the function."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd488ea4e>",
                    "type": "UnknownWord",
                    "value": "unflattened"
                },
                "references": {
                    "sentences": [
                        "The algorithm to detect nested dispatchers is simple. Therefore, we have added an option to turn it on and off. In rare cases, a faulty output is generated if the nested dispatcher is enabled.<crlf>In many functions, we had to deal with conditional states. Depending on the outcome of, for example, a WINAPI function, the state variable changes to a different value at runtime. Additional patching and insertion of microcode instructions would be needed to unflatten these conditional blocks.<crlf>Our main approach was to add logic for reoccurring patterns in the binary. As our work progressed, we realized that a microcode emulator might have been a better choice, or would have been an adjustment that led to more unflattened blocks.<crlf>During development and evaluation, we experienced multiple crashes. We are all humans and we make mistakes, so some crashes will result from bugs in our code. However, judging from the error messages, we believe that there is a deeper-rooted problem in the Python port of the Microcode API. Therefore, we recommend saving often and keeping a copy of the IDB file.",
                        "Out of 254 functions, we categorized 68 functions as flattened. From these 68 functions, we were able to unflatten 38 successfully. Nineteen functions were partially flattened, and 11 functions failed. By unflattened successfully, we mean cases in which our script failed to unflatten a maximum of 3 states. Partially unflattened means that most of the function remains flattened, but our tool was able to unflatten some blocks. Finally, failed means that we were not able to deobfuscate a single block in the function."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xea1f5834>",
                    "type": "UnknownWord",
                    "value": "packed"
                },
                "references": {
                    "sentences": [
                        "When sharing the decompiled output of functions in an Emotet sample, it is impossible not to encounter other Emotet obfuscation techniques beyond CFF. This appendix covers the most prevalent obfuscation techniques we have identified in an unpacked Emotet sample. Keep in mind that Emotet is usually delivered in a packed form and needs to be unpacked first."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xcd2d204d>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "9a0286ec0a3e7ea346759c9497c8b5c7c212fa2c780a1cabb094134bf492a51b"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xea1f5834>",
                            "type": "UnknownWord",
                            "value": "packed"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x907bca0>",
                    "type": "UnknownWord",
                    "value": "interested"
                },
                "references": {
                    "sentences": [
                        "Our unflattening tool is now available on the SophosLabs Github. (For those interested in such things, we also recommend to your attention a CFF-unpacking tool released by ESET several years back to address control-flow flattening in the Stantinko botnet another example of why, since attackers freely share tactics, techniques, and procedures among themselves, defenders are wise to do the same.)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xeb14ec3e>",
                    "type": "UnknownWord",
                    "value": "cff-unpacking"
                },
                "references": {
                    "sentences": [
                        "Our unflattening tool is now available on the SophosLabs Github. (For those interested in such things, we also recommend to your attention a CFF-unpacking tool released by ESET several years back to address control-flow flattening in the Stantinko botnet another example of why, since attackers freely share tactics, techniques, and procedures among themselves, defenders are wise to do the same.)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6f92e2ac>",
                    "type": "UnknownWord",
                    "value": "control-flow"
                },
                "references": {
                    "sentences": [
                        "Our unflattening tool is now available on the SophosLabs Github. (For those interested in such things, we also recommend to your attention a CFF-unpacking tool released by ESET several years back to address control-flow flattening in the Stantinko botnet another example of why, since attackers freely share tactics, techniques, and procedures among themselves, defenders are wise to do the same.)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x218ac238>",
                    "type": "UnknownWord",
                    "value": "freely"
                },
                "references": {
                    "sentences": [
                        "Our unflattening tool is now available on the SophosLabs Github. (For those interested in such things, we also recommend to your attention a CFF-unpacking tool released by ESET several years back to address control-flow flattening in the Stantinko botnet another example of why, since attackers freely share tactics, techniques, and procedures among themselves, defenders are wise to do the same.)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xde471987>",
                    "type": "UnknownWord",
                    "value": "wise"
                },
                "references": {
                    "sentences": [
                        "Our unflattening tool is now available on the SophosLabs Github. (For those interested in such things, we also recommend to your attention a CFF-unpacking tool released by ESET several years back to address control-flow flattening in the Stantinko botnet another example of why, since attackers freely share tactics, techniques, and procedures among themselves, defenders are wise to do the same.)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x46d816ae>",
                    "type": "UnknownWord",
                    "value": "faulty"
                },
                "references": {
                    "sentences": [
                        "The algorithm to detect nested dispatchers is simple. Therefore, we have added an option to turn it on and off. In rare cases, a faulty output is generated if the nested dispatcher is enabled.<crlf>In many functions, we had to deal with conditional states. Depending on the outcome of, for example, a WINAPI function, the state variable changes to a different value at runtime. Additional patching and insertion of microcode instructions would be needed to unflatten these conditional blocks.<crlf>Our main approach was to add logic for reoccurring patterns in the binary. As our work progressed, we realized that a microcode emulator might have been a better choice, or would have been an adjustment that led to more unflattened blocks.<crlf>During development and evaluation, we experienced multiple crashes. We are all humans and we make mistakes, so some crashes will result from bugs in our code. However, judging from the error messages, we believe that there is a deeper-rooted problem in the Python port of the Microcode API. Therefore, we recommend saving often and keeping a copy of the IDB file."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x36aecad1>",
                    "type": "UnknownWord",
                    "value": "conditional"
                },
                "references": {
                    "sentences": [
                        "The algorithm to detect nested dispatchers is simple. Therefore, we have added an option to turn it on and off. In rare cases, a faulty output is generated if the nested dispatcher is enabled.<crlf>In many functions, we had to deal with conditional states. Depending on the outcome of, for example, a WINAPI function, the state variable changes to a different value at runtime. Additional patching and insertion of microcode instructions would be needed to unflatten these conditional blocks.<crlf>Our main approach was to add logic for reoccurring patterns in the binary. As our work progressed, we realized that a microcode emulator might have been a better choice, or would have been an adjustment that led to more unflattened blocks.<crlf>During development and evaluation, we experienced multiple crashes. We are all humans and we make mistakes, so some crashes will result from bugs in our code. However, judging from the error messages, we believe that there is a deeper-rooted problem in the Python port of the Microcode API. Therefore, we recommend saving often and keeping a copy of the IDB file."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7a86d374>",
                    "type": "UnknownWord",
                    "value": "winapi"
                },
                "references": {
                    "sentences": [
                        "The algorithm to detect nested dispatchers is simple. Therefore, we have added an option to turn it on and off. In rare cases, a faulty output is generated if the nested dispatcher is enabled.<crlf>In many functions, we had to deal with conditional states. Depending on the outcome of, for example, a WINAPI function, the state variable changes to a different value at runtime. Additional patching and insertion of microcode instructions would be needed to unflatten these conditional blocks.<crlf>Our main approach was to add logic for reoccurring patterns in the binary. As our work progressed, we realized that a microcode emulator might have been a better choice, or would have been an adjustment that led to more unflattened blocks.<crlf>During development and evaluation, we experienced multiple crashes. We are all humans and we make mistakes, so some crashes will result from bugs in our code. However, judging from the error messages, we believe that there is a deeper-rooted problem in the Python port of the Microcode API. Therefore, we recommend saving often and keeping a copy of the IDB file."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf97a15fa>",
                    "type": "UnknownWord",
                    "value": "insertion"
                },
                "references": {
                    "sentences": [
                        "The algorithm to detect nested dispatchers is simple. Therefore, we have added an option to turn it on and off. In rare cases, a faulty output is generated if the nested dispatcher is enabled.<crlf>In many functions, we had to deal with conditional states. Depending on the outcome of, for example, a WINAPI function, the state variable changes to a different value at runtime. Additional patching and insertion of microcode instructions would be needed to unflatten these conditional blocks.<crlf>Our main approach was to add logic for reoccurring patterns in the binary. As our work progressed, we realized that a microcode emulator might have been a better choice, or would have been an adjustment that led to more unflattened blocks.<crlf>During development and evaluation, we experienced multiple crashes. We are all humans and we make mistakes, so some crashes will result from bugs in our code. However, judging from the error messages, we believe that there is a deeper-rooted problem in the Python port of the Microcode API. Therefore, we recommend saving often and keeping a copy of the IDB file."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x26f677f1>",
                    "type": "UnknownWord",
                    "value": "reoccurring"
                },
                "references": {
                    "sentences": [
                        "The algorithm to detect nested dispatchers is simple. Therefore, we have added an option to turn it on and off. In rare cases, a faulty output is generated if the nested dispatcher is enabled.<crlf>In many functions, we had to deal with conditional states. Depending on the outcome of, for example, a WINAPI function, the state variable changes to a different value at runtime. Additional patching and insertion of microcode instructions would be needed to unflatten these conditional blocks.<crlf>Our main approach was to add logic for reoccurring patterns in the binary. As our work progressed, we realized that a microcode emulator might have been a better choice, or would have been an adjustment that led to more unflattened blocks.<crlf>During development and evaluation, we experienced multiple crashes. We are all humans and we make mistakes, so some crashes will result from bugs in our code. However, judging from the error messages, we believe that there is a deeper-rooted problem in the Python port of the Microcode API. Therefore, we recommend saving often and keeping a copy of the IDB file."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x140c3f20>",
                    "type": "UnknownWord",
                    "value": "progressed"
                },
                "references": {
                    "sentences": [
                        "The algorithm to detect nested dispatchers is simple. Therefore, we have added an option to turn it on and off. In rare cases, a faulty output is generated if the nested dispatcher is enabled.<crlf>In many functions, we had to deal with conditional states. Depending on the outcome of, for example, a WINAPI function, the state variable changes to a different value at runtime. Additional patching and insertion of microcode instructions would be needed to unflatten these conditional blocks.<crlf>Our main approach was to add logic for reoccurring patterns in the binary. As our work progressed, we realized that a microcode emulator might have been a better choice, or would have been an adjustment that led to more unflattened blocks.<crlf>During development and evaluation, we experienced multiple crashes. We are all humans and we make mistakes, so some crashes will result from bugs in our code. However, judging from the error messages, we believe that there is a deeper-rooted problem in the Python port of the Microcode API. Therefore, we recommend saving often and keeping a copy of the IDB file."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x87937905>",
                    "type": "UnknownWord",
                    "value": "realized"
                },
                "references": {
                    "sentences": [
                        "The algorithm to detect nested dispatchers is simple. Therefore, we have added an option to turn it on and off. In rare cases, a faulty output is generated if the nested dispatcher is enabled.<crlf>In many functions, we had to deal with conditional states. Depending on the outcome of, for example, a WINAPI function, the state variable changes to a different value at runtime. Additional patching and insertion of microcode instructions would be needed to unflatten these conditional blocks.<crlf>Our main approach was to add logic for reoccurring patterns in the binary. As our work progressed, we realized that a microcode emulator might have been a better choice, or would have been an adjustment that led to more unflattened blocks.<crlf>During development and evaluation, we experienced multiple crashes. We are all humans and we make mistakes, so some crashes will result from bugs in our code. However, judging from the error messages, we believe that there is a deeper-rooted problem in the Python port of the Microcode API. Therefore, we recommend saving often and keeping a copy of the IDB file."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9e1f7afb>",
                    "type": "UnknownWord",
                    "value": "adjustment"
                },
                "references": {
                    "sentences": [
                        "The algorithm to detect nested dispatchers is simple. Therefore, we have added an option to turn it on and off. In rare cases, a faulty output is generated if the nested dispatcher is enabled.<crlf>In many functions, we had to deal with conditional states. Depending on the outcome of, for example, a WINAPI function, the state variable changes to a different value at runtime. Additional patching and insertion of microcode instructions would be needed to unflatten these conditional blocks.<crlf>Our main approach was to add logic for reoccurring patterns in the binary. As our work progressed, we realized that a microcode emulator might have been a better choice, or would have been an adjustment that led to more unflattened blocks.<crlf>During development and evaluation, we experienced multiple crashes. We are all humans and we make mistakes, so some crashes will result from bugs in our code. However, judging from the error messages, we believe that there is a deeper-rooted problem in the Python port of the Microcode API. Therefore, we recommend saving often and keeping a copy of the IDB file."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7884deda>",
                    "type": "UnknownWord",
                    "value": "judging"
                },
                "references": {
                    "sentences": [
                        "The algorithm to detect nested dispatchers is simple. Therefore, we have added an option to turn it on and off. In rare cases, a faulty output is generated if the nested dispatcher is enabled.<crlf>In many functions, we had to deal with conditional states. Depending on the outcome of, for example, a WINAPI function, the state variable changes to a different value at runtime. Additional patching and insertion of microcode instructions would be needed to unflatten these conditional blocks.<crlf>Our main approach was to add logic for reoccurring patterns in the binary. As our work progressed, we realized that a microcode emulator might have been a better choice, or would have been an adjustment that led to more unflattened blocks.<crlf>During development and evaluation, we experienced multiple crashes. We are all humans and we make mistakes, so some crashes will result from bugs in our code. However, judging from the error messages, we believe that there is a deeper-rooted problem in the Python port of the Microcode API. Therefore, we recommend saving often and keeping a copy of the IDB file."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7b7314d2>",
                    "type": "UnknownWord",
                    "value": "deeper-rooted"
                },
                "references": {
                    "sentences": [
                        "The algorithm to detect nested dispatchers is simple. Therefore, we have added an option to turn it on and off. In rare cases, a faulty output is generated if the nested dispatcher is enabled.<crlf>In many functions, we had to deal with conditional states. Depending on the outcome of, for example, a WINAPI function, the state variable changes to a different value at runtime. Additional patching and insertion of microcode instructions would be needed to unflatten these conditional blocks.<crlf>Our main approach was to add logic for reoccurring patterns in the binary. As our work progressed, we realized that a microcode emulator might have been a better choice, or would have been an adjustment that led to more unflattened blocks.<crlf>During development and evaluation, we experienced multiple crashes. We are all humans and we make mistakes, so some crashes will result from bugs in our code. However, judging from the error messages, we believe that there is a deeper-rooted problem in the Python port of the Microcode API. Therefore, we recommend saving often and keeping a copy of the IDB file."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x40a63872>",
                    "type": "UnknownWord",
                    "value": "cross-check"
                },
                "references": {
                    "sentences": [
                        "Overall, we recommend that researchers always cross-check their results and not trust the output blindly. Control Flow Flattening used in conjunction with other obfuscation techniques certainly complicates the process of reverse engineering Emotet, but the technique weve described helps to even the odds against researchers examining this high-profile malware."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x26ad5415>",
                    "type": "UnknownWord",
                    "value": "blindly"
                },
                "references": {
                    "sentences": [
                        "Overall, we recommend that researchers always cross-check their results and not trust the output blindly. Control Flow Flattening used in conjunction with other obfuscation techniques certainly complicates the process of reverse engineering Emotet, but the technique weve described helps to even the odds against researchers examining this high-profile malware."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa4b70cf7>",
                    "type": "UnknownWord",
                    "value": "freed"
                },
                "references": {
                    "sentences": [
                        "Emotet contains encrypted strings in its unpacked form. Before usage, strings will be decrypted and freed again right after each serves its purpose."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x59087011>",
                    "type": "UnknownWord",
                    "value": "decryptstring"
                },
                "references": {
                    "sentences": [
                        "Figure 9: Cross references of DecryptString function with corresponding decrypted string"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x187044d9>",
                    "type": "UnknownWord",
                    "value": "calculates"
                },
                "references": {
                    "sentences": [
                        "Emotet uses API Hashing to conceal the usage of API functions. The malware calculates the hash of exported function names for a given DLL. If the calculated hash matches the constant pushed onto the stack at method invocation, the pointer to the exported function will be retrieved."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1525fafe>",
                    "type": "UnknownWord",
                    "value": "stack"
                },
                "references": {
                    "sentences": [
                        "Figure 12: Multiple values being pushed onto the stack before DYN_BCryptEncrypt is invoked",
                        "DYN_BCryptEncrypt first resolves the API function BCryptEncrypt and stores the pointer to this function in register EAX. The function is then called via call EAX. Instead of just pushing the necessary parameters, this method pushes values onto the stack not being used by the actual EAX call. This leads to generation of a function signature that is much harder to read than normal.",
                        "Emotet uses API Hashing to conceal the usage of API functions. The malware calculates the hash of exported function names for a given DLL. If the calculated hash matches the constant pushed onto the stack at method invocation, the pointer to the exported function will be retrieved.",
                        "Stack Obfuscation"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x46f1bff>",
                    "type": "UnknownWord",
                    "value": "invocation"
                },
                "references": {
                    "sentences": [
                        "Emotet uses API Hashing to conceal the usage of API functions. The malware calculates the hash of exported function names for a given DLL. If the calculated hash matches the constant pushed onto the stack at method invocation, the pointer to the exported function will be retrieved.",
                        "Figure 10: Disassembly of ApiHash function invocation"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x97194fbf>",
                    "type": "UnknownWord",
                    "value": "pointer"
                },
                "references": {
                    "sentences": [
                        "DYN_BCryptEncrypt first resolves the API function BCryptEncrypt and stores the pointer to this function in register EAX. The function is then called via call EAX. Instead of just pushing the necessary parameters, this method pushes values onto the stack not being used by the actual EAX call. This leads to generation of a function signature that is much harder to read than normal.",
                        "Emotet uses API Hashing to conceal the usage of API functions. The malware calculates the hash of exported function names for a given DLL. If the calculated hash matches the constant pushed onto the stack at method invocation, the pointer to the exported function will be retrieved."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x219b67fd>",
                    "type": "UnknownWord",
                    "value": "apihash"
                },
                "references": {
                    "sentences": [
                        "Figure 10: Disassembly of ApiHash function invocation"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5a7e002f>",
                    "type": "UnknownWord",
                    "value": "wrapped"
                },
                "references": {
                    "sentences": [
                        "In most cases, API Hashing calls and their corresponding dynamic call are wrapped into separate functions. We have automated this analysis, and functions with prefix DYN_ are functions determined at runtime via API Hashing."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa79d3990>",
                    "type": "UnknownWord",
                    "value": "prefix"
                },
                "references": {
                    "sentences": [
                        "In most cases, API Hashing calls and their corresponding dynamic call are wrapped into separate functions. We have automated this analysis, and functions with prefix DYN_ are functions determined at runtime via API Hashing."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x341d804d>",
                    "type": "UnknownWord",
                    "value": "dyn_"
                },
                "references": {
                    "sentences": [
                        "In most cases, API Hashing calls and their corresponding dynamic call are wrapped into separate functions. We have automated this analysis, and functions with prefix DYN_ are functions determined at runtime via API Hashing."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x142df5b0>",
                    "type": "UnknownWord",
                    "value": "confuse"
                },
                "references": {
                    "sentences": [
                        "Emotet embeds junk instructions to confuse reverse engineers. Junk instructions are instructions that do not serve any purpose except to complicate and slow down analysis. Figure 11 below shows an example of a junk instruction block."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9e6afd05>",
                    "type": "UnknownWord",
                    "value": "slow"
                },
                "references": {
                    "sentences": [
                        "Emotet embeds junk instructions to confuse reverse engineers. Junk instructions are instructions that do not serve any purpose except to complicate and slow down analysis. Figure 11 below shows an example of a junk instruction block."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x25f29c31>",
                    "type": "UnknownWord",
                    "value": "ida decompiler"
                },
                "references": {
                    "sentences": [
                        "Another interesting technique that confuses the IDA decompiler is the way in which Emotet passes parameters to functions. In Figure 12 below, we show how DYN_BCryptEncrypt is invoked."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x66548b17>",
                    "type": "UnknownWord",
                    "value": "confuses"
                },
                "references": {
                    "sentences": [
                        "Another interesting technique that confuses the IDA decompiler is the way in which Emotet passes parameters to functions. In Figure 12 below, we show how DYN_BCryptEncrypt is invoked."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7a07850f>",
                    "type": "UnknownWord",
                    "value": "dyn_bcryptencrypt"
                },
                "references": {
                    "sentences": [
                        "Figure 12: Multiple values being pushed onto the stack before DYN_BCryptEncrypt is invoked",
                        "DYN_BCryptEncrypt first resolves the API function BCryptEncrypt and stores the pointer to this function in register EAX. The function is then called via call EAX. Instead of just pushing the necessary parameters, this method pushes values onto the stack not being used by the actual EAX call. This leads to generation of a function signature that is much harder to read than normal.",
                        "Another interesting technique that confuses the IDA decompiler is the way in which Emotet passes parameters to functions. In Figure 12 below, we show how DYN_BCryptEncrypt is invoked."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8e605a55>",
                    "type": "UnknownWord",
                    "value": "bcryptencrypt"
                },
                "references": {
                    "sentences": [
                        "DYN_BCryptEncrypt first resolves the API function BCryptEncrypt and stores the pointer to this function in register EAX. The function is then called via call EAX. Instead of just pushing the necessary parameters, this method pushes values onto the stack not being used by the actual EAX call. This leads to generation of a function signature that is much harder to read than normal."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x436c4190>",
                    "type": "UnknownWord",
                    "value": "eax"
                },
                "references": {
                    "sentences": [
                        "DYN_BCryptEncrypt first resolves the API function BCryptEncrypt and stores the pointer to this function in register EAX. The function is then called via call EAX. Instead of just pushing the necessary parameters, this method pushes values onto the stack not being used by the actual EAX call. This leads to generation of a function signature that is much harder to read than normal."
                    ],
                    "titles": []
                }
            }
        ]
    },
    "other_links": [],
    "info": {
        "potential_threats": {
            "<UNKNOWNWORD_0x9e35c96c>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x9e35c96c>",
                    "type": "UnknownWord",
                    "value": "uncut"
                },
                "references": {
                    "sentences": [
                        "SophosLabs Uncut"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x1118b4d3>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x1118b4d3>",
                    "type": "UnknownWord",
                    "value": "tenacity"
                },
                "references": {
                    "sentences": [
                        "Emotet: Resurgence and Tenacity"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x8010afd5>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x8010afd5>",
                    "type": "UnknownWord",
                    "value": "ollvm"
                },
                "references": {
                    "sentences": [
                        "First, the body of the function is broken into basic blocks, and then the blocks are put next to each other on the same level. A visualization of this transformation can be seen in Figure 2. Control Flow Flattening can be combined with other obfuscation techniques, such as API Hashing or String Encryption. Some of the most prominent obfuscators for flattening functions are OLLVM and Tigress."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x885460cc>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x885460cc>",
                    "type": "UnknownWord",
                    "value": "tigress"
                },
                "references": {
                    "sentences": [
                        "First, the body of the function is broken into basic blocks, and then the blocks are put next to each other on the same level. A visualization of this transformation can be seen in Figure 2. Control Flow Flattening can be combined with other obfuscation techniques, such as API Hashing or String Encryption. Some of the most prominent obfuscators for flattening functions are OLLVM and Tigress."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x540cec0c>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x540cec0c>",
                    "type": "UnknownWord",
                    "value": "hello"
                },
                "references": {
                    "sentences": [
                        "Flattening Hello World"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x9053fc72>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x9053fc72>",
                    "type": "UnknownWord",
                    "value": "hex-rays"
                },
                "references": {
                    "sentences": [
                        "For demonstration purposes, weve compiled a simple program written in C. On the left side of Figure 3, an annotated control flow graph (CFG) of the binary is shown. On the right side you can see the decompiled output generated by the Hex-Rays Decompiler.",
                        "In this figure, no obfuscation techniques have been applied. The Hex-Rays Decompiler has no trouble generating an easy-to-read high-level language representation of the disassembly. Even without a decompiler, an experienced reverse engineer can simply follow the control flow graph to understand its purpose.",
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard",
                        "Instead of patching and operating on the disassembly directly, we make use of the Hex-Rays Microcode API. Microcode is an intermediate language used by the Hex-Rays decompiler. During decompilation, the decompiler steps through different maturity phases. The different phases are displayed in Figure 6 below. The API allows us to hook the decompilation progress and operate on the microcode instead of patching the disassembly directly."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x325bcbf3>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x325bcbf3>",
                    "type": "UnknownWord",
                    "value": "statevar"
                },
                "references": {
                    "sentences": [
                        "If we compare the decompiled output of Figure 3 and Figure 4, we can see multiple similarities, and we can identify the CFG dispatcher again. In the decompiled output, we see a variable we annotated as stateVar. Like the output in Figure 3, this is our state variable that is constantly updated and used by the dispatcher to determine which block is executed next.",
                        "The control flow is concealed. Instead of being able to follow the blocks, a control flow dispatcher block is implemented. This block determines which blocks are executed next.<crlf>A state variable annotated as stateVar in the decompiled output is updated with high entropy variables throughout the function. The state variable is used by the control flow dispatcher to decide which block gets executed next.<crlf>The two problems above lead to a highly complex decompiled output. While it is still possible to follow the execution flow, the time and effort needed to understand the function is significantly larger than it would be compared to the decompiled output in Figure 3."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x375dafd0>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x375dafd0>",
                    "type": "UnknownWord",
                    "value": "microcode"
                },
                "references": {
                    "sentences": [
                        "A flattened block might be implemented by multiple microcode blocks. To find the end of the region, the original algorithm by Rolf Rolles generates a dominator tree and uses the generated information to determine the end of a region, or the beginning of a cluster. In some cases, the algorithm failed to find the cluster head. We added an additional function to determine the cluster head as a fallback. We believe that the original algorithm by Rolf Rolles is more reliable; however, evaluation showed that the fallback algorithm still led to good results and improved the decompiled output.",
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard",
                        "Instead of patching and operating on the disassembly directly, we make use of the Hex-Rays Microcode API. Microcode is an intermediate language used by the Hex-Rays decompiler. During decompilation, the decompiler steps through different maturity phases. The different phases are displayed in Figure 6 below. The API allows us to hook the decompilation progress and operate on the microcode instead of patching the disassembly directly.",
                        "The algorithm to detect nested dispatchers is simple. Therefore, we have added an option to turn it on and off. In rare cases, a faulty output is generated if the nested dispatcher is enabled.<crlf>In many functions, we had to deal with conditional states. Depending on the outcome of, for example, a WINAPI function, the state variable changes to a different value at runtime. Additional patching and insertion of microcode instructions would be needed to unflatten these conditional blocks.<crlf>Our main approach was to add logic for reoccurring patterns in the binary. As our work progressed, we realized that a microcode emulator might have been a better choice, or would have been an adjustment that led to more unflattened blocks.<crlf>During development and evaluation, we experienced multiple crashes. We are all humans and we make mistakes, so some crashes will result from bugs in our code. However, judging from the error messages, we believe that there is a deeper-rooted problem in the Python port of the Microcode API. Therefore, we recommend saving often and keeping a copy of the IDB file.",
                        "Figure 6: IDA Microcode maturity levels",
                        "The IDAPython fork of Rolf Rolles HexRaysDeob tool was based on Python2.7. We updated several parts of the code to match Python3 standards.<crlf>In the original version of the tool, if the run function was invoked once, the plugin got activated and if the tool determined the function as flattened via an algorithm, it attempted to unflatten it. During implementation and testing, we experienced crashes of IDA Pro when using the IDAPython microcode API. This might lead to a corrupted IDB database. As an additional safety mechanism, the address of the target function must be added to the array white_list to allow unflattening. Overall, we recommend saving often and keeping a separate IDB copy when using the tool."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x350acc35>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x350acc35>",
                    "type": "UnknownWord",
                    "value": "rolles"
                },
                "references": {
                    "sentences": [
                        "A flattened block might be implemented by multiple microcode blocks. To find the end of the region, the original algorithm by Rolf Rolles generates a dominator tree and uses the generated information to determine the end of a region, or the beginning of a cluster. In some cases, the algorithm failed to find the cluster head. We added an additional function to determine the cluster head as a fallback. We believe that the original algorithm by Rolf Rolles is more reliable; however, evaluation showed that the fallback algorithm still led to good results and improved the decompiled output.",
                        "We used an IDAPython fork of the Rolf Rolles HexRaysDeob tool as our foundation. Like the fork, we are operating solely on the maturity level MMAT_LOCOPT, the third level in the figure above. As seen in Figure 6, that maturity level includes information about inbound and outbound blocks, which are necessary to correctly identify dispatcher blocks. Furthermore, the original code was based around the MMAT_LOCOPT layer. Changing the layer would have required plenty more investigation, verification, and adjustments of the existing code than keeping the layer. Below is a summarization of changes we applied on the existing code base.",
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard",
                        "The IDAPython fork of Rolf Rolles HexRaysDeob tool was based on Python2.7. We updated several parts of the code to match Python3 standards.<crlf>In the original version of the tool, if the run function was invoked once, the plugin got activated and if the tool determined the function as flattened via an algorithm, it attempted to unflatten it. During implementation and testing, we experienced crashes of IDA Pro when using the IDAPython microcode API. This might lead to a corrupted IDB database. As an additional safety mechanism, the address of the target function must be added to the array white_list to allow unflattening. Overall, we recommend saving often and keeping a separate IDB copy when using the tool."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xec3b977f>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xec3b977f>",
                    "type": "UnknownWord",
                    "value": "compiler-level"
                },
                "references": {
                    "sentences": [
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x3ac5036e>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x3ac5036e>",
                    "type": "UnknownWord",
                    "value": "ollvm-protected"
                },
                "references": {
                    "sentences": [
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x88f1154f>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x88f1154f>",
                    "type": "UnknownWord",
                    "value": "francis"
                },
                "references": {
                    "sentences": [
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xdc605ea2>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xdc605ea2>",
                    "type": "UnknownWord",
                    "value": "gabriel"
                },
                "references": {
                    "sentences": [
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x565dad30>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x565dad30>",
                    "type": "UnknownWord",
                    "value": "quarkslab"
                },
                "references": {
                    "sentences": [
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xf2f73ab2>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xf2f73ab2>",
                    "type": "UnknownWord",
                    "value": "eshard"
                },
                "references": {
                    "sentences": [
                        "Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles<crlf>Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWares Threat Analysis Unit<crlf>Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of Quarkslab<crlf>D810: A journey into control flow unflattening by Boris Batteaux of eShard"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xe84701a7>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xe84701a7>",
                    "type": "UnknownWord",
                    "value": "openscmanagera"
                },
                "references": {
                    "sentences": [
                        "First, the function calls OpenSCManagerA to retrieve a handle to the Service Control Manager. Next, it calls OpenServiceW to open an existing service. If opening the service succeeds, the opened service will be deleted via DeleteService. Finally, the opened handles will be closed. If the service was deleted successfully, the function returns 1, otherwise 0."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x6b0633f4>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x6b0633f4>",
                    "type": "UnknownWord",
                    "value": "openservicew"
                },
                "references": {
                    "sentences": [
                        "First, the function calls OpenSCManagerA to retrieve a handle to the Service Control Manager. Next, it calls OpenServiceW to open an existing service. If opening the service succeeds, the opened service will be deleted via DeleteService. Finally, the opened handles will be closed. If the service was deleted successfully, the function returns 1, otherwise 0."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x77b8a205>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x77b8a205>",
                    "type": "UnknownWord",
                    "value": "deleteservice"
                },
                "references": {
                    "sentences": [
                        "First, the function calls OpenSCManagerA to retrieve a handle to the Service Control Manager. Next, it calls OpenServiceW to open an existing service. If opening the service succeeds, the opened service will be deleted via DeleteService. Finally, the opened handles will be closed. If the service was deleted successfully, the function returns 1, otherwise 0."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x89395974>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x89395974>",
                    "type": "UnknownWord",
                    "value": "hexraysdeob"
                },
                "references": {
                    "sentences": [
                        "The IDAPython fork of Rolf Rolles HexRaysDeob tool was based on Python2.7. We updated several parts of the code to match Python3 standards.<crlf>In the original version of the tool, if the run function was invoked once, the plugin got activated and if the tool determined the function as flattened via an algorithm, it attempted to unflatten it. During implementation and testing, we experienced crashes of IDA Pro when using the IDAPython microcode API. This might lead to a corrupted IDB database. As an additional safety mechanism, the address of the target function must be added to the array white_list to allow unflattening. Overall, we recommend saving often and keeping a separate IDB copy when using the tool.",
                        "We used an IDAPython fork of the Rolf Rolles HexRaysDeob tool as our foundation. Like the fork, we are operating solely on the maturity level MMAT_LOCOPT, the third level in the figure above. As seen in Figure 6, that maturity level includes information about inbound and outbound blocks, which are necessary to correctly identify dispatcher blocks. Furthermore, the original code was based around the MMAT_LOCOPT layer. Changing the layer would have required plenty more investigation, verification, and adjustments of the existing code than keeping the layer. Below is a summarization of changes we applied on the existing code base."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xda33937e>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xda33937e>",
                    "type": "UnknownWord",
                    "value": "mmat_locopt"
                },
                "references": {
                    "sentences": [
                        "We used an IDAPython fork of the Rolf Rolles HexRaysDeob tool as our foundation. Like the fork, we are operating solely on the maturity level MMAT_LOCOPT, the third level in the figure above. As seen in Figure 6, that maturity level includes information about inbound and outbound blocks, which are necessary to correctly identify dispatcher blocks. Furthermore, the original code was based around the MMAT_LOCOPT layer. Changing the layer would have required plenty more investigation, verification, and adjustments of the existing code than keeping the layer. Below is a summarization of changes we applied on the existing code base."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xc2eddf26>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xc2eddf26>",
                    "type": "UnknownWord",
                    "value": "run_mltpl_dispatchers"
                },
                "references": {
                    "sentences": [
                        "In multiple functions, running the deobfuscation algorithm on a single dispatcher did not generate an output we were satisfied with. Analysis showed that more complex functions might contain multiple nested dispatchers instead of one. We added additional logic to identify and run the algorithm on multiple dispatchers. This option can be turned on or off by setting the RUN_MLTPL_DISPATCHERS flag to True or False. In Figure 7 below, you can see an example of a function with two potential dispatchers."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x736fa90b>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x736fa90b>",
                    "type": "UnknownWord",
                    "value": "python3"
                },
                "references": {
                    "sentences": [
                        "The IDAPython fork of Rolf Rolles HexRaysDeob tool was based on Python2.7. We updated several parts of the code to match Python3 standards.<crlf>In the original version of the tool, if the run function was invoked once, the plugin got activated and if the tool determined the function as flattened via an algorithm, it attempted to unflatten it. During implementation and testing, we experienced crashes of IDA Pro when using the IDAPython microcode API. This might lead to a corrupted IDB database. As an additional safety mechanism, the address of the target function must be added to the array white_list to allow unflattening. Overall, we recommend saving often and keeping a separate IDB copy when using the tool."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xeb14ec3e>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xeb14ec3e>",
                    "type": "UnknownWord",
                    "value": "cff-unpacking"
                },
                "references": {
                    "sentences": [
                        "Our unflattening tool is now available on the SophosLabs Github. (For those interested in such things, we also recommend to your attention a CFF-unpacking tool released by ESET several years back to address control-flow flattening in the Stantinko botnet another example of why, since attackers freely share tactics, techniques, and procedures among themselves, defenders are wise to do the same.)"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x7a86d374>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x7a86d374>",
                    "type": "UnknownWord",
                    "value": "winapi"
                },
                "references": {
                    "sentences": [
                        "The algorithm to detect nested dispatchers is simple. Therefore, we have added an option to turn it on and off. In rare cases, a faulty output is generated if the nested dispatcher is enabled.<crlf>In many functions, we had to deal with conditional states. Depending on the outcome of, for example, a WINAPI function, the state variable changes to a different value at runtime. Additional patching and insertion of microcode instructions would be needed to unflatten these conditional blocks.<crlf>Our main approach was to add logic for reoccurring patterns in the binary. As our work progressed, we realized that a microcode emulator might have been a better choice, or would have been an adjustment that led to more unflattened blocks.<crlf>During development and evaluation, we experienced multiple crashes. We are all humans and we make mistakes, so some crashes will result from bugs in our code. However, judging from the error messages, we believe that there is a deeper-rooted problem in the Python port of the Microcode API. Therefore, we recommend saving often and keeping a copy of the IDB file."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x59087011>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x59087011>",
                    "type": "UnknownWord",
                    "value": "decryptstring"
                },
                "references": {
                    "sentences": [
                        "Figure 9: Cross references of DecryptString function with corresponding decrypted string"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x219b67fd>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x219b67fd>",
                    "type": "UnknownWord",
                    "value": "apihash"
                },
                "references": {
                    "sentences": [
                        "Figure 10: Disassembly of ApiHash function invocation"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x7a07850f>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x7a07850f>",
                    "type": "UnknownWord",
                    "value": "dyn_bcryptencrypt"
                },
                "references": {
                    "sentences": [
                        "Figure 12: Multiple values being pushed onto the stack before DYN_BCryptEncrypt is invoked",
                        "DYN_BCryptEncrypt first resolves the API function BCryptEncrypt and stores the pointer to this function in register EAX. The function is then called via call EAX. Instead of just pushing the necessary parameters, this method pushes values onto the stack not being used by the actual EAX call. This leads to generation of a function signature that is much harder to read than normal.",
                        "Another interesting technique that confuses the IDA decompiler is the way in which Emotet passes parameters to functions. In Figure 12 below, we show how DYN_BCryptEncrypt is invoked."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x8e605a55>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x8e605a55>",
                    "type": "UnknownWord",
                    "value": "bcryptencrypt"
                },
                "references": {
                    "sentences": [
                        "DYN_BCryptEncrypt first resolves the API function BCryptEncrypt and stores the pointer to this function in register EAX. The function is then called via call EAX. Instead of just pushing the necessary parameters, this method pushes values onto the stack not being used by the actual EAX call. This leads to generation of a function signature that is much harder to read than normal."
                    ],
                    "titles": []
                }
            }
        },
        "sigma": false,
        "yara": false
    },
    "keywords": {
        "classified": [],
        "dubbed": [],
        "associated": [],
        "targets": [
            "Control Flow Flattening used in conjunction with other obfuscation techniques certainly complicates the process of reverse engineering Emotet, but the technique weve described helps to even the odds against researchers examining this high-profile malware"
        ],
        "attributed": []
    },
    "resources": {
        "links": {
            "github": [
                "https://github.com/obfuscator-llvm/obfuscator/wiki",
                "https://github.com/sophoslabs/emotet_unflatten_poc",
                "https://github.com/eset/stadeo"
            ],
            "pastebin": [],
            "text_files": [],
            "other": [
                "https://news.sophos.com/en-us/author/andreas-klopsch/",
                "https://news.sophos.com/en-us/2022/05/04/attacking-emotets-control-flow-flattening/",
                "https://news.sophos.com/en-us/category/threat-research/sophoslabs-uncut/",
                "https://news.sophos.com/en-us/tag/emotet/",
                "https://news.sophos.com/en-us/tag/obfuscation/",
                "https://news.sophos.com/en-us/tag/secops/",
                "http://tigress.cs.arizona.edu/",
                "https://hex-rays.com/blog/hex-rays-microcode-api-vs-obfuscating-compiler/",
                "https://blogs.vmware.com/security/2019/02/defeating-compiler-level-obfuscations-used-in-apt10-malware.html",
                "https://blog.quarkslab.com/deobfuscation-recovering-an-ollvm-protected-program.html",
                "https://eshard.com/posts/D810-a-journey-into-control-flow-unflattening",
                "http://www.facebook.com/share.php?u=https://news.sophos.com/?p=84215&title=Attacking%20Emotet%E2%80%99s%20Control%20Flow%20Flattening",
                "http://twitter.com/intent/tweet?text=Attacking%20Emotet%E2%80%99s%20Control%20Flow%20Flattening%20https%3A%2F%2Fnews.sophos.com%2F%3Fp%3D84215",
                "http://www.linkedin.com/shareArticle?mini=true&url=https://news.sophos.com/en-us/2022/05/04/attacking-emotets-control-flow-flattening/"
            ]
        },
        "images": [
            "https://news.sophos.com/wp-content/uploads/2022/04/PIcture1-1a.png",
            "https://news.sophos.com/wp-content/uploads/2022/04/Picture2-1.png",
            "https://news.sophos.com/wp-content/uploads/2022/04/Picture3-1.png",
            "https://news.sophos.com/wp-content/uploads/2022/04/Picture4-1.png",
            "https://news.sophos.com/wp-content/uploads/2022/04/Picture5-1.png",
            "https://news.sophos.com/wp-content/uploads/2022/04/Picture6.png",
            "https://news.sophos.com/wp-content/uploads/2022/04/Picture7.png",
            "https://news.sophos.com/wp-content/uploads/2022/04/Picture8.png",
            "https://news.sophos.com/wp-content/uploads/2022/04/shutterstock_105181163.jpg?w=1000",
            "https://news.sophos.com/wp-content/uploads/2021/05/Category-Icon-Threat-Research@2x.min_.png",
            "https://news.sophos.com/wp-content/uploads/2022/04/Picture9.png",
            "https://news.sophos.com/wp-content/uploads/2022/04/Picture10.png",
            "https://news.sophos.com/wp-content/uploads/2022/04/Picture11.png",
            "https://news.sophos.com/wp-content/uploads/2022/04/Picture12.png",
            "https://news.sophos.com/wp-content/uploads/2022/04/Picture13.png"
        ]
    }
}