{
    "title": "Rook Ransomware. Static Code Analysis",
    "url": "https://chuongdong.com/reverse%20engineering/2022/01/06/RookRansomware",
    "threats": {
        "Threat": [
            {
                "token": {
                    "id": "<THREAT_0x5bed30a9>",
                    "type": "Threat",
                    "value": "rook"
                },
                "references": {
                    "sentences": [
                        "If the drive type is a remote drive, ROOK calls WNetGetConnectionW to retrieve the remote name of the drive and passes it to be traversed by the recursive_traverse_dir function.",
                        "For stopping services, ROOK borrows this part from the leaked BABUK source code.",
                        "If ROOK is unable to open the file prior to encryption, the malware attempts to terminate the file owners process.",
                        "Prior to encrypting files, ROOK sets up its own multithreading system.",
                        "Next, it calls mbedtls_pk_parse_public_key to parse the TAs RSA public key into a mbedtls_pk_context struct. The ROOKs public key context is then extracted from the pk_ctx field on the newly populated mbedtls_pk_context struct.",
                        "Next, ROOK encrypts the victims RSA private key using its own public key context.",
                        "This is my analysis for ROOK Ransomware.",
                        "After terminating all processes that are using the file, ROOK passes it back in to be encrypted.",
                        "When traversing a drive, ROOK builds the following drive path.",
                        "ROOK first checks if its process is running under a 64-bit processor by calling IsWow64Process.",
                        "ROOK can run with or without command-line arguments.",
                        "After stopping all dependent services, ROOK calls ControlService send a control stop code to the main service and continuosly checks until the service is fully stopped.",
                        "However, unlike BABUK devs who are big fans of using ECDH curves and eSTREAM portfolio Profile 1 ciphers such as ChaCha and HC-128 for hybrid-encryption, ROOK devs stick with the traditional choice of RSA and AES.",
                        "Prior to file encryption, ROOK calls SetFileAttributesW to set the file attribute to normal.",
                        "It builds the following path **.Rook\"** and calls **MoveFileExW** to change the file name to have the encrypted extension **.Rook**.",
                        "ROOK then calls CreateThread to spawn threads for double the number of processors for each thread array. The functionalities of these threads are later discussed in the Child Thread section.",
                        "Then, the function begins enumerating the directory for all its sub-directories. ROOK builds the path **\\\\\\*\"** and passes it to **FindFirstFileW** to start the enumeration.",
                        "The argument can come in the form of a list of paths, each separated by a comma. Instead of a normal directory path, ROOK also accepts a two-character string of a drive letter followed by a colon as a path to a drive.",
                        "For each found file, ROOK checks to make sure its name is not in the files and directories to avoid list and is not HowToRestoreYourFiles.txt.",
                        "Instead of just looping and waiting for the directory list to be cleared, ROOK extracts and encrypts files in the global file list during the wait time to increase efficiency and avoids wasting computing resources. This makes the overall enumeration and encryption process quite fast.",
                        "While waiting for that, ROOK efficiently waits to retrieve access to the global file list, extract a file, and encrypts it similar to the previous nested while loop.",
                        "Figure 3: ROOKs Ransom Note.",
                        "For the enumeration, ROOK first builds a path to a ransom note file in the directory, calls CreateFileW to create it and WriteFile to write the ransom note content to it.",
                        "Next, ROOK calls FindFirstVolumeW and FindNextVolumeW to scan for available volumes in the system. For each volume, the malware calls GetVolumePathNamesForVolumeNameW to retrieve the volume GUID path and SetVolumeMountPointW to set the path as the root path for the next no-root drive in the list.",
                        "After getting access to the file list, ROOK calls EnterCriticalSection to obtain the ownership of the file lists critical section and<crlf>adds the subfile to the list.",
                        "If the command-line argument -paths is not provided, ROOK manually mounts all drives that have no volume mounted and traverses through all of them.",
                        "Then, ROOK checks to make sure the application is not its own ransomware process through the process IDs. Finally, it calls OpenProcess to retrieve the processs handle and terminate it using TerminateProcess.",
                        "Rook Ransomware Contents Overview IOCS Ransom Note<crlf>Contents<crlf>Overview<crlf>IOCS<crlf>Ransom Note<crlf>Static Code Analysis RSA Key Generation Anti-Detection: Alternate Data Streams Command-line Arguments Logging Stopping Services Terminating Processes Deleting Shadow Copies Multithreading Setup Network Resource Traversal Drives Traversal Shares Traversal Child Thread File Encryption References<crlf>RSA Key Generation<crlf>Anti-Detection: Alternate Data Streams<crlf>Command-line Arguments<crlf>Logging<crlf>Stopping Services<crlf>Terminating Processes<crlf>Deleting Shadow Copies<crlf>Multithreading Setup<crlf>Network Resource Traversal<crlf>Drives Traversal<crlf>Shares Traversal<crlf>Child Thread<crlf>File Encryption<crlf>References",
                        "ROOK then calls RegCreateKeyExW to open the subkey Software in HKEY_CURRENT_USER. Using that, it calls RegQueryValueExW to check if the registry value RookPublicKey exists in there. If it does not, the malware generates a public-private key pair for the victim.",
                        "ROOK is a relatively new ransomware that has been coming up in the last few months. With the Mbed TLS library, the malware uses a hybrid cryptography scheme to encrypt files using AES and protect its keys with RSA-2048.",
                        "ROOK also skips the file if its extension is .exe, .dll, or .Rook. After checking, the malware enters a nested while loop to wait until no thread can add to the global file list and extracts files to encrypt during the wait time.",
                        "In the recursive_traverse_dir function, ROOK begins by executing two nested while loop. The first one loops and waits until the END_ACCESS_DIR_SEMAPHORE semaphores count is reduced to zero, and its state is nonsignaled. When this happens, it means every directory in the global directory list is already traversed and no thread is extracting from it.",
                        "As it has been claimed by other researchers, ROOK borrows some of the code from the leaked BABUK source code. To be more specific, the ROOK developers copied and pasted the code for services & processes termination as well as deleting shadow copies. ROOKs multithreading approach is a reimplementation and an upgrade from that of BABUK version 3, which is now more efficient for directory traversal.",
                        "If it is not, ROOK calls EnumDependentServicesA to enumerate through all dependent services of the target service and stop them.",
                        "For execution speed, ROOK is quite fast since it uses a decently good method of multithreading with two global lists for file and directory traversal.",
                        "To test this, I use two copies of the ROOK sample and have the ro0k.mal_ one hide itself in the :ask data stream. As we can see in the command-line, that file shows up empty, but its alternate data stream contains the full malicious executable.",
                        "The first thing ROOK does upon execution is setting up the RSA keys for asymmetric encryption.",
                        "Next, ROOK populates the following structures for the file footer.",
                        "The content of the default ransom note is stored in plaintext in ROOKs executable.",
                        "To evade detection, ROOK uses ADS to hides its own executable. First, it calls GetModuleFileNameW with a NULL handle to retrieve its own executable path.",
                        "Figure 1: ROOK Leak Site.",
                        "While waiting for this, the inner while loop waits until the BEGIN_ACCESS_FILE_SEMAPHORE semaphore is signaled, which allows the current process to access the global file list. After obtaining the ownership of the critical section for the global file list using EnterCriticalSection, ROOK extracts the file at the current index, increments the index, and encrypts it. The file encryption routine is later discussed at the File Encryption section.",
                        "After hiding itself, ROOK also calls SetFileInformationByHandle again to set the file to be deleted once all handles are closed at the end.",
                        "Next, it copies the victims private key that is encrypted using ROOKs public key during RSA Key Generation into the metadatas my_private_key_encrypted_by_Rook_public field.",
                        "ROOKs ransom note filename is HowToRestoreYourFiles.txt, which is really similar to BABUKs How To Restore Your Files.txt.",
                        "When the command-line argument -paths is provided, ROOK specifically enumerates them and exits upon completion.",
                        "For each network resource, if its a container for other resources that can also be enumerated, ROOK recursively passes it back to the current function to traverse it.",
                        "When the command-line argument -paths or -shares is not provided, ROOK recursively traverses through all resources in the network.",
                        "Figure 5: Parsing ROOKs RSA Public Key.",
                        "ROOK calls CreateToolhelp32Snapshot to retrieve a snapshot of all processes and threads in the system. It then calls Process32FirstW and Process32NextW to enumerate through the snapshot.",
                        "When the debug argument is provided on the command-line, ROOK enables debugging and calls CreateFileW to create the log file to later log into."
                    ],
                    "titles": [
                        "Logging",
                        "Overview",
                        "File Encryption",
                        "Deleting Shadow Copies",
                        "Child Thread",
                        "Terminating Processes",
                        "Ransom Note",
                        "Contents",
                        "Network Resource Traversal",
                        "RSA Key Generation",
                        "Multithreading Setup",
                        "Rook Ransomware",
                        "Rook Ransomware. Static Code Analysis",
                        "Anti-Detection: Alternate Data Streams",
                        "Drives Traversal",
                        "Command-line Arguments",
                        "Stopping Services"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xa179f90c>",
                            "type": "Category",
                            "value": "ransomware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xfda51682>",
                            "type": "Category",
                            "value": "scan"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x6f721f35>",
                            "type": "Threat",
                            "value": "babuk"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xeb497dc6>",
                            "type": "File",
                            "value": "files.txt"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xb8653f1>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "c2d46d256b8f9490c9599eea11ecef19fde7d4fdd2dea93604cee3cea8e172ac"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        }
                    },
                    {
                        "src": {
                            "id": "<MD5_0x2b7e565e>",
                            "type": "Hash",
                            "hash_type": "MD5",
                            "value": "6d87be9212a1a0e92e58e1ed94c589f9"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0xda2b93b2>",
                            "type": "Threat",
                            "value": "maze"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xad870dc6>",
                            "type": "File",
                            "value": "howtorestoreyourfiles.txt"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x6f721f35>",
                            "type": "Threat",
                            "value": "babuk"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<THREAT_0x6f721f35>",
                    "type": "Threat",
                    "value": "babuk"
                },
                "references": {
                    "sentences": [
                        "For stopping services, ROOK borrows this part from the leaked BABUK source code.",
                        "However, unlike BABUK devs who are big fans of using ECDH curves and eSTREAM portfolio Profile 1 ciphers such as ChaCha and HC-128 for hybrid-encryption, ROOK devs stick with the traditional choice of RSA and AES.",
                        "ROOKs ransom note filename is HowToRestoreYourFiles.txt, which is really similar to BABUKs How To Restore Your Files.txt.",
                        "This part of code is also copied and pasted from the BABUK source code.",
                        "As it has been claimed by other researchers, ROOK borrows some of the code from the leaked BABUK source code. To be more specific, the ROOK developers copied and pasted the code for services & processes termination as well as deleting shadow copies. ROOKs multithreading approach is a reimplementation and an upgrade from that of BABUK version 3, which is now more efficient for directory traversal."
                    ],
                    "titles": [
                        "Overview",
                        "Deleting Shadow Copies",
                        "Ransom Note",
                        "Terminating Processes",
                        "Stopping Services"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xeb497dc6>",
                            "type": "File",
                            "value": "files.txt"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x6f721f35>",
                            "type": "Threat",
                            "value": "babuk"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x6f721f35>",
                            "type": "Threat",
                            "value": "babuk"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x6f721f35>",
                            "type": "Threat",
                            "value": "babuk"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xda2b93b2>",
                            "type": "Threat",
                            "value": "maze"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xad870dc6>",
                            "type": "File",
                            "value": "howtorestoreyourfiles.txt"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x6f721f35>",
                            "type": "Threat",
                            "value": "babuk"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x6f721f35>",
                            "type": "Threat",
                            "value": "babuk"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<THREAT_0xda2b93b2>",
                    "type": "Threat",
                    "value": "maze"
                },
                "references": {
                    "sentences": [
                        "However, unlike BABUK devs who are big fans of using ECDH curves and eSTREAM portfolio Profile 1 ciphers such as ChaCha and HC-128 for hybrid-encryption, ROOK devs stick with the traditional choice of RSA and AES."
                    ],
                    "titles": [
                        "Overview"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<THREAT_0xda2b93b2>",
                            "type": "Threat",
                            "value": "maze"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x6f721f35>",
                            "type": "Threat",
                            "value": "babuk"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xda2b93b2>",
                            "type": "Threat",
                            "value": "maze"
                        }
                    }
                ]
            }
        ]
    },
    "ttps": {},
    "meanings": {
        "Category": [
            {
                "token": {
                    "id": "<CATEGORY_0xa179f90c>",
                    "type": "Category",
                    "value": "ransomware"
                },
                "references": {
                    "sentences": [
                        "Then, ROOK checks to make sure the application is not its own ransomware process through the process IDs. Finally, it calls OpenProcess to retrieve the processs handle and terminate it using TerminateProcess.",
                        "Rook Ransomware Contents Overview IOCS Ransom Note<crlf>Contents<crlf>Overview<crlf>IOCS<crlf>Ransom Note<crlf>Static Code Analysis RSA Key Generation Anti-Detection: Alternate Data Streams Command-line Arguments Logging Stopping Services Terminating Processes Deleting Shadow Copies Multithreading Setup Network Resource Traversal Drives Traversal Shares Traversal Child Thread File Encryption References<crlf>RSA Key Generation<crlf>Anti-Detection: Alternate Data Streams<crlf>Command-line Arguments<crlf>Logging<crlf>Stopping Services<crlf>Terminating Processes<crlf>Deleting Shadow Copies<crlf>Multithreading Setup<crlf>Network Resource Traversal<crlf>Drives Traversal<crlf>Shares Traversal<crlf>Child Thread<crlf>File Encryption<crlf>References",
                        "ROOK is a relatively new ransomware that has been coming up in the last few months. With the Mbed TLS library, the malware uses a hybrid cryptography scheme to encrypt files using AES and protect its keys with RSA-2048.",
                        "This is my analysis for ROOK Ransomware.",
                        "After doing this, the ransomware file will appear as empty in the file system until the end of execution."
                    ],
                    "titles": [
                        "Overview",
                        "File Encryption",
                        "Contents",
                        "Rook Ransomware",
                        "Rook Ransomware. Static Code Analysis",
                        "Anti-Detection: Alternate Data Streams"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0xa179f90c>",
                            "type": "Category",
                            "value": "ransomware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0xf1a480bb>",
                    "type": "Category",
                    "value": "malware"
                },
                "references": {
                    "sentences": [
                        "Next, it iterates through a hard-coded list containing services to be stopped. For each of these service, the malware calls OpenServiceA to retrieve the services handle and QueryServiceStatusEx to query and checks if the service state is SERVICE_STOP_PENDING.",
                        "If ROOK is unable to open the file prior to encryption, the malware attempts to terminate the file owners process.",
                        "Finally, the malware calls GetLogicalDrives to iterate through all the drives in the system and traverse them.",
                        "After the directory list is full, the malware obtains ownership of the lists critical section, extracts a directory out, and begins traversing it for sub-files.",
                        "Finally, the malware calls mbedtls_pk_parse_public_key to retrieve the victims public key context and wipes the victims raw private key from memory.",
                        "For each dependent service, the malware calls OpenServiceA to retrieve its handle and ControlService to send a control stop code to stop it. It also sleeps and calls QueryServiceStatusEx to wait until the services state is fully stopped.",
                        "For each sub-directory found, the malware checks if the filename is not in the list of files and directories to avoid. If its not, the sub-directory full path is constructed and passed back to recursive_traverse_dir to be recursively traversed.",
                        "Using that session handle, the malware calls RmRegisterResources to register the target file as a resource to the RM.",
                        "If the victims public key was already generated before and the malware can query it directly from registry, the victims encrypted private key is pulled from the registry value RookPrivateKey.",
                        "Next, the malware calls HeapAlloc to allocate two arrays to store child thread handles, one for file encryption and the other for directory enumeration.",
                        "If the drive type is not remote drive and CD-ROM drive, the malware simply passes it to the recursive_traverse_dir function.",
                        "Next, the malware calls EnterCriticalSection to obtain the ownership of the global directory list and adds the directory path to be traversed in. Then, it calls ReleaseSemaphore to release the BEGIN_ACCESS_DIR_SEMAPHORE semaphore, which increments its count by one and signals other threads that another directory is available to be enumerated.",
                        "First, the malware initializes a CTR_DRBG context using the Mbed TLS library, which is used to build a pseudo-RNG to later randomly generate AES keys.",
                        "With the path, the malware checks and avoids enumerating the drive if its a CD-ROM drive.",
                        "Next, ROOK calls FindFirstVolumeW and FindNextVolumeW to scan for available volumes in the system. For each volume, the malware calls GetVolumePathNamesForVolumeNameW to retrieve the volume GUID path and SetVolumeMountPointW to set the path as the root path for the next no-root drive in the list.",
                        "For each process whose name is in the list of processes to be terminated, the malware calls OpenProcess to retrieve the processs handle and TerminateProcess to terminate it.",
                        "Sample: MalwareBazaar",
                        "The malware begins by calling GetFileSizeEx to retrieve the size of the file and store it in the file footer. It then uses the victims RSA public key to encrypt the AES key and store it in the metadatas AES_key_encrypted_by_my_public field.",
                        "The malware first calls GetTickCount to get a tick count prior to stopping services. It then calls OpenSCManagerA to retrieve a service control manager handle.",
                        "ROOK then calls RegCreateKeyExW to open the subkey Software in HKEY_CURRENT_USER. Using that, it calls RegQueryValueExW to check if the registry value RookPublicKey exists in there. If it does not, the malware generates a public-private key pair for the victim.",
                        "ROOK is a relatively new ransomware that has been coming up in the last few months. With the Mbed TLS library, the malware uses a hybrid cryptography scheme to encrypt files using AES and protect its keys with RSA-2048.",
                        "ROOK also skips the file if its extension is .exe, .dll, or .Rook. After checking, the malware enters a nested while loop to wait until no thread can add to the global file list and extracts files to encrypt during the wait time.",
                        "For directory enumeration, the malware calculates the maximum number of directories to be enumerated by multiple threads at the same time is 6 times the number of processors. It also creates a global array, 2 semaphores, and a critical section like to the file encryption part above.",
                        "If it is, the malware calls Wow64DisableWow64FsRedirection to disable file system redirection for its process.",
                        "If the file size is greater than 0x80000 bytes, the malware reads and encrypts at most three 0x80000-byte chunks at the beginning of the file using AES-128 ECB.",
                        "To test this, I use two copies of the ROOK sample and have the ro0k.mal_ one hide itself in the :ask data stream. As we can see in the command-line, that file shows up empty, but its alternate data stream contains the full malicious executable.",
                        "The malware calls WNetOpenEnumW to retrieve an enumeration handle for all network resources and WNetEnumResourceW to enumerate through them.",
                        "If the resource is just a normal and connectable directory, the malware passes it into a recursive function to traverse it, which will be discussed in the Drives Traversal section.",
                        "For stopping all services, the maximum timeout is 30000ms or 30 seconds from the original tick count. If it takes more than 30 seconds to stop services, the malware aborts and exits the function.",
                        "Next, the malware calls CreateFileW to retrieve the file handle for the target and begins the encryption.",
                        "For file encryption, the malware calculates the maximum number of files to be encrypted by multiple threads at the same time is 24 times the number of processors. It then calls HeapAlloc to allocate a global array to store the files that are set to be encrypted and CreateSemaphoreA to create 2 semaphores that are used for synchronization among threads that access the file array. Finally, it also calls<crlf>InitializeCriticalSection to initialize a critical section that allows one thread to add or remove a file from the global array at a time.",
                        "Finally, if the malwares process is running under a 64-bit architecture, it calls Wow64RevertWow64FsRedirection to enable file system redirection."
                    ],
                    "titles": [
                        "IOCS",
                        "Overview",
                        "File Encryption",
                        "Deleting Shadow Copies",
                        "Child Thread",
                        "Terminating Processes",
                        "Network Resource Traversal",
                        "RSA Key Generation",
                        "Multithreading Setup",
                        "Anti-Detection: Alternate Data Streams",
                        "Drives Traversal",
                        "Stopping Services"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0xb68aa214>",
                    "type": "Category",
                    "value": "rat"
                },
                "references": {
                    "sentences": [
                        "Then it executes ShellExecuteW to launch the following command in the command line to delete all shadow copies in the system."
                    ],
                    "titles": [
                        "Deleting Shadow Copies"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0xfda51682>",
                    "type": "Category",
                    "value": "scan"
                },
                "references": {
                    "sentences": [
                        "Next, ROOK calls FindFirstVolumeW and FindNextVolumeW to scan for available volumes in the system. For each volume, the malware calls GetVolumePathNamesForVolumeNameW to retrieve the volume GUID path and SetVolumeMountPointW to set the path as the root path for the next no-root drive in the list."
                    ],
                    "titles": [
                        "Drives Traversal"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0xfda51682>",
                            "type": "Category",
                            "value": "scan"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        }
                    }
                ]
            }
        ]
    },
    "iocs": {
        "Hash": [
            {
                "token": {
                    "id": "<MD5_0x2b7e565e>",
                    "type": "Hash",
                    "hash_type": "MD5",
                    "value": "6d87be9212a1a0e92e58e1ed94c589f9"
                },
                "references": {
                    "sentences": [
                        "MD5: 6d87be9212a1a0e92e58e1ed94c589f9"
                    ],
                    "titles": [
                        "IOCS"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<MD5_0x2b7e565e>",
                            "type": "Hash",
                            "hash_type": "MD5",
                            "value": "6d87be9212a1a0e92e58e1ed94c589f9"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0xb8653f1>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "c2d46d256b8f9490c9599eea11ecef19fde7d4fdd2dea93604cee3cea8e172ac"
                },
                "references": {
                    "sentences": [
                        "SHA256: c2d46d256b8f9490c9599eea11ecef19fde7d4fdd2dea93604cee3cea8e172ac"
                    ],
                    "titles": [
                        "IOCS"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xb8653f1>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "c2d46d256b8f9490c9599eea11ecef19fde7d4fdd2dea93604cee3cea8e172ac"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        }
                    }
                ]
            }
        ],
        "File": [
            {
                "token": {
                    "id": "<FILE_0xad870dc6>",
                    "type": "File",
                    "value": "howtorestoreyourfiles.txt"
                },
                "references": {
                    "sentences": [
                        "For each found file, ROOK checks to make sure its name is not in the files and directories to avoid list and is not HowToRestoreYourFiles.txt.",
                        "ROOKs ransom note filename is HowToRestoreYourFiles.txt, which is really similar to BABUKs How To Restore Your Files.txt."
                    ],
                    "titles": [
                        "Child Thread",
                        "Ransom Note"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xad870dc6>",
                            "type": "File",
                            "value": "howtorestoreyourfiles.txt"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xad870dc6>",
                            "type": "File",
                            "value": "howtorestoreyourfiles.txt"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbe58df53>",
                            "type": "UnknownWord",
                            "value": "restore"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xad870dc6>",
                            "type": "File",
                            "value": "howtorestoreyourfiles.txt"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x6f721f35>",
                            "type": "Threat",
                            "value": "babuk"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0xeb497dc6>",
                    "type": "File",
                    "value": "files.txt"
                },
                "references": {
                    "sentences": [
                        "ROOKs ransom note filename is HowToRestoreYourFiles.txt, which is really similar to BABUKs How To Restore Your Files.txt."
                    ],
                    "titles": [
                        "Ransom Note"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xeb497dc6>",
                            "type": "File",
                            "value": "files.txt"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x5bed30a9>",
                            "type": "Threat",
                            "value": "rook"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xeb497dc6>",
                            "type": "File",
                            "value": "files.txt"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbe58df53>",
                            "type": "UnknownWord",
                            "value": "restore"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xeb497dc6>",
                            "type": "File",
                            "value": "files.txt"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x6f721f35>",
                            "type": "Threat",
                            "value": "babuk"
                        }
                    }
                ]
            }
        ]
    },
    "unknownwords": {
        "UnknownWord": [
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4180fd73>",
                    "type": "UnknownWord",
                    "value": "anti-detection"
                },
                "references": {
                    "sentences": [
                        "Rook Ransomware Contents Overview IOCS Ransom Note<crlf>Contents<crlf>Overview<crlf>IOCS<crlf>Ransom Note<crlf>Static Code Analysis RSA Key Generation Anti-Detection: Alternate Data Streams Command-line Arguments Logging Stopping Services Terminating Processes Deleting Shadow Copies Multithreading Setup Network Resource Traversal Drives Traversal Shares Traversal Child Thread File Encryption References<crlf>RSA Key Generation<crlf>Anti-Detection: Alternate Data Streams<crlf>Command-line Arguments<crlf>Logging<crlf>Stopping Services<crlf>Terminating Processes<crlf>Deleting Shadow Copies<crlf>Multithreading Setup<crlf>Network Resource Traversal<crlf>Drives Traversal<crlf>Shares Traversal<crlf>Child Thread<crlf>File Encryption<crlf>References"
                    ],
                    "titles": [
                        "Anti-Detection: Alternate Data Streams"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x752fa3b2>",
                    "type": "UnknownWord",
                    "value": "streams"
                },
                "references": {
                    "sentences": [
                        "Because alternate data streams are hidden from Windows Explorer and the dir command on the command-line, they are a sneaky way to hide external executable from a seemingly harmless file.",
                        "Alternate Data Streams (ADS) is a file attribute on the NT File System (NTFS) which was designed for compatibility with Macintosh Hierarchical File System (HFS).",
                        "Rook Ransomware Contents Overview IOCS Ransom Note<crlf>Contents<crlf>Overview<crlf>IOCS<crlf>Ransom Note<crlf>Static Code Analysis RSA Key Generation Anti-Detection: Alternate Data Streams Command-line Arguments Logging Stopping Services Terminating Processes Deleting Shadow Copies Multithreading Setup Network Resource Traversal Drives Traversal Shares Traversal Child Thread File Encryption References<crlf>RSA Key Generation<crlf>Anti-Detection: Alternate Data Streams<crlf>Command-line Arguments<crlf>Logging<crlf>Stopping Services<crlf>Terminating Processes<crlf>Deleting Shadow Copies<crlf>Multithreading Setup<crlf>Network Resource Traversal<crlf>Drives Traversal<crlf>Shares Traversal<crlf>Child Thread<crlf>File Encryption<crlf>References"
                    ],
                    "titles": [
                        "Anti-Detection: Alternate Data Streams"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf237f470>",
                    "type": "UnknownWord",
                    "value": "shadow"
                },
                "references": {
                    "sentences": [
                        "As it has been claimed by other researchers, ROOK borrows some of the code from the leaked BABUK source code. To be more specific, the ROOK developers copied and pasted the code for services & processes termination as well as deleting shadow copies. ROOKs multithreading approach is a reimplementation and an upgrade from that of BABUK version 3, which is now more efficient for directory traversal.",
                        "Then it executes ShellExecuteW to launch the following command in the command line to delete all shadow copies in the system.",
                        "Figure 20: Deleting Shadow Copies.",
                        "Rook Ransomware Contents Overview IOCS Ransom Note<crlf>Contents<crlf>Overview<crlf>IOCS<crlf>Ransom Note<crlf>Static Code Analysis RSA Key Generation Anti-Detection: Alternate Data Streams Command-line Arguments Logging Stopping Services Terminating Processes Deleting Shadow Copies Multithreading Setup Network Resource Traversal Drives Traversal Shares Traversal Child Thread File Encryption References<crlf>RSA Key Generation<crlf>Anti-Detection: Alternate Data Streams<crlf>Command-line Arguments<crlf>Logging<crlf>Stopping Services<crlf>Terminating Processes<crlf>Deleting Shadow Copies<crlf>Multithreading Setup<crlf>Network Resource Traversal<crlf>Drives Traversal<crlf>Shares Traversal<crlf>Child Thread<crlf>File Encryption<crlf>References"
                    ],
                    "titles": [
                        "Deleting Shadow Copies"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xec56ee55>",
                    "type": "UnknownWord",
                    "value": "multithreading"
                },
                "references": {
                    "sentences": [
                        "For execution speed, ROOK is quite fast since it uses a decently good method of multithreading with two global lists for file and directory traversal.",
                        "Prior to encrypting files, ROOK sets up its own multithreading system.",
                        "The multithreading structure is divided into two parts: file encryption and directory enumeration.",
                        "Rook Ransomware Contents Overview IOCS Ransom Note<crlf>Contents<crlf>Overview<crlf>IOCS<crlf>Ransom Note<crlf>Static Code Analysis RSA Key Generation Anti-Detection: Alternate Data Streams Command-line Arguments Logging Stopping Services Terminating Processes Deleting Shadow Copies Multithreading Setup Network Resource Traversal Drives Traversal Shares Traversal Child Thread File Encryption References<crlf>RSA Key Generation<crlf>Anti-Detection: Alternate Data Streams<crlf>Command-line Arguments<crlf>Logging<crlf>Stopping Services<crlf>Terminating Processes<crlf>Deleting Shadow Copies<crlf>Multithreading Setup<crlf>Network Resource Traversal<crlf>Drives Traversal<crlf>Shares Traversal<crlf>Child Thread<crlf>File Encryption<crlf>References",
                        "As it has been claimed by other researchers, ROOK borrows some of the code from the leaked BABUK source code. To be more specific, the ROOK developers copied and pasted the code for services & processes termination as well as deleting shadow copies. ROOKs multithreading approach is a reimplementation and an upgrade from that of BABUK version 3, which is now more efficient for directory traversal."
                    ],
                    "titles": [
                        "Multithreading Setup"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc02e1d04>",
                    "type": "UnknownWord",
                    "value": "mbed"
                },
                "references": {
                    "sentences": [
                        "ROOK is a relatively new ransomware that has been coming up in the last few months. With the Mbed TLS library, the malware uses a hybrid cryptography scheme to encrypt files using AES and protect its keys with RSA-2048.",
                        "First, it uses the Mbed TLS CTR_DRBG context to generates a random 16-byte AES key.",
                        "First, the malware initializes a CTR_DRBG context using the Mbed TLS library, which is used to build a pseudo-RNG to later randomly generate AES keys."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2cdbc13e>",
                    "type": "UnknownWord",
                    "value": "hybrid"
                },
                "references": {
                    "sentences": [
                        "ROOK is a relatively new ransomware that has been coming up in the last few months. With the Mbed TLS library, the malware uses a hybrid cryptography scheme to encrypt files using AES and protect its keys with RSA-2048."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbc1c499d>",
                    "type": "UnknownWord",
                    "value": "cryptography"
                },
                "references": {
                    "sentences": [
                        "ROOK is a relatively new ransomware that has been coming up in the last few months. With the Mbed TLS library, the malware uses a hybrid cryptography scheme to encrypt files using AES and protect its keys with RSA-2048."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xca2902ea>",
                    "type": "UnknownWord",
                    "value": "rsa-2048"
                },
                "references": {
                    "sentences": [
                        "ROOK is a relatively new ransomware that has been coming up in the last few months. With the Mbed TLS library, the malware uses a hybrid cryptography scheme to encrypt files using AES and protect its keys with RSA-2048."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc7a6181>",
                    "type": "UnknownWord",
                    "value": "decently"
                },
                "references": {
                    "sentences": [
                        "For execution speed, ROOK is quite fast since it uses a decently good method of multithreading with two global lists for file and directory traversal."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xacc02c46>",
                    "type": "UnknownWord",
                    "value": "borrows"
                },
                "references": {
                    "sentences": [
                        "As it has been claimed by other researchers, ROOK borrows some of the code from the leaked BABUK source code. To be more specific, the ROOK developers copied and pasted the code for services & processes termination as well as deleting shadow copies. ROOKs multithreading approach is a reimplementation and an upgrade from that of BABUK version 3, which is now more efficient for directory traversal.",
                        "For stopping services, ROOK borrows this part from the leaked BABUK source code."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf97c8d28>",
                    "type": "UnknownWord",
                    "value": "reimplementation"
                },
                "references": {
                    "sentences": [
                        "As it has been claimed by other researchers, ROOK borrows some of the code from the leaked BABUK source code. To be more specific, the ROOK developers copied and pasted the code for services & processes termination as well as deleting shadow copies. ROOKs multithreading approach is a reimplementation and an upgrade from that of BABUK version 3, which is now more efficient for directory traversal."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb061da40>",
                    "type": "UnknownWord",
                    "value": "efficient"
                },
                "references": {
                    "sentences": [
                        "As it has been claimed by other researchers, ROOK borrows some of the code from the leaked BABUK source code. To be more specific, the ROOK developers copied and pasted the code for services & processes termination as well as deleting shadow copies. ROOKs multithreading approach is a reimplementation and an upgrade from that of BABUK version 3, which is now more efficient for directory traversal."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x358b9e91>",
                    "type": "UnknownWord",
                    "value": "devs"
                },
                "references": {
                    "sentences": [
                        "However, unlike BABUK devs who are big fans of using ECDH curves and eSTREAM portfolio Profile 1 ciphers such as ChaCha and HC-128 for hybrid-encryption, ROOK devs stick with the traditional choice of RSA and AES."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x59403772>",
                    "type": "UnknownWord",
                    "value": "fans"
                },
                "references": {
                    "sentences": [
                        "However, unlike BABUK devs who are big fans of using ECDH curves and eSTREAM portfolio Profile 1 ciphers such as ChaCha and HC-128 for hybrid-encryption, ROOK devs stick with the traditional choice of RSA and AES."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x84022151>",
                    "type": "UnknownWord",
                    "value": "ecdh"
                },
                "references": {
                    "sentences": [
                        "However, unlike BABUK devs who are big fans of using ECDH curves and eSTREAM portfolio Profile 1 ciphers such as ChaCha and HC-128 for hybrid-encryption, ROOK devs stick with the traditional choice of RSA and AES."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2162b070>",
                    "type": "UnknownWord",
                    "value": "curves"
                },
                "references": {
                    "sentences": [
                        "However, unlike BABUK devs who are big fans of using ECDH curves and eSTREAM portfolio Profile 1 ciphers such as ChaCha and HC-128 for hybrid-encryption, ROOK devs stick with the traditional choice of RSA and AES."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa353cd6f>",
                    "type": "UnknownWord",
                    "value": "estream"
                },
                "references": {
                    "sentences": [
                        "However, unlike BABUK devs who are big fans of using ECDH curves and eSTREAM portfolio Profile 1 ciphers such as ChaCha and HC-128 for hybrid-encryption, ROOK devs stick with the traditional choice of RSA and AES."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xade1295a>",
                    "type": "UnknownWord",
                    "value": "ciphers"
                },
                "references": {
                    "sentences": [
                        "However, unlike BABUK devs who are big fans of using ECDH curves and eSTREAM portfolio Profile 1 ciphers such as ChaCha and HC-128 for hybrid-encryption, ROOK devs stick with the traditional choice of RSA and AES."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4b145a7e>",
                    "type": "UnknownWord",
                    "value": "hc-128"
                },
                "references": {
                    "sentences": [
                        "However, unlike BABUK devs who are big fans of using ECDH curves and eSTREAM portfolio Profile 1 ciphers such as ChaCha and HC-128 for hybrid-encryption, ROOK devs stick with the traditional choice of RSA and AES."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf36225ca>",
                    "type": "UnknownWord",
                    "value": "hybrid-encryption"
                },
                "references": {
                    "sentences": [
                        "However, unlike BABUK devs who are big fans of using ECDH curves and eSTREAM portfolio Profile 1 ciphers such as ChaCha and HC-128 for hybrid-encryption, ROOK devs stick with the traditional choice of RSA and AES."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd062a912>",
                    "type": "UnknownWord",
                    "value": "stick"
                },
                "references": {
                    "sentences": [
                        "However, unlike BABUK devs who are big fans of using ECDH curves and eSTREAM portfolio Profile 1 ciphers such as ChaCha and HC-128 for hybrid-encryption, ROOK devs stick with the traditional choice of RSA and AES."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbe58df53>",
                    "type": "UnknownWord",
                    "value": "restore"
                },
                "references": {
                    "sentences": [
                        "ROOKs ransom note filename is HowToRestoreYourFiles.txt, which is really similar to BABUKs How To Restore Your Files.txt."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xad870dc6>",
                            "type": "File",
                            "value": "howtorestoreyourfiles.txt"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbe58df53>",
                            "type": "UnknownWord",
                            "value": "restore"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xeb497dc6>",
                            "type": "File",
                            "value": "files.txt"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbe58df53>",
                            "type": "UnknownWord",
                            "value": "restore"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb5379c9>",
                    "type": "UnknownWord",
                    "value": "asymmetric"
                },
                "references": {
                    "sentences": [
                        "The first thing ROOK does upon execution is setting up the RSA keys for asymmetric encryption."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x89147a11>",
                    "type": "UnknownWord",
                    "value": "initializes"
                },
                "references": {
                    "sentences": [
                        "First, the malware initializes a CTR_DRBG context using the Mbed TLS library, which is used to build a pseudo-RNG to later randomly generate AES keys."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4f8c8df4>",
                    "type": "UnknownWord",
                    "value": "ctr_drbg"
                },
                "references": {
                    "sentences": [
                        "First, it uses the Mbed TLS CTR_DRBG context to generates a random 16-byte AES key.",
                        "Figure 4: CTR_DRBG Initialization.",
                        "First, the malware initializes a CTR_DRBG context using the Mbed TLS library, which is used to build a pseudo-RNG to later randomly generate AES keys."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xee7fb85>",
                    "type": "UnknownWord",
                    "value": "pseudo-rng"
                },
                "references": {
                    "sentences": [
                        "First, the malware initializes a CTR_DRBG context using the Mbed TLS library, which is used to build a pseudo-RNG to later randomly generate AES keys."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfc17fdb0>",
                    "type": "UnknownWord",
                    "value": "mbedtls_pk_parse_public_key"
                },
                "references": {
                    "sentences": [
                        "Finally, the malware calls mbedtls_pk_parse_public_key to retrieve the victims public key context and wipes the victims raw private key from memory.",
                        "Next, it calls mbedtls_pk_parse_public_key to parse the TAs RSA public key into a mbedtls_pk_context struct. The ROOKs public key context is then extracted from the pk_ctx field on the newly populated mbedtls_pk_context struct."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa94bf552>",
                    "type": "UnknownWord",
                    "value": "mbedtls_pk_context"
                },
                "references": {
                    "sentences": [
                        "Next, it calls mbedtls_pk_parse_public_key to parse the TAs RSA public key into a mbedtls_pk_context struct. The ROOKs public key context is then extracted from the pk_ctx field on the newly populated mbedtls_pk_context struct."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x160b77de>",
                    "type": "UnknownWord",
                    "value": "struct"
                },
                "references": {
                    "sentences": [
                        "Next, it calls mbedtls_pk_parse_public_key to parse the TAs RSA public key into a mbedtls_pk_context struct. The ROOKs public key context is then extracted from the pk_ctx field on the newly populated mbedtls_pk_context struct."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc5fdd0bf>",
                    "type": "UnknownWord",
                    "value": "pk_ctx"
                },
                "references": {
                    "sentences": [
                        "Next, it calls mbedtls_pk_parse_public_key to parse the TAs RSA public key into a mbedtls_pk_context struct. The ROOKs public key context is then extracted from the pk_ctx field on the newly populated mbedtls_pk_context struct."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcff3e05a>",
                    "type": "UnknownWord",
                    "value": "regcreatekeyexw"
                },
                "references": {
                    "sentences": [
                        "ROOK then calls RegCreateKeyExW to open the subkey Software in HKEY_CURRENT_USER. Using that, it calls RegQueryValueExW to check if the registry value RookPublicKey exists in there. If it does not, the malware generates a public-private key pair for the victim."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe843bde7>",
                    "type": "UnknownWord",
                    "value": "subkey"
                },
                "references": {
                    "sentences": [
                        "ROOK then calls RegCreateKeyExW to open the subkey Software in HKEY_CURRENT_USER. Using that, it calls RegQueryValueExW to check if the registry value RookPublicKey exists in there. If it does not, the malware generates a public-private key pair for the victim."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd78cdc6a>",
                    "type": "UnknownWord",
                    "value": "hkey_current_user"
                },
                "references": {
                    "sentences": [
                        "ROOK then calls RegCreateKeyExW to open the subkey Software in HKEY_CURRENT_USER. Using that, it calls RegQueryValueExW to check if the registry value RookPublicKey exists in there. If it does not, the malware generates a public-private key pair for the victim."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8577fea3>",
                    "type": "UnknownWord",
                    "value": "regqueryvalueexw"
                },
                "references": {
                    "sentences": [
                        "ROOK then calls RegCreateKeyExW to open the subkey Software in HKEY_CURRENT_USER. Using that, it calls RegQueryValueExW to check if the registry value RookPublicKey exists in there. If it does not, the malware generates a public-private key pair for the victim."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5ed4f10e>",
                    "type": "UnknownWord",
                    "value": "rookpublickey"
                },
                "references": {
                    "sentences": [
                        "The victims public key and encrypted private key are consecutively stored in the registry at the value RookPublicKey and RookPrivateKey.",
                        "ROOK then calls RegCreateKeyExW to open the subkey Software in HKEY_CURRENT_USER. Using that, it calls RegQueryValueExW to check if the registry value RookPublicKey exists in there. If it does not, the malware generates a public-private key pair for the victim."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8ae68cc9>",
                    "type": "UnknownWord",
                    "value": "public-private"
                },
                "references": {
                    "sentences": [
                        "Figure 6, 7: Querying From Registry & Generating Victim Public-Private Key Pair.",
                        "ROOK then calls RegCreateKeyExW to open the subkey Software in HKEY_CURRENT_USER. Using that, it calls RegQueryValueExW to check if the registry value RookPublicKey exists in there. If it does not, the malware generates a public-private key pair for the victim."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x75103b6a>",
                    "type": "UnknownWord",
                    "value": "pair"
                },
                "references": {
                    "sentences": [
                        "Figure 6, 7: Querying From Registry & Generating Victim Public-Private Key Pair.",
                        "ROOK then calls RegCreateKeyExW to open the subkey Software in HKEY_CURRENT_USER. Using that, it calls RegQueryValueExW to check if the registry value RookPublicKey exists in there. If it does not, the malware generates a public-private key pair for the victim."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd04412ad>",
                    "type": "UnknownWord",
                    "value": "querying"
                },
                "references": {
                    "sentences": [
                        "Figure 6, 7: Querying From Registry & Generating Victim Public-Private Key Pair."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x85ce1a7d>",
                    "type": "UnknownWord",
                    "value": "consecutively"
                },
                "references": {
                    "sentences": [
                        "The victims public key and encrypted private key are consecutively stored in the registry at the value RookPublicKey and RookPrivateKey."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x987c422e>",
                    "type": "UnknownWord",
                    "value": "rookprivatekey"
                },
                "references": {
                    "sentences": [
                        "The victims public key and encrypted private key are consecutively stored in the registry at the value RookPublicKey and RookPrivateKey.",
                        "If the victims public key was already generated before and the malware can query it directly from registry, the victims encrypted private key is pulled from the registry value RookPrivateKey."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xee7beb82>",
                    "type": "UnknownWord",
                    "value": "pulled"
                },
                "references": {
                    "sentences": [
                        "If the victims public key was already generated before and the malware can query it directly from registry, the victims encrypted private key is pulled from the registry value RookPrivateKey."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa385fc59>",
                    "type": "UnknownWord",
                    "value": "wipes"
                },
                "references": {
                    "sentences": [
                        "Finally, the malware calls mbedtls_pk_parse_public_key to retrieve the victims public key context and wipes the victims raw private key from memory."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3e3a9b7e>",
                    "type": "UnknownWord",
                    "value": "cleaning"
                },
                "references": {
                    "sentences": [
                        "Figure 9: Writing Keys to Registry & Cleaning Up."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x143823b>",
                    "type": "UnknownWord",
                    "value": "ntfs"
                },
                "references": {
                    "sentences": [
                        "Alternate Data Streams (ADS) is a file attribute on the NT File System (NTFS) which was designed for compatibility with Macintosh Hierarchical File System (HFS)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe664bb50>",
                    "type": "UnknownWord",
                    "value": "macintosh"
                },
                "references": {
                    "sentences": [
                        "Alternate Data Streams (ADS) is a file attribute on the NT File System (NTFS) which was designed for compatibility with Macintosh Hierarchical File System (HFS)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x724c851c>",
                    "type": "UnknownWord",
                    "value": "hierarchical"
                },
                "references": {
                    "sentences": [
                        "Alternate Data Streams (ADS) is a file attribute on the NT File System (NTFS) which was designed for compatibility with Macintosh Hierarchical File System (HFS)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xaf83929f>",
                    "type": "UnknownWord",
                    "value": "stream"
                },
                "references": {
                    "sentences": [
                        "It then calls CreateFileW to retrieve its own handle and SetFileInformationByHandle to rename the file with a data stream named :ask. This ultimately puts the entire executable into the alternate :ask data stream, leaving an empty file on the primary stream.",
                        "To test this, I use two copies of the ROOK sample and have the ro0k.mal_ one hide itself in the :ask data stream. As we can see in the command-line, that file shows up empty, but its alternate data stream contains the full malicious executable.",
                        "Figure 10: Moving Executable to Data Stream.",
                        "For normal files, there is typically one primary data stream that is known as the unnamed data stream since its name is an empty string. However, ADS allows files to have more than one data stream, with any stream with a name being considered alternate.",
                        "Figure 11: Examining Alternate Data Stream In Command-Line."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb913d33a>",
                    "type": "UnknownWord",
                    "value": "harmless"
                },
                "references": {
                    "sentences": [
                        "Because alternate data streams are hidden from Windows Explorer and the dir command on the command-line, they are a sneaky way to hide external executable from a seemingly harmless file."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb2fc908b>",
                    "type": "UnknownWord",
                    "value": "getmodulefilenamew"
                },
                "references": {
                    "sentences": [
                        "To evade detection, ROOK uses ADS to hides its own executable. First, it calls GetModuleFileNameW with a NULL handle to retrieve its own executable path."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x533ce732>",
                    "type": "UnknownWord",
                    "value": "handle"
                },
                "references": {
                    "sentences": [
                        "It then calls CreateFileW to retrieve its own handle and SetFileInformationByHandle to rename the file with a data stream named :ask. This ultimately puts the entire executable into the alternate :ask data stream, leaving an empty file on the primary stream.",
                        "Pausing the execution after the handle is released using the call to CloseHandle, we can examine how it looks in the system.",
                        "The malware calls WNetOpenEnumW to retrieve an enumeration handle for all network resources and WNetEnumResourceW to enumerate through them.",
                        "To evade detection, ROOK uses ADS to hides its own executable. First, it calls GetModuleFileNameW with a NULL handle to retrieve its own executable path.",
                        "Then, ROOK checks to make sure the application is not its own ransomware process through the process IDs. Finally, it calls OpenProcess to retrieve the processs handle and terminate it using TerminateProcess.",
                        "Next, it iterates through a hard-coded list containing services to be stopped. For each of these service, the malware calls OpenServiceA to retrieve the services handle and QueryServiceStatusEx to query and checks if the service state is SERVICE_STOP_PENDING.",
                        "For each process whose name is in the list of processes to be terminated, the malware calls OpenProcess to retrieve the processs handle and TerminateProcess to terminate it.",
                        "Using that session handle, the malware calls RmRegisterResources to register the target file as a resource to the RM.",
                        "Next, the malware calls CreateFileW to retrieve the file handle for the target and begins the encryption.",
                        "The malware first calls GetTickCount to get a tick count prior to stopping services. It then calls OpenSCManagerA to retrieve a service control manager handle.",
                        "For each dependent service, the malware calls OpenServiceA to retrieve its handle and ControlService to send a control stop code to stop it. It also sleeps and calls QueryServiceStatusEx to wait until the services state is fully stopped."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9300f930>",
                    "type": "UnknownWord",
                    "value": "createfilew"
                },
                "references": {
                    "sentences": [
                        "It then calls CreateFileW to retrieve its own handle and SetFileInformationByHandle to rename the file with a data stream named :ask. This ultimately puts the entire executable into the alternate :ask data stream, leaving an empty file on the primary stream.",
                        "For the enumeration, ROOK first builds a path to a ransom note file in the directory, calls CreateFileW to create it and WriteFile to write the ransom note content to it.",
                        "Next, the malware calls CreateFileW to retrieve the file handle for the target and begins the encryption.",
                        "When the debug argument is provided on the command-line, ROOK enables debugging and calls CreateFileW to create the log file to later log into."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8a02e5dc>",
                    "type": "UnknownWord",
                    "value": "setfileinformationbyhandle"
                },
                "references": {
                    "sentences": [
                        "It then calls CreateFileW to retrieve its own handle and SetFileInformationByHandle to rename the file with a data stream named :ask. This ultimately puts the entire executable into the alternate :ask data stream, leaving an empty file on the primary stream.",
                        "After hiding itself, ROOK also calls SetFileInformationByHandle again to set the file to be deleted once all handles are closed at the end."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x600c7855>",
                    "type": "UnknownWord",
                    "value": "pausing"
                },
                "references": {
                    "sentences": [
                        "Pausing the execution after the handle is released using the call to CloseHandle, we can examine how it looks in the system."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x703f3560>",
                    "type": "UnknownWord",
                    "value": "closehandle"
                },
                "references": {
                    "sentences": [
                        "Pausing the execution after the handle is released using the call to CloseHandle, we can examine how it looks in the system."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4ddf7316>",
                    "type": "UnknownWord",
                    "value": "mal_"
                },
                "references": {
                    "sentences": [
                        "To test this, I use two copies of the ROOK sample and have the ro0k.mal_ one hide itself in the :ask data stream. As we can see in the command-line, that file shows up empty, but its alternate data stream contains the full malicious executable."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x16adf657>",
                    "type": "UnknownWord",
                    "value": "self-deletion"
                },
                "references": {
                    "sentences": [
                        "Figure 12: Set Up File for Self-Deletion."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x23662f1d>",
                    "type": "UnknownWord",
                    "value": "supplied"
                },
                "references": {
                    "sentences": [
                        "Below is the list of arguments that can be supplied by the operator."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9f13d65f>",
                    "type": "UnknownWord",
                    "value": "-debug"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x81b6336b>",
                    "type": "UnknownWord",
                    "value": "<log_filename>"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb5cba891>",
                    "type": "UnknownWord",
                    "value": "-shares"
                },
                "references": {
                    "sentences": [
                        "When the command-line argument -paths or -shares is not provided, ROOK recursively traverses through all resources in the network."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf8a9b358>",
                    "type": "UnknownWord",
                    "value": "<share_list>"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x45bc3b08>",
                    "type": "UnknownWord",
                    "value": "traversed"
                },
                "references": {
                    "sentences": [
                        "For each sub-directory found, the malware checks if the filename is not in the list of files and directories to avoid. If its not, the sub-directory full path is constructed and passed back to recursive_traverse_dir to be recursively traversed.",
                        "If the drive type is a remote drive, ROOK calls WNetGetConnectionW to retrieve the remote name of the drive and passes it to be traversed by the recursive_traverse_dir function.",
                        "Next, the malware calls EnterCriticalSection to obtain the ownership of the global directory list and adds the directory path to be traversed in. Then, it calls ReleaseSemaphore to release the BEGIN_ACCESS_DIR_SEMAPHORE semaphore, which increments its count by one and signals other threads that another directory is available to be enumerated.",
                        "In the recursive_traverse_dir function, ROOK begins by executing two nested while loop. The first one loops and waits until the END_ACCESS_DIR_SEMAPHORE semaphores count is reduced to zero, and its state is nonsignaled. When this happens, it means every directory in the global directory list is already traversed and no thread is extracting from it."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3617cf93>",
                    "type": "UnknownWord",
                    "value": "-paths"
                },
                "references": {
                    "sentences": [
                        "If the command-line argument -paths is not provided, ROOK manually mounts all drives that have no volume mounted and traverses through all of them.",
                        "When the command-line argument -paths is provided, ROOK specifically enumerates them and exits upon completion.",
                        "When the command-line argument -paths or -shares is not provided, ROOK recursively traverses through all resources in the network.",
                        "Figure 25: Parsing -paths Command-Line Argument."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xaa98b390>",
                    "type": "UnknownWord",
                    "value": "<drive_list>"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x756460f1>",
                    "type": "UnknownWord",
                    "value": "initializecriticalsection"
                },
                "references": {
                    "sentences": [
                        "For file encryption, the malware calculates the maximum number of files to be encrypted by multiple threads at the same time is 24 times the number of processors. It then calls HeapAlloc to allocate a global array to store the files that are set to be encrypted and CreateSemaphoreA to create 2 semaphores that are used for synchronization among threads that access the file array. Finally, it also calls<crlf>InitializeCriticalSection to initialize a critical section that allows one thread to add or remove a file from the global array at a time.",
                        "It also calls InitializeCriticalSection to initialize a critical section to prevent multiple threads from writing into the log file at the same time."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xadfa770d>",
                    "type": "UnknownWord",
                    "value": "initialize"
                },
                "references": {
                    "sentences": [
                        "For file encryption, the malware calculates the maximum number of files to be encrypted by multiple threads at the same time is 24 times the number of processors. It then calls HeapAlloc to allocate a global array to store the files that are set to be encrypted and CreateSemaphoreA to create 2 semaphores that are used for synchronization among threads that access the file array. Finally, it also calls<crlf>InitializeCriticalSection to initialize a critical section that allows one thread to add or remove a file from the global array at a time.",
                        "It also calls InitializeCriticalSection to initialize a critical section to prevent multiple threads from writing into the log file at the same time."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8fa55e5d>",
                    "type": "UnknownWord",
                    "value": "gettickcount"
                },
                "references": {
                    "sentences": [
                        "The malware first calls GetTickCount to get a tick count prior to stopping services. It then calls OpenSCManagerA to retrieve a service control manager handle."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe84701a7>",
                    "type": "UnknownWord",
                    "value": "openscmanagera"
                },
                "references": {
                    "sentences": [
                        "The malware first calls GetTickCount to get a tick count prior to stopping services. It then calls OpenSCManagerA to retrieve a service control manager handle."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x328f29d5>",
                    "type": "UnknownWord",
                    "value": "iterates"
                },
                "references": {
                    "sentences": [
                        "First, it builds a list of all drive letters and iterates through it to find drives with type DRIVE_NO_ROOT_DIR. Those drives are then added to the end of the list.",
                        "Next, it iterates through a hard-coded list containing services to be stopped. For each of these service, the malware calls OpenServiceA to retrieve the services handle and QueryServiceStatusEx to query and checks if the service state is SERVICE_STOP_PENDING."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x645ff267>",
                    "type": "UnknownWord",
                    "value": "openservicea"
                },
                "references": {
                    "sentences": [
                        "For each dependent service, the malware calls OpenServiceA to retrieve its handle and ControlService to send a control stop code to stop it. It also sleeps and calls QueryServiceStatusEx to wait until the services state is fully stopped.",
                        "Next, it iterates through a hard-coded list containing services to be stopped. For each of these service, the malware calls OpenServiceA to retrieve the services handle and QueryServiceStatusEx to query and checks if the service state is SERVICE_STOP_PENDING."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x38a6847b>",
                    "type": "UnknownWord",
                    "value": "queryservicestatusex"
                },
                "references": {
                    "sentences": [
                        "For each dependent service, the malware calls OpenServiceA to retrieve its handle and ControlService to send a control stop code to stop it. It also sleeps and calls QueryServiceStatusEx to wait until the services state is fully stopped.",
                        "Next, it iterates through a hard-coded list containing services to be stopped. For each of these service, the malware calls OpenServiceA to retrieve the services handle and QueryServiceStatusEx to query and checks if the service state is SERVICE_STOP_PENDING."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6f47e127>",
                    "type": "UnknownWord",
                    "value": "service_stop_pending"
                },
                "references": {
                    "sentences": [
                        "Next, it iterates through a hard-coded list containing services to be stopped. For each of these service, the malware calls OpenServiceA to retrieve the services handle and QueryServiceStatusEx to query and checks if the service state is SERVICE_STOP_PENDING."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xeffb057d>",
                    "type": "UnknownWord",
                    "value": "enumdependentservicesa"
                },
                "references": {
                    "sentences": [
                        "If it is not, ROOK calls EnumDependentServicesA to enumerate through all dependent services of the target service and stop them."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfb858ca6>",
                    "type": "UnknownWord",
                    "value": "iterating"
                },
                "references": {
                    "sentences": [
                        "Figure 15: Iterating Through Service Stop List.",
                        "Figure 42: Iterating & Encrypting Files in Global List."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe38ae89a>",
                    "type": "UnknownWord",
                    "value": "controlservice"
                },
                "references": {
                    "sentences": [
                        "After stopping all dependent services, ROOK calls ControlService send a control stop code to the main service and continuosly checks until the service is fully stopped.",
                        "For each dependent service, the malware calls OpenServiceA to retrieve its handle and ControlService to send a control stop code to stop it. It also sleeps and calls QueryServiceStatusEx to wait until the services state is fully stopped."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6dcefc69>",
                    "type": "UnknownWord",
                    "value": "continuosly"
                },
                "references": {
                    "sentences": [
                        "After stopping all dependent services, ROOK calls ControlService send a control stop code to the main service and continuosly checks until the service is fully stopped."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9d099c99>",
                    "type": "UnknownWord",
                    "value": "30000ms"
                },
                "references": {
                    "sentences": [
                        "For stopping all services, the maximum timeout is 30000ms or 30 seconds from the original tick count. If it takes more than 30 seconds to stop services, the malware aborts and exits the function."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc302a87e>",
                    "type": "UnknownWord",
                    "value": "aborts"
                },
                "references": {
                    "sentences": [
                        "For stopping all services, the maximum timeout is 30000ms or 30 seconds from the original tick count. If it takes more than 30 seconds to stop services, the malware aborts and exits the function."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf98a4a49>",
                    "type": "UnknownWord",
                    "value": "createtoolhelp32snapshot"
                },
                "references": {
                    "sentences": [
                        "ROOK calls CreateToolhelp32Snapshot to retrieve a snapshot of all processes and threads in the system. It then calls Process32FirstW and Process32NextW to enumerate through the snapshot."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4a693244>",
                    "type": "UnknownWord",
                    "value": "process32firstw"
                },
                "references": {
                    "sentences": [
                        "ROOK calls CreateToolhelp32Snapshot to retrieve a snapshot of all processes and threads in the system. It then calls Process32FirstW and Process32NextW to enumerate through the snapshot."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6d236ed>",
                    "type": "UnknownWord",
                    "value": "process32nextw"
                },
                "references": {
                    "sentences": [
                        "ROOK calls CreateToolhelp32Snapshot to retrieve a snapshot of all processes and threads in the system. It then calls Process32FirstW and Process32NextW to enumerate through the snapshot."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1e607597>",
                    "type": "UnknownWord",
                    "value": "openprocess"
                },
                "references": {
                    "sentences": [
                        "For each process whose name is in the list of processes to be terminated, the malware calls OpenProcess to retrieve the processs handle and TerminateProcess to terminate it.",
                        "Then, ROOK checks to make sure the application is not its own ransomware process through the process IDs. Finally, it calls OpenProcess to retrieve the processs handle and terminate it using TerminateProcess."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xef3a94f0>",
                    "type": "UnknownWord",
                    "value": "terminateprocess"
                },
                "references": {
                    "sentences": [
                        "For each process whose name is in the list of processes to be terminated, the malware calls OpenProcess to retrieve the processs handle and TerminateProcess to terminate it.",
                        "Then, ROOK checks to make sure the application is not its own ransomware process through the process IDs. Finally, it calls OpenProcess to retrieve the processs handle and terminate it using TerminateProcess."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x80ab9416>",
                    "type": "UnknownWord",
                    "value": "processor"
                },
                "references": {
                    "sentences": [
                        "ROOK first checks if its process is running under a 64-bit processor by calling IsWow64Process."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x18ee2538>",
                    "type": "UnknownWord",
                    "value": "iswow64process"
                },
                "references": {
                    "sentences": [
                        "ROOK first checks if its process is running under a 64-bit processor by calling IsWow64Process."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcb6f45f8>",
                    "type": "UnknownWord",
                    "value": "wow64disablewow64fsredirection"
                },
                "references": {
                    "sentences": [
                        "If it is, the malware calls Wow64DisableWow64FsRedirection to disable file system redirection for its process."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x83defb44>",
                    "type": "UnknownWord",
                    "value": "wow64revertwow64fsredirection"
                },
                "references": {
                    "sentences": [
                        "Finally, if the malwares process is running under a 64-bit architecture, it calls Wow64RevertWow64FsRedirection to enable file system redirection."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5c166924>",
                    "type": "UnknownWord",
                    "value": "getsysteminfo"
                },
                "references": {
                    "sentences": [
                        "Initially, it calls GetSystemInfo to retrieve the number of processors in the system."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8d2fd742>",
                    "type": "UnknownWord",
                    "value": "divided"
                },
                "references": {
                    "sentences": [
                        "The multithreading structure is divided into two parts: file encryption and directory enumeration."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x187044d9>",
                    "type": "UnknownWord",
                    "value": "calculates"
                },
                "references": {
                    "sentences": [
                        "For file encryption, the malware calculates the maximum number of files to be encrypted by multiple threads at the same time is 24 times the number of processors. It then calls HeapAlloc to allocate a global array to store the files that are set to be encrypted and CreateSemaphoreA to create 2 semaphores that are used for synchronization among threads that access the file array. Finally, it also calls<crlf>InitializeCriticalSection to initialize a critical section that allows one thread to add or remove a file from the global array at a time.",
                        "For directory enumeration, the malware calculates the maximum number of directories to be enumerated by multiple threads at the same time is 6 times the number of processors. It also creates a global array, 2 semaphores, and a critical section like to the file encryption part above."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfb45706f>",
                    "type": "UnknownWord",
                    "value": "heapalloc"
                },
                "references": {
                    "sentences": [
                        "For file encryption, the malware calculates the maximum number of files to be encrypted by multiple threads at the same time is 24 times the number of processors. It then calls HeapAlloc to allocate a global array to store the files that are set to be encrypted and CreateSemaphoreA to create 2 semaphores that are used for synchronization among threads that access the file array. Finally, it also calls<crlf>InitializeCriticalSection to initialize a critical section that allows one thread to add or remove a file from the global array at a time.",
                        "Next, the malware calls HeapAlloc to allocate two arrays to store child thread handles, one for file encryption and the other for directory enumeration."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf60948a4>",
                    "type": "UnknownWord",
                    "value": "allocate"
                },
                "references": {
                    "sentences": [
                        "For file encryption, the malware calculates the maximum number of files to be encrypted by multiple threads at the same time is 24 times the number of processors. It then calls HeapAlloc to allocate a global array to store the files that are set to be encrypted and CreateSemaphoreA to create 2 semaphores that are used for synchronization among threads that access the file array. Finally, it also calls<crlf>InitializeCriticalSection to initialize a critical section that allows one thread to add or remove a file from the global array at a time.",
                        "Next, the malware calls HeapAlloc to allocate two arrays to store child thread handles, one for file encryption and the other for directory enumeration."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfd0452fa>",
                    "type": "UnknownWord",
                    "value": "createsemaphorea"
                },
                "references": {
                    "sentences": [
                        "For file encryption, the malware calculates the maximum number of files to be encrypted by multiple threads at the same time is 24 times the number of processors. It then calls HeapAlloc to allocate a global array to store the files that are set to be encrypted and CreateSemaphoreA to create 2 semaphores that are used for synchronization among threads that access the file array. Finally, it also calls<crlf>InitializeCriticalSection to initialize a critical section that allows one thread to add or remove a file from the global array at a time."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb8cc3c45>",
                    "type": "UnknownWord",
                    "value": "semaphores"
                },
                "references": {
                    "sentences": [
                        "For file encryption, the malware calculates the maximum number of files to be encrypted by multiple threads at the same time is 24 times the number of processors. It then calls HeapAlloc to allocate a global array to store the files that are set to be encrypted and CreateSemaphoreA to create 2 semaphores that are used for synchronization among threads that access the file array. Finally, it also calls<crlf>InitializeCriticalSection to initialize a critical section that allows one thread to add or remove a file from the global array at a time.",
                        "For directory enumeration, the malware calculates the maximum number of directories to be enumerated by multiple threads at the same time is 6 times the number of processors. It also creates a global array, 2 semaphores, and a critical section like to the file encryption part above.",
                        "In the recursive_traverse_dir function, ROOK begins by executing two nested while loop. The first one loops and waits until the END_ACCESS_DIR_SEMAPHORE semaphores count is reduced to zero, and its state is nonsignaled. When this happens, it means every directory in the global directory list is already traversed and no thread is extracting from it."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbc8f23b6>",
                    "type": "UnknownWord",
                    "value": "synchronization"
                },
                "references": {
                    "sentences": [
                        "For file encryption, the malware calculates the maximum number of files to be encrypted by multiple threads at the same time is 24 times the number of processors. It then calls HeapAlloc to allocate a global array to store the files that are set to be encrypted and CreateSemaphoreA to create 2 semaphores that are used for synchronization among threads that access the file array. Finally, it also calls<crlf>InitializeCriticalSection to initialize a critical section that allows one thread to add or remove a file from the global array at a time."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2d9126b5>",
                    "type": "UnknownWord",
                    "value": "createthread"
                },
                "references": {
                    "sentences": [
                        "ROOK then calls CreateThread to spawn threads for double the number of processors for each thread array. The functionalities of these threads are later discussed in the Child Thread section."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x75f9c343>",
                    "type": "UnknownWord",
                    "value": "spawning"
                },
                "references": {
                    "sentences": [
                        "Figure 23: Spawning Child Threads."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe918c796>",
                    "type": "UnknownWord",
                    "value": "traverses"
                },
                "references": {
                    "sentences": [
                        "If the command-line argument -paths is not provided, ROOK manually mounts all drives that have no volume mounted and traverses through all of them.",
                        "When the command-line argument -paths or -shares is not provided, ROOK recursively traverses through all resources in the network."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x38da6af3>",
                    "type": "UnknownWord",
                    "value": "wnetopenenumw"
                },
                "references": {
                    "sentences": [
                        "The malware calls WNetOpenEnumW to retrieve an enumeration handle for all network resources and WNetEnumResourceW to enumerate through them."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7f721e60>",
                    "type": "UnknownWord",
                    "value": "wnetenumresourcew"
                },
                "references": {
                    "sentences": [
                        "The malware calls WNetOpenEnumW to retrieve an enumeration handle for all network resources and WNetEnumResourceW to enumerate through them."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x44b7e41>",
                    "type": "UnknownWord",
                    "value": "connectable"
                },
                "references": {
                    "sentences": [
                        "If the resource is just a normal and connectable directory, the malware passes it into a recursive function to traverse it, which will be discussed in the Drives Traversal section."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x77a69f79>",
                    "type": "UnknownWord",
                    "value": "recursive"
                },
                "references": {
                    "sentences": [
                        "If the resource is just a normal and connectable directory, the malware passes it into a recursive function to traverse it, which will be discussed in the Drives Traversal section."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe41c76b6>",
                    "type": "UnknownWord",
                    "value": "traversing"
                },
                "references": {
                    "sentences": [
                        "Figure 33: Traversing All Mounted Drives.",
                        "Figure 30: Recursively Traversing All Sub-Directories.",
                        "Figure 24: Traversing Network Resources.",
                        "When traversing a drive, ROOK builds the following drive path."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x92e16214>",
                    "type": "UnknownWord",
                    "value": "comma"
                },
                "references": {
                    "sentences": [
                        "The argument can come in the form of a list of paths, each separated by a comma. Instead of a normal directory path, ROOK also accepts a two-character string of a drive letter followed by a colon as a path to a drive."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfd9ccd47>",
                    "type": "UnknownWord",
                    "value": "two-character"
                },
                "references": {
                    "sentences": [
                        "The argument can come in the form of a list of paths, each separated by a comma. Instead of a normal directory path, ROOK also accepts a two-character string of a drive letter followed by a colon as a path to a drive."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x167e0321>",
                    "type": "UnknownWord",
                    "value": "wnetgetconnectionw"
                },
                "references": {
                    "sentences": [
                        "If the drive type is a remote drive, ROOK calls WNetGetConnectionW to retrieve the remote name of the drive and passes it to be traversed by the recursive_traverse_dir function."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd8c5f550>",
                    "type": "UnknownWord",
                    "value": "recursive_traverse_dir"
                },
                "references": {
                    "sentences": [
                        "For each sub-directory found, the malware checks if the filename is not in the list of files and directories to avoid. If its not, the sub-directory full path is constructed and passed back to recursive_traverse_dir to be recursively traversed.",
                        "If the drive type is a remote drive, ROOK calls WNetGetConnectionW to retrieve the remote name of the drive and passes it to be traversed by the recursive_traverse_dir function.",
                        "If the drive type is not remote drive and CD-ROM drive, the malware simply passes it to the recursive_traverse_dir function.",
                        "In the recursive_traverse_dir function, ROOK begins by executing two nested while loop. The first one loops and waits until the END_ACCESS_DIR_SEMAPHORE semaphores count is reduced to zero, and its state is nonsignaled. When this happens, it means every directory in the global directory list is already traversed and no thread is extracting from it."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x13384480>",
                    "type": "UnknownWord",
                    "value": "nested"
                },
                "references": {
                    "sentences": [
                        "First, it enters a nested while loop like the one we have seen earlier. The first loop waits until the BEGIN_ACCESS_DIR_SEMAPHORE semaphore enters a nonsignaled state, which means no thread is adding to the directory list.",
                        "While waiting for that, ROOK efficiently waits to retrieve access to the global file list, extract a file, and encrypts it similar to the previous nested while loop.",
                        "ROOK also skips the file if its extension is .exe, .dll, or .Rook. After checking, the malware enters a nested while loop to wait until no thread can add to the global file list and extracts files to encrypt during the wait time.",
                        "In the recursive_traverse_dir function, ROOK begins by executing two nested while loop. The first one loops and waits until the END_ACCESS_DIR_SEMAPHORE semaphores count is reduced to zero, and its state is nonsignaled. When this happens, it means every directory in the global directory list is already traversed and no thread is extracting from it."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb9ac1c0f>",
                    "type": "UnknownWord",
                    "value": "end_access_dir_semaphore"
                },
                "references": {
                    "sentences": [
                        "In the recursive_traverse_dir function, ROOK begins by executing two nested while loop. The first one loops and waits until the END_ACCESS_DIR_SEMAPHORE semaphores count is reduced to zero, and its state is nonsignaled. When this happens, it means every directory in the global directory list is already traversed and no thread is extracting from it."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x21f19c18>",
                    "type": "UnknownWord",
                    "value": "nonsignaled"
                },
                "references": {
                    "sentences": [
                        "First, it enters a nested while loop like the one we have seen earlier. The first loop waits until the BEGIN_ACCESS_DIR_SEMAPHORE semaphore enters a nonsignaled state, which means no thread is adding to the directory list.",
                        "In the recursive_traverse_dir function, ROOK begins by executing two nested while loop. The first one loops and waits until the END_ACCESS_DIR_SEMAPHORE semaphores count is reduced to zero, and its state is nonsignaled. When this happens, it means every directory in the global directory list is already traversed and no thread is extracting from it."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1b0f6350>",
                    "type": "UnknownWord",
                    "value": "waiting"
                },
                "references": {
                    "sentences": [
                        "While waiting for this, the inner while loop waits until the BEGIN_ACCESS_FILE_SEMAPHORE semaphore is signaled, which allows the current process to access the global file list. After obtaining the ownership of the critical section for the global file list using EnterCriticalSection, ROOK extracts the file at the current index, increments the index, and encrypts it. The file encryption routine is later discussed at the File Encryption section.",
                        "Figure 27: Waiting for Directory List to Be Cleared & Encrypting File in the Meantime.",
                        "While waiting for that, ROOK efficiently waits to retrieve access to the global file list, extract a file, and encrypts it similar to the previous nested while loop.",
                        "Instead of just looping and waiting for the directory list to be cleared, ROOK extracts and encrypts files in the global file list during the wait time to increase efficiency and avoids wasting computing resources. This makes the overall enumeration and encryption process quite fast.",
                        "Figure 36: Waiting for Global Directory List Access."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3c10b3b5>",
                    "type": "UnknownWord",
                    "value": "begin_access_file_semaphore"
                },
                "references": {
                    "sentences": [
                        "While waiting for this, the inner while loop waits until the BEGIN_ACCESS_FILE_SEMAPHORE semaphore is signaled, which allows the current process to access the global file list. After obtaining the ownership of the critical section for the global file list using EnterCriticalSection, ROOK extracts the file at the current index, increments the index, and encrypts it. The file encryption routine is later discussed at the File Encryption section."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3293ee27>",
                    "type": "UnknownWord",
                    "value": "semaphore"
                },
                "references": {
                    "sentences": [
                        "Next, the malware calls EnterCriticalSection to obtain the ownership of the global directory list and adds the directory path to be traversed in. Then, it calls ReleaseSemaphore to release the BEGIN_ACCESS_DIR_SEMAPHORE semaphore, which increments its count by one and signals other threads that another directory is available to be enumerated.",
                        "First, it enters a nested while loop like the one we have seen earlier. The first loop waits until the BEGIN_ACCESS_DIR_SEMAPHORE semaphore enters a nonsignaled state, which means no thread is adding to the directory list.",
                        "While waiting for this, the inner while loop waits until the BEGIN_ACCESS_FILE_SEMAPHORE semaphore is signaled, which allows the current process to access the global file list. After obtaining the ownership of the critical section for the global file list using EnterCriticalSection, ROOK extracts the file at the current index, increments the index, and encrypts it. The file encryption routine is later discussed at the File Encryption section."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd70da80b>",
                    "type": "UnknownWord",
                    "value": "signaled"
                },
                "references": {
                    "sentences": [
                        "While waiting for this, the inner while loop waits until the BEGIN_ACCESS_FILE_SEMAPHORE semaphore is signaled, which allows the current process to access the global file list. After obtaining the ownership of the critical section for the global file list using EnterCriticalSection, ROOK extracts the file at the current index, increments the index, and encrypts it. The file encryption routine is later discussed at the File Encryption section."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x73504a6a>",
                    "type": "UnknownWord",
                    "value": "entercriticalsection"
                },
                "references": {
                    "sentences": [
                        "After getting access to the file list, ROOK calls EnterCriticalSection to obtain the ownership of the file lists critical section and<crlf>adds the subfile to the list.",
                        "Next, the malware calls EnterCriticalSection to obtain the ownership of the global directory list and adds the directory path to be traversed in. Then, it calls ReleaseSemaphore to release the BEGIN_ACCESS_DIR_SEMAPHORE semaphore, which increments its count by one and signals other threads that another directory is available to be enumerated.",
                        "While waiting for this, the inner while loop waits until the BEGIN_ACCESS_FILE_SEMAPHORE semaphore is signaled, which allows the current process to access the global file list. After obtaining the ownership of the critical section for the global file list using EnterCriticalSection, ROOK extracts the file at the current index, increments the index, and encrypts it. The file encryption routine is later discussed at the File Encryption section."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x26fd929>",
                    "type": "UnknownWord",
                    "value": "increments"
                },
                "references": {
                    "sentences": [
                        "While waiting for this, the inner while loop waits until the BEGIN_ACCESS_FILE_SEMAPHORE semaphore is signaled, which allows the current process to access the global file list. After obtaining the ownership of the critical section for the global file list using EnterCriticalSection, ROOK extracts the file at the current index, increments the index, and encrypts it. The file encryption routine is later discussed at the File Encryption section.",
                        "Next, the malware calls EnterCriticalSection to obtain the ownership of the global directory list and adds the directory path to be traversed in. Then, it calls ReleaseSemaphore to release the BEGIN_ACCESS_DIR_SEMAPHORE semaphore, which increments its count by one and signals other threads that another directory is available to be enumerated."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb55ddce5>",
                    "type": "UnknownWord",
                    "value": "meantime"
                },
                "references": {
                    "sentences": [
                        "Figure 27: Waiting for Directory List to Be Cleared & Encrypting File in the Meantime."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xccc85045>",
                    "type": "UnknownWord",
                    "value": "looping"
                },
                "references": {
                    "sentences": [
                        "Instead of just looping and waiting for the directory list to be cleared, ROOK extracts and encrypts files in the global file list during the wait time to increase efficiency and avoids wasting computing resources. This makes the overall enumeration and encryption process quite fast."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x114d8a7a>",
                    "type": "UnknownWord",
                    "value": "efficiency"
                },
                "references": {
                    "sentences": [
                        "Instead of just looping and waiting for the directory list to be cleared, ROOK extracts and encrypts files in the global file list during the wait time to increase efficiency and avoids wasting computing resources. This makes the overall enumeration and encryption process quite fast."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc61c7b6>",
                    "type": "UnknownWord",
                    "value": "wasting"
                },
                "references": {
                    "sentences": [
                        "Instead of just looping and waiting for the directory list to be cleared, ROOK extracts and encrypts files in the global file list during the wait time to increase efficiency and avoids wasting computing resources. This makes the overall enumeration and encryption process quite fast."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd131d5b3>",
                    "type": "UnknownWord",
                    "value": "releasesemaphore"
                },
                "references": {
                    "sentences": [
                        "Next, the malware calls EnterCriticalSection to obtain the ownership of the global directory list and adds the directory path to be traversed in. Then, it calls ReleaseSemaphore to release the BEGIN_ACCESS_DIR_SEMAPHORE semaphore, which increments its count by one and signals other threads that another directory is available to be enumerated."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5cc2ac9c>",
                    "type": "UnknownWord",
                    "value": "begin_access_dir_semaphore"
                },
                "references": {
                    "sentences": [
                        "First, it enters a nested while loop like the one we have seen earlier. The first loop waits until the BEGIN_ACCESS_DIR_SEMAPHORE semaphore enters a nonsignaled state, which means no thread is adding to the directory list.",
                        "Next, the malware calls EnterCriticalSection to obtain the ownership of the global directory list and adds the directory path to be traversed in. Then, it calls ReleaseSemaphore to release the BEGIN_ACCESS_DIR_SEMAPHORE semaphore, which increments its count by one and signals other threads that another directory is available to be enumerated."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6d1b36e3>",
                    "type": "UnknownWord",
                    "value": "signals"
                },
                "references": {
                    "sentences": [
                        "Next, the malware calls EnterCriticalSection to obtain the ownership of the global directory list and adds the directory path to be traversed in. Then, it calls ReleaseSemaphore to release the BEGIN_ACCESS_DIR_SEMAPHORE semaphore, which increments its count by one and signals other threads that another directory is available to be enumerated."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4f1e62>",
                    "type": "UnknownWord",
                    "value": "signaling"
                },
                "references": {
                    "sentences": [
                        "Figure 28: Adding Directory to Global List & Signaling for Enumeration."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9a257c4c>",
                    "type": "UnknownWord",
                    "value": "findfirstfilew"
                },
                "references": {
                    "sentences": [
                        "Then, the function begins enumerating the directory for all its sub-directories. ROOK builds the path **\\\\\\*\"** and passes it to **FindFirstFileW** to start the enumeration.",
                        "Next, it builds the path **\\\\*\"** and passes it to **FindFirstFileW** to begin enumerating through files in the directory."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8ee8d34e>",
                    "type": "UnknownWord",
                    "value": "sub-directory"
                },
                "references": {
                    "sentences": [
                        "For each sub-directory found, the malware checks if the filename is not in the list of files and directories to avoid. If its not, the sub-directory full path is constructed and passed back to recursive_traverse_dir to be recursively traversed."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2671a467>",
                    "type": "UnknownWord",
                    "value": "constructed"
                },
                "references": {
                    "sentences": [
                        "For each sub-directory found, the malware checks if the filename is not in the list of files and directories to avoid. If its not, the sub-directory full path is constructed and passed back to recursive_traverse_dir to be recursively traversed."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9b8a6287>",
                    "type": "UnknownWord",
                    "value": "manually"
                },
                "references": {
                    "sentences": [
                        "If the command-line argument -paths is not provided, ROOK manually mounts all drives that have no volume mounted and traverses through all of them."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb82b413e>",
                    "type": "UnknownWord",
                    "value": "drive_no_root_dir"
                },
                "references": {
                    "sentences": [
                        "First, it builds a list of all drive letters and iterates through it to find drives with type DRIVE_NO_ROOT_DIR. Those drives are then added to the end of the list."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x93690684>",
                    "type": "UnknownWord",
                    "value": "findfirstvolumew"
                },
                "references": {
                    "sentences": [
                        "Next, ROOK calls FindFirstVolumeW and FindNextVolumeW to scan for available volumes in the system. For each volume, the malware calls GetVolumePathNamesForVolumeNameW to retrieve the volume GUID path and SetVolumeMountPointW to set the path as the root path for the next no-root drive in the list."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd6bebdab>",
                    "type": "UnknownWord",
                    "value": "findnextvolumew"
                },
                "references": {
                    "sentences": [
                        "Next, ROOK calls FindFirstVolumeW and FindNextVolumeW to scan for available volumes in the system. For each volume, the malware calls GetVolumePathNamesForVolumeNameW to retrieve the volume GUID path and SetVolumeMountPointW to set the path as the root path for the next no-root drive in the list."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd92bcbc1>",
                    "type": "UnknownWord",
                    "value": "getvolumepathnamesforvolumenamew"
                },
                "references": {
                    "sentences": [
                        "Next, ROOK calls FindFirstVolumeW and FindNextVolumeW to scan for available volumes in the system. For each volume, the malware calls GetVolumePathNamesForVolumeNameW to retrieve the volume GUID path and SetVolumeMountPointW to set the path as the root path for the next no-root drive in the list."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc182cf33>",
                    "type": "UnknownWord",
                    "value": "setvolumemountpointw"
                },
                "references": {
                    "sentences": [
                        "Next, ROOK calls FindFirstVolumeW and FindNextVolumeW to scan for available volumes in the system. For each volume, the malware calls GetVolumePathNamesForVolumeNameW to retrieve the volume GUID path and SetVolumeMountPointW to set the path as the root path for the next no-root drive in the list."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x35281bf4>",
                    "type": "UnknownWord",
                    "value": "no-root"
                },
                "references": {
                    "sentences": [
                        "Next, ROOK calls FindFirstVolumeW and FindNextVolumeW to scan for available volumes in the system. For each volume, the malware calls GetVolumePathNamesForVolumeNameW to retrieve the volume GUID path and SetVolumeMountPointW to set the path as the root path for the next no-root drive in the list."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6ec8b3ee>",
                    "type": "UnknownWord",
                    "value": "unmounted"
                },
                "references": {
                    "sentences": [
                        "Figure 32: Mounting All Unmounted Drives."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd0023556>",
                    "type": "UnknownWord",
                    "value": "getlogicaldrives"
                },
                "references": {
                    "sentences": [
                        "Finally, the malware calls GetLogicalDrives to iterate through all the drives in the system and traverse them."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7168b3f6>",
                    "type": "UnknownWord",
                    "value": "iterate"
                },
                "references": {
                    "sentences": [
                        "Finally, the malware calls GetLogicalDrives to iterate through all the drives in the system and traverse them."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbb07aca4>",
                    "type": "UnknownWord",
                    "value": "traverse"
                },
                "references": {
                    "sentences": [
                        "Finally, the malware calls GetLogicalDrives to iterate through all the drives in the system and traverse them."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x802d52b5>",
                    "type": "UnknownWord",
                    "value": "efficiently"
                },
                "references": {
                    "sentences": [
                        "While waiting for that, ROOK efficiently waits to retrieve access to the global file list, extract a file, and encrypts it similar to the previous nested while loop."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc685bbae>",
                    "type": "UnknownWord",
                    "value": "sub-files"
                },
                "references": {
                    "sentences": [
                        "Figure 37: Extracting Directory & Enumerating for Sub-Files.",
                        "After the directory list is full, the malware obtains ownership of the lists critical section, extracts a directory out, and begins traversing it for sub-files."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3a8585f9>",
                    "type": "UnknownWord",
                    "value": "writefile"
                },
                "references": {
                    "sentences": [
                        "For the enumeration, ROOK first builds a path to a ransom note file in the directory, calls CreateFileW to create it and WriteFile to write the ransom note content to it."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3dcb881a>",
                    "type": "UnknownWord",
                    "value": "subfile"
                },
                "references": {
                    "sentences": [
                        "After getting access to the file list, ROOK calls EnterCriticalSection to obtain the ownership of the file lists critical section and<crlf>adds the subfile to the list.",
                        "Figure 41: Adding Subfile to Global File List."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdae9b70b>",
                    "type": "UnknownWord",
                    "value": "setfileattributesw"
                },
                "references": {
                    "sentences": [
                        "Prior to file encryption, ROOK calls SetFileAttributesW to set the file attribute to normal."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x53c02b26>",
                    "type": "UnknownWord",
                    "value": "movefileexw"
                },
                "references": {
                    "sentences": [
                        "It builds the following path **.Rook\"** and calls **MoveFileExW** to change the file name to have the encrypted extension **.Rook**."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc9dfa9e>",
                    "type": "UnknownWord",
                    "value": "16-byte"
                },
                "references": {
                    "sentences": [
                        "First, it uses the Mbed TLS CTR_DRBG context to generates a random 16-byte AES key."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1705d2ec>",
                    "type": "UnknownWord",
                    "value": "populates"
                },
                "references": {
                    "sentences": [
                        "Next, ROOK populates the following structures for the file footer."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2e9b4a61>",
                    "type": "UnknownWord",
                    "value": "getfilesizeex"
                },
                "references": {
                    "sentences": [
                        "The malware begins by calling GetFileSizeEx to retrieve the size of the file and store it in the file footer. It then uses the victims RSA public key to encrypt the AES key and store it in the metadatas AES_key_encrypted_by_my_public field."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc362010a>",
                    "type": "UnknownWord",
                    "value": "aes_key_encrypted_by_my_public"
                },
                "references": {
                    "sentences": [
                        "The malware begins by calling GetFileSizeEx to retrieve the size of the file and store it in the file footer. It then uses the victims RSA public key to encrypt the AES key and store it in the metadatas AES_key_encrypted_by_my_public field."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdf573583>",
                    "type": "UnknownWord",
                    "value": "my_private_key_encrypted_by_rook_public"
                },
                "references": {
                    "sentences": [
                        "Next, it copies the victims private key that is encrypted using ROOKs public key during RSA Key Generation into the metadatas my_private_key_encrypted_by_Rook_public field."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2569fe50>",
                    "type": "UnknownWord",
                    "value": "greater"
                },
                "references": {
                    "sentences": [
                        "If the file size is greater than 0x80000 bytes, the malware reads and encrypts at most three 0x80000-byte chunks at the beginning of the file using AES-128 ECB."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8c58ebd3>",
                    "type": "UnknownWord",
                    "value": "0x80000-byte"
                },
                "references": {
                    "sentences": [
                        "If the file size is greater than 0x80000 bytes, the malware reads and encrypts at most three 0x80000-byte chunks at the beginning of the file using AES-128 ECB."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x72b3a031>",
                    "type": "UnknownWord",
                    "value": "chunks"
                },
                "references": {
                    "sentences": [
                        "If the file size is greater than 0x80000 bytes, the malware reads and encrypts at most three 0x80000-byte chunks at the beginning of the file using AES-128 ECB."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd486de54>",
                    "type": "UnknownWord",
                    "value": "aes-128"
                },
                "references": {
                    "sentences": [
                        "If the file size is greater than 0x80000 bytes, the malware reads and encrypts at most three 0x80000-byte chunks at the beginning of the file using AES-128 ECB."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x763a5c51>",
                    "type": "UnknownWord",
                    "value": "ecb"
                },
                "references": {
                    "sentences": [
                        "If the file size is greater than 0x80000 bytes, the malware reads and encrypts at most three 0x80000-byte chunks at the beginning of the file using AES-128 ECB."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x51580b83>",
                    "type": "UnknownWord",
                    "value": "larger"
                },
                "references": {
                    "sentences": [
                        "Figure 47: Encrypting Files Larger Than 0x80000 Bytes."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xaf6c224a>",
                    "type": "UnknownWord",
                    "value": "calculating"
                },
                "references": {
                    "sentences": [
                        "Figure 48: Calculating & Encrypting the Last Chunk That Is Less Than 0x80000 Bytes."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x811dbb26>",
                    "type": "UnknownWord",
                    "value": "chunk"
                },
                "references": {
                    "sentences": [
                        "Figure 48: Calculating & Encrypting the Last Chunk That Is Less Than 0x80000 Bytes."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7e328e5f>",
                    "type": "UnknownWord",
                    "value": "rmstartsession"
                },
                "references": {
                    "sentences": [
                        "It first calls RmStartSession to starts a new Restart Manager session and WideCharToMultiByte to convert the file path to a multibyte buffer."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x380578a7>",
                    "type": "UnknownWord",
                    "value": "widechartomultibyte"
                },
                "references": {
                    "sentences": [
                        "It first calls RmStartSession to starts a new Restart Manager session and WideCharToMultiByte to convert the file path to a multibyte buffer."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb04924d4>",
                    "type": "UnknownWord",
                    "value": "multibyte"
                },
                "references": {
                    "sentences": [
                        "It first calls RmStartSession to starts a new Restart Manager session and WideCharToMultiByte to convert the file path to a multibyte buffer."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x33c0b318>",
                    "type": "UnknownWord",
                    "value": "rmregisterresources"
                },
                "references": {
                    "sentences": [
                        "Using that session handle, the malware calls RmRegisterResources to register the target file as a resource to the RM."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x79b2924f>",
                    "type": "UnknownWord",
                    "value": "registering"
                },
                "references": {
                    "sentences": [
                        "Figure 51: Registering Target File as a Resource."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbc24ad5a>",
                    "type": "UnknownWord",
                    "value": "rmgetlist"
                },
                "references": {
                    "sentences": [
                        "Next, it calls RmGetList to get a list of all applications that are using the file. For each of these applications, if the applications type is Windows Explorer or a critical process, it is skipped."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x89feb17b>",
                    "type": "UnknownWord",
                    "value": "skipped"
                },
                "references": {
                    "sentences": [
                        "Next, it calls RmGetList to get a list of all applications that are using the file. For each of these applications, if the applications type is Windows Explorer or a critical process, it is skipped."
                    ],
                    "titles": []
                }
            }
        ]
    },
    "other_links": [],
    "info": {
        "potential_threats": {},
        "sigma": false,
        "yara": false
    },
    "keywords": {
        "classified": [],
        "dubbed": [],
        "associated": [],
        "targets": [],
        "attributed": [
            "Alternate Data Streams (ADS) is a file attribute on the NT File System (NTFS) which was designed for compatibility with Macintosh Hierarchical File System (HFS).",
            "Prior to file encryption, ROOK calls SetFileAttributesW to set the file attribute to normal."
        ]
    },
    "resources": {
        "links": {
            "github": [
                "https://github.com/ARMmbed/mbedtls"
            ],
            "pastebin": [],
            "text_files": [],
            "other": [
                "https://chuongdong.com/categories/#reverse%20engineering",
                "https://bazaar.abuse.ch/sample/c2d46d256b8f9490c9599eea11ecef19fde7d4fdd2dea93604cee3cea8e172ac/",
                "https://tls.mbed.org/api/structmbedtls__ctr__drbg__context.html",
                "https://tls.mbed.org/api/ctr__drbg_8h.html",
                "https://tls.mbed.org/api/pk_8h.html#ade680bf8e87df7ccc3bb36b52e43972b",
                "https://twitter.com/intent/tweet/?url=https://cdong1012.github.io//reverse%20engineering/2022/01/06/RookRansomware/&text=Rook%20Ransomware&via=cPeterr",
                "https://facebook.com/sharer/sharer.php?u=https://cdong1012.github.io//reverse%20engineering/2022/01/06/RookRansomware/",
                "mailto:?subject=Rook%20Ransomware&body=Hey,%20check%20out%20this:%20https://cdong1012.github.io//reverse%20engineering/2022/01/06/RookRansomware/"
            ]
        },
        "images": [
            "https://chuongdong.com/uploads/rook01.PNG",
            "https://chuongdong.com/uploads/rook02.PNG",
            "https://chuongdong.com/uploads/rook03.PNG",
            "https://chuongdong.com/uploads/rook04.PNG",
            "https://chuongdong.com/uploads/rook05.PNG",
            "https://chuongdong.com/uploads/rook06.PNG",
            "https://chuongdong.com/uploads/rook07.PNG",
            "https://chuongdong.com/uploads/rook08.PNG",
            "https://chuongdong.com/uploads/rook09.PNG",
            "https://chuongdong.com/uploads/rook10.PNG",
            "https://chuongdong.com/uploads/rook11.PNG",
            "https://chuongdong.com/uploads/rook12.PNG",
            "https://chuongdong.com/uploads/rook13.PNG",
            "https://chuongdong.com/uploads/rook14.PNG",
            "https://chuongdong.com/uploads/rook15.PNG",
            "https://chuongdong.com/uploads/rook16.PNG",
            "https://chuongdong.com/uploads/rook17.PNG",
            "https://chuongdong.com/uploads/rook18.PNG",
            "https://chuongdong.com/uploads/rook19.PNG",
            "https://chuongdong.com/uploads/rook20.PNG",
            "https://chuongdong.com/uploads/rook21.PNG",
            "https://chuongdong.com/uploads/rook22.PNG",
            "https://chuongdong.com/uploads/rook23.PNG",
            "https://chuongdong.com/uploads/rook24.PNG",
            "https://chuongdong.com/uploads/rook25.PNG",
            "https://chuongdong.com/uploads/rook27.PNG",
            "https://chuongdong.com/uploads/rook28.PNG",
            "https://chuongdong.com/uploads/rook29.PNG",
            "https://chuongdong.com/uploads/rook30.PNG",
            "https://chuongdong.com/uploads/rook31.PNG",
            "https://chuongdong.com/uploads/rook32.PNG",
            "https://chuongdong.com/uploads/rook33.PNG",
            "https://chuongdong.com/uploads/rook36.PNG",
            "https://chuongdong.com/uploads/rook37.PNG",
            "https://chuongdong.com/uploads/rook38.PNG",
            "https://chuongdong.com/uploads/rook39.PNG",
            "https://chuongdong.com/uploads/rook40.PNG",
            "https://chuongdong.com/uploads/rook41.PNG",
            "https://chuongdong.com/uploads/rook42.PNG",
            "https://chuongdong.com/uploads/rook43.PNG",
            "https://chuongdong.com/uploads/rook44.PNG",
            "https://chuongdong.com/uploads/rook45.PNG",
            "https://chuongdong.com/uploads/rook46.PNG",
            "https://chuongdong.com/uploads/rook47.PNG",
            "https://chuongdong.com/uploads/rook48.PNG",
            "https://chuongdong.com/uploads/rook49.PNG",
            "https://chuongdong.com/uploads/rook50.PNG",
            "https://chuongdong.com/uploads/rook51.PNG",
            "https://chuongdong.com/uploads/rook52.PNG",
            "https://chuongdong.com/uploads/rook53.PNG"
        ]
    }
}