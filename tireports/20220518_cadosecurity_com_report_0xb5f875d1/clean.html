<div>
<p>Introduction</p>
<p>Linux has long dominated the server computing landscape, and the rapid adoption of cloud technologies by organisations around the world has only contributed to this. As a result, many recent high-profile malware campaigns have targeted Linux servers (often in cloud environments) and used them to illicitly mine cryptocurrency, conduct denial of service (DoS) attacks, steal sensitive data and carry out other nefarious activities.</p>
<p>At Cado Labs, we regularly analyse malware campaigns targeting Linux and have decided to document some common and not-so-common attack techniques observed in these campaigns. We hope this will help defenders identify and mitigate these techniques in their Linux environments. In this blog we’re going to analyse a common method of execution flow hijacking on Linux: dynamic linker hijacking.</p>
<p></p>
<p>Background on Dynamic Linker Hijacking</p>
<p>Dynamic linking, a feature present in virtually all modern operating systems, allows certain commonly-used libraries (referred to as shared objects in Linux, dylibs in macOS, and Dynamic Linked Libraries/DLLs in Windows) to be loaded by an application at runtime. When a developer compiles an executable, they specify which libraries should be loaded and the operating system’s linker retrieves these and loads them when the application is launched. This allows the code contained within the libraries to be shared across applications and saves the developer writing this code and shipping it themselves. </p>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-5203" height="716" src="https://www.cadosecurity.com/wp-content/uploads/image3-8.png" style="max-width:800px;height:auto;width:auto;" width="1684"/><figcaption>Example of shared libraries loaded by the ls command 
</figcaption></figure>
<p>Typical examples of shared libraries include things like compression and cryptographic libraries, features which are commonly used by applications but are difficult and time-consuming to implement – after all, why reinvent the wheel? </p>
<p>However, if we think like an attacker, shared libraries present an opportunity to hijack the execution flow of an application and run malicious code in the context of a legitimate process. Generally, dynamic linker hijacking involves tricking the dynamic linker into loading a malicious library implanted by the attacker. </p>
<p>This can be used to supplement existing payloads by implementing features like process hiding, as we’ll discuss later. It also brings stealth benefits to a malware campaign and although many modern operating systems are hardened to prevent arbitrary libraries from being loaded, this is still a highly-effective technique and one which is often seen in the wild.</p>
<p></p>
<p>Using Linux’s LD Preload Feature for Dynamic Linker Hijacking</p>
<p>In Linux, the dynamic linkers are referred to as ld.so and ld-linux.so. The latter is commonly used in contemporary Linux distributions as it handles dynamic linking for executables in the ELF binary format – the current default format on Linux. 
A number of environment variables (envars) can be used during the execution of the dynamic linker, the most important of which (for our purposes) is LD_PRELOAD. From the ld.so <a href="https://man7.org/linux/man-pages/man8/ld.so.8.html">man page</a>:</p>
<p></p>
<p>[LD_PRELOAD is…] A list of additional, user-specified, ELF shared objects</p>
<p> to be loaded before all others. This feature can be used to selectively override </p>
<p>functions in other shared objects.</p>
<p></p>
<p>Essentially, this means that shortly after invocation, the dynamic linker will read the contents of $LD_PRELOAD and load any shared objects located at paths defined in the envar before any other (potentially benign) shared objects are loaded. Since it’s easy for a malicious shell script or other executable to set the value of LD_PRELOAD, you can see how this could be leveraged by malware to run additional payloads.</p>
<p>
The LD_PRELOAD envar is not the only place where users can specify shared objects to be loaded first. The dynamic linker also consults the file /etc/ld.so.preload which can also contain user-specified paths to shared objects. In the case that paths are defined both in the envar and in this file, the envar takes precedence. Additionally, the ld.so.preload file causes a system-wide configuration change, resulting in shared objects being preloaded by any binary on the system.</p>
<p></p>
<p>Linux Dynamic Linker Hijacking in Action</p>
<p>Dynamic linker hijacking is often utilised by Linux malware to install rootkits on the target system. One popular open source rootkit is <a href="https://github.com/gianlucaborello/libprocesshider">libprocesshider.so</a>. As the name suggests, libprocesshider is used to hide processes from Linux performance monitoring tools, such as top, ps, lsof and so on. It achieves this by hooking syscalls used for enumerating the /proc/&lt;PID&gt; directories and preventing them from doing so (more info <a href="https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/">here</a>). Naturally, this is desirable for virtually all categories of malware, as malicious processes may be able to execute unimpeded if they are undetectable by the bundled monitoring tools. </p>
<p>In order to hook the appropriate syscall, the library needs to be loaded first… In steps the dynamic linker’s LD Preload feature! </p>
<p>To demonstrate this in action, we examined a recent <a href="https://www.virustotal.com/gui/file/53047c6f255ceee5ec989d73a36fa97ac6035325ea1a81e959b585220188fd11">sample</a> of cryptomining malware:</p>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-5204" height="1138" src="https://www.cadosecurity.com/wp-content/uploads/image2-8.png" style="max-width:800px;height:auto;width:auto;" width="1999"/></figure>
<p>As can be seen on lines 18 – 20, a function named hide first uses sed to remove any lines containing ‘libprocesshider’ from the /etc/ld.so.preload file. A path containing the compiled libprocesshider shared object (library) is then added back into the ld.so.preload file to ensure that it’s loaded correctly. </p>
<p>According to the libprocesshider documentation, once the path to libprocesshider is added to LD_PRELOAD or the ld.so.preload file, the specified executable will first load libprocesshider and details of the process will be hidden from process monitoring tools. </p>
<p>Further down the script, we can see the hide function being invoked:</p>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-5205" height="971" src="https://www.cadosecurity.com/wp-content/uploads/image1-11.png" style="max-width:800px;height:auto;width:auto;" width="1999"/><figcaption>Line 214: invocation of the hide() function
</figcaption></figure>
<p>If you examine lines 211 to 214 in the screenshot above, you’ll see a file at the path /var/tmp/java_c/java_c is executed prior to the hide function being invoked. Despite the name, this is the binary for the XMRig Monero mining software, commonly seen in cryptojacking campaigns. </p>
<p>Once the hide function is invoked, the miner process is hidden – as the process name is hardcoded in the version of libprocesshider.so that the script downloads. This means that although the miner is likely executing with high utilisation of system resources (something that would typically draw attention) this would be near-impossible for an administrator to identify using system monitoring tools alone. </p>
<p>As a result, the miner executes uninterrupted and successfully generates profits for the malware developer.</p>
<p></p>
<p>How to Detect Dynamic Linker Hijacking in your Environment</p>
<p>Although effective, fortunately this technique is relatively easy to detect on Linux. To check the contents of the LD_PRELOAD envar, the export command can be used. If you suspect your system has been compromised and this envar is set then it’s likely that a malicious library has been used. The unset command can be used to delete the value of the envar and reveal the malware if a process hiding library was used. </p>
<p>Similarly, the /etc/ld.so.preload file shouldn’t exist in a vanilla installation of Linux. If this file exists and it contains paths to arbitrary executables, this is again indicative of malicious libraries being used. Simply delete the file to prevent the libraries being loaded in future and remove the libraries themselves. </p>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-5206" height="699" src="https://www.cadosecurity.com/wp-content/uploads/image4-8.png" style="max-width:800px;height:auto;width:auto;" width="1690"/><figcaption>Cado Response Screenshot demonstrating dynamic linker hijacking attempt
</figcaption></figure>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-5207" height="774" src="https://www.cadosecurity.com/wp-content/uploads/Screen-Shot-2022-05-17-at-3.08.55-PM.png" style="max-width:800px;height:auto;width:auto;" width="1200"/></figure>
<p></p>
<p>Indicators of Compromise</p>
<figure class="wp-block-table"><table><tbody><tr><td>Filename</td><td>SHA256</td></tr><tr><td>p.sh (shell script used in example)</td><td>53047c6f255ceee5ec989d73a36fa97ac6035325ea1a81e959b585220188fd11</td></tr><tr><td>libprocesshider.so (hash is specific to example)</td><td>0e6d37099dd89c7eed44063420bd05a2d7b0865a0f690e12457fbec68f9b67a8</td></tr></tbody></table></figure>
About The Author
<img alt="" class="avia-img-lazy-loading-4401 attachment-full size-full" height="218" src="https://www.cadosecurity.com/wp-content/uploads/Screen-Shot-2022-01-07-at-11.27.32-AM.png" width="214"/> 
										Matt Muir									
										Matt is a security researcher with a passion for UNIX and UNIX-like operating systems. He previously worked as a macOS malware analyst and his background includes experience in the areas of digital forensics, DevOps, and operational cyber security. Matt enjoys technical writing and has published research including pieces on TOR browser forensics, an emerging cloud-focused botnet, and the exploitation of the Log4Shell vulnerability.									
<h4 class="av-special-heading-tag">About Cado Security</h4>
<p>Cado Security provides the cloud investigation platform that empowers security teams to respond to threats at cloud speed. By automating data capture and processing across cloud and container environments, Cado Response effortlessly delivers forensic-level detail and unprecedented context to simplify cloud investigation and response. Backed by Blossom Capital and Ten Eleven Ventures, Cado Security has offices in the United States and United Kingdom. For more information, please visit <a href="https://www.cadosecurity.com/">https://www.cadosecurity.com/</a> or follow us on Twitter <a href="https://twitter.com/CadoSecurity" rel="noopener noreferrer" target="_blank">@cadosecurity.</a></p>
<a class="prev-button" href="https://www.cadosecurity.com/cado-security-selected-as-top-10-finalist-for-rsa-conference-2022-innovation-sandbox-contest/">Prev Post</a>
</div>