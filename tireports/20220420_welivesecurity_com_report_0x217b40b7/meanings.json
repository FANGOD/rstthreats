{
    "title": "When secure isnt secure at all: Highimpact UEFI vulnerabilities discovered in Lenovo consumer laptops",
    "url": "https://www.welivesecurity.com/2022/04/19/when-secure-isnt-secure-uefi-vulnerabilities-lenovo-consumer-laptops",
    "threats": {
        "Threat": [
            {
                "token": {
                    "id": "<THREAT_0xdfcc115f>",
                    "type": "Threat",
                    "value": "lojax"
                },
                "references": {
                    "sentences": [
                        "All of the real-world UEFI threats discovered in recent years (LoJax, MosaicRegressor, MoonBounce, ESPecter, FinSpy) needed to bypass or disable the security mechanisms in some way in order to be deployed and executed. However, only in the case of LoJax, the first in-the-wild UEFI rootkit (discovered by ESET Research in 2018), do we have a clue how it was done by using the ReWriter_binary capable of exploiting the Speed Racer vulnerability.",
                        "This memory is not affected by operating system reinstallation and therefore presents a tempting target for threat actors deploying their implants as was the case of LoJax, MosaicRegressor, and MoonBounce.",
                        "When set, the BIOS region is not writable unless all processors are in SMM and BIOSWE is 1. Setting this bit resolves the Speed Racer race condition vulnerability (an exploit for this vulnerability was present in the ReWriter_binary tool, which was used by the Sednit group to deploy LoJax).",
                        "ESET researchers have discovered and analyzed three vulnerabilities affecting various Lenovo consumer laptop models. The first two of these vulnerabilities CVE-2021-3971, CVE-2021-3972 affect UEFI firmware drivers originally meant to be used only during the manufacturing process of Lenovo consumer notebooks. Unfortunately, they were mistakenly included also in the production BIOS images without being properly deactivated. These affected firmware drivers can be activated by attacker to directly disable SPI flash protections (BIOS Control Register bits and Protected Range registers) or the UEFI Secure Boot feature from a privileged user-mode process during OS runtime. It means that exploitation of these vulnerabilities would allow attackers to deploy and successfully execute SPI flash or ESP implants, like LoJax or our latest UEFI malware discovery ESPecter, on the affected devices."
                    ],
                    "titles": [
                        "BIOS Control Register",
                        "When secure isnt secure at all: Highimpact UEFI vulnerabilities discovered in Lenovo consumer laptops",
                        "Conclusion",
                        "Primary SPI flash protection mechanisms"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<THREAT_0xdfcc115f>",
                            "type": "Threat",
                            "value": "lojax"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xa6e3d324>",
                            "type": "Threat",
                            "value": "finfisher"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0xc1bf3b91>",
                            "type": "Threat",
                            "value": "fancy_bear_group"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xdfcc115f>",
                            "type": "Threat",
                            "value": "lojax"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0xdfcc115f>",
                            "type": "Threat",
                            "value": "lojax"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x4a964398>",
                            "type": "Threat",
                            "value": "especter"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0xdfcc115f>",
                            "type": "Threat",
                            "value": "lojax"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x6ea5281d>",
                            "type": "Threat",
                            "value": "moonbounce"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<THREAT_0x4a964398>",
                    "type": "Threat",
                    "value": "especter"
                },
                "references": {
                    "sentences": [
                        "All of the real-world UEFI threats discovered in recent years (LoJax, MosaicRegressor, MoonBounce, ESPecter, FinSpy) needed to bypass or disable the security mechanisms in some way in order to be deployed and executed. However, only in the case of LoJax, the first in-the-wild UEFI rootkit (discovered by ESET Research in 2018), do we have a clue how it was done by using the ReWriter_binary capable of exploiting the Speed Racer vulnerability.",
                        "ESET researchers have discovered and analyzed three vulnerabilities affecting various Lenovo consumer laptop models. The first two of these vulnerabilities CVE-2021-3971, CVE-2021-3972 affect UEFI firmware drivers originally meant to be used only during the manufacturing process of Lenovo consumer notebooks. Unfortunately, they were mistakenly included also in the production BIOS images without being properly deactivated. These affected firmware drivers can be activated by attacker to directly disable SPI flash protections (BIOS Control Register bits and Protected Range registers) or the UEFI Secure Boot feature from a privileged user-mode process during OS runtime. It means that exploitation of these vulnerabilities would allow attackers to deploy and successfully execute SPI flash or ESP implants, like LoJax or our latest UEFI malware discovery ESPecter, on the affected devices."
                    ],
                    "titles": [
                        "When secure isnt secure at all: Highimpact UEFI vulnerabilities discovered in Lenovo consumer laptops",
                        "Conclusion"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<THREAT_0xdfcc115f>",
                            "type": "Threat",
                            "value": "lojax"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x4a964398>",
                            "type": "Threat",
                            "value": "especter"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x6ea5281d>",
                            "type": "Threat",
                            "value": "moonbounce"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x4a964398>",
                            "type": "Threat",
                            "value": "especter"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x4a964398>",
                            "type": "Threat",
                            "value": "especter"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xa6e3d324>",
                            "type": "Threat",
                            "value": "finfisher"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<THREAT_0x6ea5281d>",
                    "type": "Threat",
                    "value": "moonbounce"
                },
                "references": {
                    "sentences": [
                        "All of the real-world UEFI threats discovered in recent years (LoJax, MosaicRegressor, MoonBounce, ESPecter, FinSpy) needed to bypass or disable the security mechanisms in some way in order to be deployed and executed. However, only in the case of LoJax, the first in-the-wild UEFI rootkit (discovered by ESET Research in 2018), do we have a clue how it was done by using the ReWriter_binary capable of exploiting the Speed Racer vulnerability.",
                        "This memory is not affected by operating system reinstallation and therefore presents a tempting target for threat actors deploying their implants as was the case of LoJax, MosaicRegressor, and MoonBounce."
                    ],
                    "titles": [
                        "Conclusion",
                        "Primary SPI flash protection mechanisms"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<THREAT_0x6ea5281d>",
                            "type": "Threat",
                            "value": "moonbounce"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xa6e3d324>",
                            "type": "Threat",
                            "value": "finfisher"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x6ea5281d>",
                            "type": "Threat",
                            "value": "moonbounce"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x4a964398>",
                            "type": "Threat",
                            "value": "especter"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0xdfcc115f>",
                            "type": "Threat",
                            "value": "lojax"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x6ea5281d>",
                            "type": "Threat",
                            "value": "moonbounce"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<THREAT_0xc1bf3b91>",
                    "type": "Threat",
                    "value": "fancy_bear_group"
                },
                "references": {
                    "sentences": [
                        "When set, the BIOS region is not writable unless all processors are in SMM and BIOSWE is 1. Setting this bit resolves the Speed Racer race condition vulnerability (an exploit for this vulnerability was present in the ReWriter_binary tool, which was used by the Sednit group to deploy LoJax)."
                    ],
                    "titles": [
                        "BIOS Control Register"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<THREAT_0xc1bf3b91>",
                            "type": "Threat",
                            "value": "fancy_bear_group"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xdfcc115f>",
                            "type": "Threat",
                            "value": "lojax"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<THREAT_0xa6e3d324>",
                    "type": "Threat",
                    "value": "finfisher"
                },
                "references": {
                    "sentences": [
                        "All of the real-world UEFI threats discovered in recent years (LoJax, MosaicRegressor, MoonBounce, ESPecter, FinSpy) needed to bypass or disable the security mechanisms in some way in order to be deployed and executed. However, only in the case of LoJax, the first in-the-wild UEFI rootkit (discovered by ESET Research in 2018), do we have a clue how it was done by using the ReWriter_binary capable of exploiting the Speed Racer vulnerability."
                    ],
                    "titles": [
                        "Conclusion"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<THREAT_0x6ea5281d>",
                            "type": "Threat",
                            "value": "moonbounce"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xa6e3d324>",
                            "type": "Threat",
                            "value": "finfisher"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x4a964398>",
                            "type": "Threat",
                            "value": "especter"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xa6e3d324>",
                            "type": "Threat",
                            "value": "finfisher"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0xdfcc115f>",
                            "type": "Threat",
                            "value": "lojax"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xa6e3d324>",
                            "type": "Threat",
                            "value": "finfisher"
                        }
                    }
                ]
            }
        ]
    },
    "ttps": {},
    "meanings": {
        "Category": [
            {
                "token": {
                    "id": "<CATEGORY_0xf1a480bb>",
                    "type": "Category",
                    "value": "malware"
                },
                "references": {
                    "sentences": [
                        "We have provided an example of how to read only the first 0x100 bytes of the SMRAM; however, with additional modifications, its possible to read/write the whole SMRAM range. This could allow threat actors to execute their own malicious code in SMM or even worse considering the LenovoVariable SW SMI handlers ability to modify the SPI flash write the attackers own malicious firmware implant directly to the SPI flash.",
                        "In addition, while investigating above mentioned vulnerable drivers, we discovered the third vulnerability: SMM memory corruption inside the SW SMI handler function (CVE-2021-3970). This vulnerability allows arbitrary read/write from/into SMRAM, which can lead to the execution of malicious code with SMM privileges and potentially lead to the deployment of an SPI flash implant.",
                        "As a result, the exploited system will allow modification of the SPI flash even when done from non-SMM code and thus allow an attacker to deploy malicious code directly to the firmware storage.",
                        "ESET researchers discover multiple vulnerabilities in various Lenovo laptop models that allow an attacker with admin privileges to expose the user to firmware-level malware",
                        "Needless to say, such an action would have serious impact on system security. Disabling UEFI Secure Boot would mean that the firmware wont enforce integrity verification of the UEFI drivers and applications during the boot process and will thus allow loading of any untrusted or malicious ones. On the other hand, restoring factory settings would not directly disable UEFI Secure Boot, but could expose a system to the risk of deploying some UEFI applications, such as bootloaders, with known vulnerabilities (e.g. see BootHole), thus allowing a bypass of UEFI Secure Boot.",
                        "ESET researchers have discovered and analyzed three vulnerabilities affecting various Lenovo consumer laptop models. The first two of these vulnerabilities CVE-2021-3971, CVE-2021-3972 affect UEFI firmware drivers originally meant to be used only during the manufacturing process of Lenovo consumer notebooks. Unfortunately, they were mistakenly included also in the production BIOS images without being properly deactivated. These affected firmware drivers can be activated by attacker to directly disable SPI flash protections (BIOS Control Register bits and Protected Range registers) or the UEFI Secure Boot feature from a privileged user-mode process during OS runtime. It means that exploitation of these vulnerabilities would allow attackers to deploy and successfully execute SPI flash or ESP implants, like LoJax or our latest UEFI malware discovery ESPecter, on the affected devices."
                    ],
                    "titles": [
                        "CVE-2021-3971 SecureBackDoor driver disable SPI flash protections",
                        "When secure isnt secure at all: Highimpact UEFI vulnerabilities discovered in Lenovo consumer laptops",
                        "Lenovo variable storage and a vulnerable SW SMI handler",
                        "CVE-2021-3972 ChgBootDxeHook driver disable UEFI Secure Boot"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CVE_0x88f5da2>",
                            "type": "CVE",
                            "value": "cve-2021-3972"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CVE_0x73670081>",
                            "type": "CVE",
                            "value": "cve-2021-3971"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0x96121f83>",
                    "type": "Category",
                    "value": "backdoor"
                },
                "references": {
                    "sentences": [
                        "This backdoor feature is implemented by the following two drivers in the firmware of affected devices:"
                    ],
                    "titles": [
                        "CVE-2021-3972 ChgBootDxeHook driver disable UEFI Secure Boot"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CVE_0x88f5da2>",
                            "type": "CVE",
                            "value": "cve-2021-3972"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0xc8ecca29>",
                    "type": "Category",
                    "value": "c2"
                },
                "references": {
                    "sentences": [
                        "As we can see in Figure 14, after the ChgBootSecureBootDisable variable check, another condition is present it disables UEFI Secure Boot only if the value retrieved from the special LenovoVariable persistent storage, accessed using a protocol identified by the GUID C20E5755-1169-4C56-A48A-9824AB430D00 (LENOVO_VARIABLE_PROTOCOL_GUID in Figure 14), contains value Y (0x59)."
                    ],
                    "titles": [
                        "ChgBootDxeHook analysis",
                        "Lenovo variable storage and a vulnerable SW SMI handler"
                    ]
                }
            },
            {
                "token": {
                    "id": "<CATEGORY_0x1c03897b>",
                    "type": "Category",
                    "value": "rootkit"
                },
                "references": {
                    "sentences": [
                        "All of the real-world UEFI threats discovered in recent years (LoJax, MosaicRegressor, MoonBounce, ESPecter, FinSpy) needed to bypass or disable the security mechanisms in some way in order to be deployed and executed. However, only in the case of LoJax, the first in-the-wild UEFI rootkit (discovered by ESET Research in 2018), do we have a clue how it was done by using the ReWriter_binary capable of exploiting the Speed Racer vulnerability."
                    ],
                    "titles": [
                        "Conclusion"
                    ]
                }
            }
        ],
        "CVE": [
            {
                "token": {
                    "id": "<CVE_0x73670081>",
                    "type": "CVE",
                    "value": "cve-2021-3971"
                },
                "references": {
                    "sentences": [
                        "To understand how easy this is, Windows users can disable these protections by exploiting the CVE-2021-3971 vulnerability directly from the privileged userland process (administrator with SE_SYSTEM_ENVIRONMENT_NAME privilege) using the Windows API function SetFirmwareEnvironmentVariable.",
                        "CVE-2021-3970 LenovoVariableSmm SMM arbitrary read/write<crlf>CVE-2021-3971 SecureBackDoor disable SPI flash protections<crlf>CVE-2021-3972 ChgBootDxeHook disable UEFI Secure Boot",
                        "We will start with the analysis of the CVE-2021-3971 vulnerability, which allows an attacker to disable SPI flash write-protections mechanisms by simply creating the NVRAM variable. When platform firmware detects this NVRAM variable during bootup, it skips execution of the code responsible for the setting up BIOS Control Register and Protected Range register-based SPI flash protections.",
                        "In our analysis, we will work with the firmware image (version 1GCN25WW) of the Lenovo 110-15IBR, which is one of the devices affected by the CVE-2021-3971 vulnerability.",
                        "To understand how we were able to find these vulnerabilities, consider the firmware drivers affected by CVE2021-3971. These drivers immediately caught our attention by their very unfortunate (but surprisingly honest) names: SecureBackDoor and SecureBackDoorPeim. After some initial analysis, we discovered other Lenovo drivers sharing a few common characteristics with the SecureBackDoor* drivers: ChgBootDxeHook and ChgBootSmm. As it turned out, their functionality was even more interesting and could be abused to disable UEFI Secure Boot (CVE-2021-3972).",
                        "We start with our analysis of the Lenovo drivers affected by CVE-2021-3971 and CVE-2021-3972, and then continue with the SMM vulnerability CVE-2021-3970.",
                        "ESET researchers have discovered and analyzed three vulnerabilities affecting various Lenovo consumer laptop models. The first two of these vulnerabilities CVE-2021-3971, CVE-2021-3972 affect UEFI firmware drivers originally meant to be used only during the manufacturing process of Lenovo consumer notebooks. Unfortunately, they were mistakenly included also in the production BIOS images without being properly deactivated. These affected firmware drivers can be activated by attacker to directly disable SPI flash protections (BIOS Control Register bits and Protected Range registers) or the UEFI Secure Boot feature from a privileged user-mode process during OS runtime. It means that exploitation of these vulnerabilities would allow attackers to deploy and successfully execute SPI flash or ESP implants, like LoJax or our latest UEFI malware discovery ESPecter, on the affected devices."
                    ],
                    "titles": [
                        "CVE-2021-3971 SecureBackDoor driver disable SPI flash protections",
                        "When secure isnt secure at all: Highimpact UEFI vulnerabilities discovered in Lenovo consumer laptops",
                        "Technical analysis"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CVE_0x73670081>",
                            "type": "CVE",
                            "value": "cve-2021-3971"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CVE_0x88f5da2>",
                    "type": "CVE",
                    "value": "cve-2021-3972"
                },
                "references": {
                    "sentences": [
                        "In our analysis, we will work with the firmware image (version 7XCN41WW) of the Lenovo 330-15IGM, which is affected by the CVE-2021-3972 vulnerability.",
                        "CVE-2021-3970 LenovoVariableSmm SMM arbitrary read/write<crlf>CVE-2021-3971 SecureBackDoor disable SPI flash protections<crlf>CVE-2021-3972 ChgBootDxeHook disable UEFI Secure Boot",
                        "Figure 17. CHIPSEC example read 0x100 bytes from SMRAM by exploiting CVE-2021-3972",
                        "To understand how we were able to find these vulnerabilities, consider the firmware drivers affected by CVE2021-3971. These drivers immediately caught our attention by their very unfortunate (but surprisingly honest) names: SecureBackDoor and SecureBackDoorPeim. After some initial analysis, we discovered other Lenovo drivers sharing a few common characteristics with the SecureBackDoor* drivers: ChgBootDxeHook and ChgBootSmm. As it turned out, their functionality was even more interesting and could be abused to disable UEFI Secure Boot (CVE-2021-3972).",
                        "We start with our analysis of the Lenovo drivers affected by CVE-2021-3971 and CVE-2021-3972, and then continue with the SMM vulnerability CVE-2021-3970.",
                        "For those using End Of Development Support (EODS) devices affected by the CVE-2021-3972, without any fixes available: one thing that can help you protect against unwanted modification of the UEFI Secure Boot state is using a TPM-aware full-disk encryption solution capable of making disk data inaccessible if the UEFI Secure Boot configuration changes.",
                        "ESET researchers have discovered and analyzed three vulnerabilities affecting various Lenovo consumer laptop models. The first two of these vulnerabilities CVE-2021-3971, CVE-2021-3972 affect UEFI firmware drivers originally meant to be used only during the manufacturing process of Lenovo consumer notebooks. Unfortunately, they were mistakenly included also in the production BIOS images without being properly deactivated. These affected firmware drivers can be activated by attacker to directly disable SPI flash protections (BIOS Control Register bits and Protected Range registers) or the UEFI Secure Boot feature from a privileged user-mode process during OS runtime. It means that exploitation of these vulnerabilities would allow attackers to deploy and successfully execute SPI flash or ESP implants, like LoJax or our latest UEFI malware discovery ESPecter, on the affected devices.",
                        "The next vulnerability we will take a look at is the CVE-2021-3972. This vulnerability allows an attacker with elevated privileges to change various UEFI firmware settings, including the UEFI Secure Boot state, or for example restoring the UEFI firmware factory settings, all by simply creating one UEFI variable."
                    ],
                    "titles": [
                        "When secure isnt secure at all: Highimpact UEFI vulnerabilities discovered in Lenovo consumer laptops",
                        "Lenovo variable storage and a vulnerable SW SMI handler",
                        "CVE-2021-3972 ChgBootDxeHook driver disable UEFI Secure Boot",
                        "Conclusion",
                        "Technical analysis"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CVE_0x88f5da2>",
                            "type": "CVE",
                            "value": "cve-2021-3972"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CVE_0x88f5da2>",
                            "type": "CVE",
                            "value": "cve-2021-3972"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CVE_0xdc049a40>",
                    "type": "CVE",
                    "value": "cve-2021-3970"
                },
                "references": {
                    "sentences": [
                        "In this analysis, we will work with the firmware image (version 7XCN41WW) of the Lenovo 330-15IGM, which is affected by the CVE-2021-3970 vulnerability.",
                        "In addition, while investigating above mentioned vulnerable drivers, we discovered the third vulnerability: SMM memory corruption inside the SW SMI handler function (CVE-2021-3970). This vulnerability allows arbitrary read/write from/into SMRAM, which can lead to the execution of malicious code with SMM privileges and potentially lead to the deployment of an SPI flash implant.",
                        "CVE-2021-3970 LenovoVariableSmm SMM arbitrary read/write<crlf>CVE-2021-3971 SecureBackDoor disable SPI flash protections<crlf>CVE-2021-3972 ChgBootDxeHook disable UEFI Secure Boot",
                        "In this last section, we are going to look at the analysis of the CVE-2021-3970 vulnerability caused by an improper input validation in the SW SMI handler function, which can lead to the arbitrary read/write from/to the SMRAM and subsequent arbitrary code execution in SMM execution mode.",
                        "We start with our analysis of the Lenovo drivers affected by CVE-2021-3971 and CVE-2021-3972, and then continue with the SMM vulnerability CVE-2021-3970."
                    ],
                    "titles": [
                        "CVE-2021-3970 Arbitrary SMM read/write",
                        "When secure isnt secure at all: Highimpact UEFI vulnerabilities discovered in Lenovo consumer laptops",
                        "Technical analysis"
                    ]
                }
            }
        ],
        "Geo": [
            {
                "token": {
                    "id": "<GEO_0xe5bfc6b3>",
                    "type": "Geo",
                    "value": "ukraine"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Sign up to receive an email update whenever a new article is published in our Ukraine Crisis Digital Security Resource Center"
                    ]
                }
            }
        ]
    },
    "iocs": {
        "File": [
            {
                "token": {
                    "id": "<FILE_0xd7ac1e69>",
                    "type": "File",
                    "value": "efi_boot_services.exitbootservices"
                },
                "references": {
                    "sentences": [
                        "UEFI boot drivers and applications use protocols extensively. In the context of UEFI, protocols are simply groups of functions identified by a GUID. These protocols, once installed, reside in memory and can be used by other drivers or applications, until EFI_BOOT_SERVICES.ExitBootServices is called. The UEFI specification defines many such protocols to cover the most common firmware use-case scenarios, but firmware developers are still able to define their own protocols to extend this basic functionality.",
                        "VARIABLE_ATTRIBUTE_NON_VOLATILE (NV)(0x00000001) Variables using this attribute persist across the power cycles and are stored in fixed hardware storage (NVRAM) with limited capacity (typically around 64MB).<crlf>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS (BS)(0x00000002) If the BS attribute is set, variables without the RT attribute set will not be visible to the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices.<crlf>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS (RT)0x00000004) To access a variable via the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices, the RT attribute must be set.<crlf>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS (AW)(0x00000010)<crlf>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS (AWT)(0x00000020)"
                    ],
                    "titles": [
                        "UEFI variables",
                        "UEFI services and protocols"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xd7ac1e69>",
                            "type": "File",
                            "value": "efi_boot_services.exitbootservices"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac8b186b>",
                            "type": "UnknownWord",
                            "value": "reside"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xd7ac1e69>",
                            "type": "File",
                            "value": "efi_boot_services.exitbootservices"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3ab09ddb>",
                            "type": "UnknownWord",
                            "value": "variable_attribute_runtime_access"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xd7ac1e69>",
                            "type": "File",
                            "value": "efi_boot_services.exitbootservices"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd4ba4ffe>",
                            "type": "UnknownWord",
                            "value": "getvariable"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xd7ac1e69>",
                            "type": "File",
                            "value": "efi_boot_services.exitbootservices"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc1a8beee>",
                            "type": "UnknownWord",
                            "value": "variable_attribute_bootservice_access"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0xdcb228d>",
                    "type": "File",
                    "value": "efi_smm_sw_dispatch2_protocol.register"
                },
                "references": {
                    "sentences": [
                        "To install such a handler function, the EFI_SMM_SW_DISPATCH2_PROTOCOL.Register service function is used; the function type definition is shown in Figure 2.",
                        "Figure 2. EFI_SMM_SW_DISPATCH2_PROTOCOL.Register function definition",
                        "ChgBootSmm is an SMM module responsible for registration of the SW SMI handler function. As shown in Figure 9, it registers this SMI handler using the EFI_SMM_SW_DISPATCH2_PROTOCOL.Register function and sets the SwSmiInputValue to 0xCA. This means that one can trigger execution of this function by writing the value 0xCA to I/O port 0xB2."
                    ],
                    "titles": [
                        "Defining SW SMI handlers in the UEFI firmware",
                        "ChgBootSmm analysis"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdcb228d>",
                            "type": "File",
                            "value": "efi_smm_sw_dispatch2_protocol.register"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x79b9c207>",
                            "type": "UnknownWord",
                            "value": "swsmiinputvalue"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdcb228d>",
                            "type": "File",
                            "value": "efi_smm_sw_dispatch2_protocol.register"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f6e4417>",
                            "type": "UnknownWord",
                            "value": "smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdcb228d>",
                            "type": "File",
                            "value": "efi_smm_sw_dispatch2_protocol.register"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd6e4e2d5>",
                            "type": "UnknownWord",
                            "value": "handler"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0x87e9007>",
                    "type": "File",
                    "value": "efi_pei_read_only_variable2_ppi.getvariable"
                },
                "references": {
                    "sentences": [
                        "Use EFI_PEI_READ_ONLY_VARIABLE2_PPI.GetVariable function with the VariableName and VariableGuid parameters set to values cE! and LENOVO_BACKDOOR_NAMESPACE_GUID respectively.<crlf>To pass this information to the SecureBackDoor DXE driver, create a HOB data structure identified by the following GUID AD7934E7-D800-4305-BF6F-49ED9918E1AB. To make things simpler, lets name this HOB data structure GUID SECURE_BACKDOOR_HOB_GUID.<crlf>Finally, it saves the value retrieved from the cE! variable to offset 0x18 of the newly created HOB."
                    ],
                    "titles": [
                        "SecureBackDoorPeim analysis"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x87e9007>",
                            "type": "File",
                            "value": "efi_pei_read_only_variable2_ppi.getvariable"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb66c08bb>",
                            "type": "UnknownWord",
                            "value": "lenovo_backdoor_namespace_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x87e9007>",
                            "type": "File",
                            "value": "efi_pei_read_only_variable2_ppi.getvariable"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe6e39654>",
                            "type": "UnknownWord",
                            "value": "variableguid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x87e9007>",
                            "type": "File",
                            "value": "efi_pei_read_only_variable2_ppi.getvariable"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5ea0aa68>",
                            "type": "UnknownWord",
                            "value": "variablename"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0xdcca3434>",
                    "type": "File",
                    "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                },
                "references": {
                    "sentences": [
                        "PchBiosWriteProtect is a SMM module. In Figure 6 we can see that it checks whether the BiosLock bit inside DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig (type PCH_LOCK_DOWN_CONFIG) is set, by performing a bitwise AND operation with value 0x08 (which is 0b1000 in binary representation).",
                        "If this HOB is found, the driver gets the byte value at offset 0x18 which is the value previously retrieved from the cE! UEFI variable by SecureBackDoorPeim and if this value is different from 0x00, it registers the DXE_PCH_PLATFORM_POLICY_PROTOCOL protocol notify function that zeroes the BiosLock bit inside the DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig bitmask (for related type definitions, see TianoCores PchPlatformPolicy.h header file at GitHub).",
                        "The second driver, BiosRegionLock, is responsible for setting up Protected Range registers PR0-PR4. Similar to the PchBiosWriteProtect described above, it uses the BiosLock bit inside DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig (type PCH_LOCK_DOWN_CONFIG) to decide whether or not to set SPI flash protections in this case Protected Range registers."
                    ],
                    "titles": [
                        "PchBiosWriteProtect analysis",
                        "BiosRegionLock analysis",
                        "SecureBackDoor analysis"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x55f1f9b4>",
                            "type": "UnknownWord",
                            "value": "pchplatformpolicy"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3ec06f36>",
                            "type": "UnknownWord",
                            "value": "dxe_pch_platform_policy_protocol"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x38e3d7d7>",
                            "type": "UnknownWord",
                            "value": "zeroes"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2becac96>",
                            "type": "UnknownWord",
                            "value": "spi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe42e0cf1>",
                            "type": "UnknownWord",
                            "value": "decide"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4e3de86c>",
                            "type": "UnknownWord",
                            "value": "pch_lock_down_config"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa54c5b94>",
                            "type": "UnknownWord",
                            "value": "securebackdoorpeim"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x93aed084>",
                            "type": "UnknownWord",
                            "value": "pchbioswriteprotect"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x775a62dd>",
                            "type": "UnknownWord",
                            "value": "hob"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x85dab752>",
                            "type": "UnknownWord",
                            "value": "tianocores"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x818d4466>",
                            "type": "UnknownWord",
                            "value": "0b1000"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7bf80a4>",
                            "type": "UnknownWord",
                            "value": "offset"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x63598eb8>",
                            "type": "UnknownWord",
                            "value": "bitwise"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x901f8bb6>",
                            "type": "UnknownWord",
                            "value": "bitmask"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x57d9752c>",
                            "type": "UnknownWord",
                            "value": "bioslock"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0x31ee2c05>",
                    "type": "File",
                    "value": "chipsec.chipsetfrom"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Lenovo variable storage and a vulnerable SW SMI handler"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x33d5b2>",
                            "type": "UnknownWord",
                            "value": "smi_num"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa0644f88>",
                            "type": "UnknownWord",
                            "value": "write_physical_memmem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb3b2cd6a>",
                            "type": "UnknownWord",
                            "value": "_rbx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x99e01676>",
                            "type": "UnknownWord",
                            "value": "0x5380_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xca336029>",
                            "type": "UnknownWord",
                            "value": "structimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf83b6301>",
                            "type": "UnknownWord",
                            "value": "hdr_sz"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x20780444>",
                            "type": "UnknownWord",
                            "value": "<i"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x93ce8f1b>",
                            "type": "UnknownWord",
                            "value": "0xb2_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4bb7ce50>",
                            "type": "UnknownWord",
                            "value": "alloc_physical_mem"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9866b1f7>",
                            "type": "UnknownWord",
                            "value": "mem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1ecbb2a6>",
                            "type": "UnknownWord",
                            "value": "smramphys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x41b23ff4>",
                            "type": "UnknownWord",
                            "value": "smram_addr-hdr_szhdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe4787692>",
                            "type": "UnknownWord",
                            "value": "get_smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1a6eaccf>",
                            "type": "UnknownWord",
                            "value": "addresssmram_addr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4c299b67>",
                            "type": "UnknownWord",
                            "value": "var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8bbf54a1>",
                            "type": "UnknownWord",
                            "value": "0xfffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcdebf4e6>",
                            "type": "UnknownWord",
                            "value": "sz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac629237>",
                            "type": "UnknownWord",
                            "value": "binasciiimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x12bc107d>",
                            "type": "UnknownWord",
                            "value": "send_sw_smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa71c0661>",
                            "type": "UnknownWord",
                            "value": "bufferhigh"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9471467e>",
                            "type": "UnknownWord",
                            "value": "mem_read"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd08a1abb>",
                            "type": "UnknownWord",
                            "value": "hdr_sz_va"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2bd42a89>",
                            "type": "UnknownWord",
                            "value": "intr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf60948a4>",
                            "type": "UnknownWord",
                            "value": "allocate"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4252f11e>",
                            "type": "UnknownWord",
                            "value": "var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4a114121>",
                            "type": "UnknownWord",
                            "value": "read_physical_memmem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c9bd643>",
                            "type": "UnknownWord",
                            "value": "buffersz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbac8d6cc>",
                            "type": "UnknownWord",
                            "value": "x00"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd6e4e2d5>",
                            "type": "UnknownWord",
                            "value": "handler"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x94f3253e>",
                            "type": "UnknownWord",
                            "value": "_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcb3c6be8>",
                            "type": "UnknownWord",
                            "value": "_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x331ef1db>",
                            "type": "UnknownWord",
                            "value": "mem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc7d9530d>",
                            "type": "UnknownWord",
                            "value": "highresult"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa3fc3ad5>",
                            "type": "UnknownWord",
                            "value": "0xfffffffffffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe0baaadc>",
                            "type": "UnknownWord",
                            "value": "smram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbf833fdc>",
                            "type": "UnknownWord",
                            "value": "variable_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc3f0b985>",
                            "type": "UnknownWord",
                            "value": "zeroe"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x63dc41ff>",
                            "type": "UnknownWord",
                            "value": "lenovo"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa198a1de>",
                            "type": "UnknownWord",
                            "value": "_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f6e4417>",
                            "type": "UnknownWord",
                            "value": "smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xae3d31e>",
                            "type": "UnknownWord",
                            "value": "interruptsfrom"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc0845159>",
                            "type": "UnknownWord",
                            "value": "smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2e75d5fb>",
                            "type": "UnknownWord",
                            "value": "_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x306ff259>",
                            "type": "UnknownWord",
                            "value": "smramsmram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3131d19a>",
                            "type": "UnknownWord",
                            "value": "allocated"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa263693a>",
                            "type": "UnknownWord",
                            "value": "0x100var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb70921eb>",
                            "type": "UnknownWord",
                            "value": "out_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbbe4007d>",
                            "type": "UnknownWord",
                            "value": "0xffffffff_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x6e4743bd>",
                            "type": "UnknownWord",
                            "value": "low_rbx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c54e4d3>",
                            "type": "UnknownWord",
                            "value": "interrupts"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb629a9e5>",
                            "type": "UnknownWord",
                            "value": "0x20var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac287262>",
                            "type": "UnknownWord",
                            "value": ">>"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f4e9d84>",
                            "type": "UnknownWord",
                            "value": "hexdump"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4b81bccc>",
                            "type": "UnknownWord",
                            "value": "phys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb0535127>",
                            "type": "UnknownWord",
                            "value": "highintr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc4344a4d>",
                            "type": "UnknownWord",
                            "value": "hdr"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0x78cb3a4e>",
                    "type": "File",
                    "value": "chipsec.hal.interrupts"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Lenovo variable storage and a vulnerable SW SMI handler"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd6e4e2d5>",
                            "type": "UnknownWord",
                            "value": "handler"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x94f3253e>",
                            "type": "UnknownWord",
                            "value": "_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcb3c6be8>",
                            "type": "UnknownWord",
                            "value": "_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4a114121>",
                            "type": "UnknownWord",
                            "value": "read_physical_memmem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4252f11e>",
                            "type": "UnknownWord",
                            "value": "var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c9bd643>",
                            "type": "UnknownWord",
                            "value": "buffersz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac287262>",
                            "type": "UnknownWord",
                            "value": ">>"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x20780444>",
                            "type": "UnknownWord",
                            "value": "<i"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9471467e>",
                            "type": "UnknownWord",
                            "value": "mem_read"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd08a1abb>",
                            "type": "UnknownWord",
                            "value": "hdr_sz_va"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb70921eb>",
                            "type": "UnknownWord",
                            "value": "out_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3131d19a>",
                            "type": "UnknownWord",
                            "value": "allocated"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2bd42a89>",
                            "type": "UnknownWord",
                            "value": "intr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbbe4007d>",
                            "type": "UnknownWord",
                            "value": "0xffffffff_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa263693a>",
                            "type": "UnknownWord",
                            "value": "0x100var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf60948a4>",
                            "type": "UnknownWord",
                            "value": "allocate"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2e75d5fb>",
                            "type": "UnknownWord",
                            "value": "_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x306ff259>",
                            "type": "UnknownWord",
                            "value": "smramsmram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f6e4417>",
                            "type": "UnknownWord",
                            "value": "smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa198a1de>",
                            "type": "UnknownWord",
                            "value": "_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc0845159>",
                            "type": "UnknownWord",
                            "value": "smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xae3d31e>",
                            "type": "UnknownWord",
                            "value": "interruptsfrom"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x63dc41ff>",
                            "type": "UnknownWord",
                            "value": "lenovo"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc3f0b985>",
                            "type": "UnknownWord",
                            "value": "zeroe"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x41b23ff4>",
                            "type": "UnknownWord",
                            "value": "smram_addr-hdr_szhdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x99e01676>",
                            "type": "UnknownWord",
                            "value": "0x5380_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1ecbb2a6>",
                            "type": "UnknownWord",
                            "value": "smramphys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x93ce8f1b>",
                            "type": "UnknownWord",
                            "value": "0xb2_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb0535127>",
                            "type": "UnknownWord",
                            "value": "highintr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb3b2cd6a>",
                            "type": "UnknownWord",
                            "value": "_rbx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa0644f88>",
                            "type": "UnknownWord",
                            "value": "write_physical_memmem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x33d5b2>",
                            "type": "UnknownWord",
                            "value": "smi_num"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc4344a4d>",
                            "type": "UnknownWord",
                            "value": "hdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xca336029>",
                            "type": "UnknownWord",
                            "value": "structimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c54e4d3>",
                            "type": "UnknownWord",
                            "value": "interrupts"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb629a9e5>",
                            "type": "UnknownWord",
                            "value": "0x20var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4b81bccc>",
                            "type": "UnknownWord",
                            "value": "phys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f4e9d84>",
                            "type": "UnknownWord",
                            "value": "hexdump"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1a6eaccf>",
                            "type": "UnknownWord",
                            "value": "addresssmram_addr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x12bc107d>",
                            "type": "UnknownWord",
                            "value": "send_sw_smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x6e4743bd>",
                            "type": "UnknownWord",
                            "value": "low_rbx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa71c0661>",
                            "type": "UnknownWord",
                            "value": "bufferhigh"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac629237>",
                            "type": "UnknownWord",
                            "value": "binasciiimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8bbf54a1>",
                            "type": "UnknownWord",
                            "value": "0xfffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4c299b67>",
                            "type": "UnknownWord",
                            "value": "var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcdebf4e6>",
                            "type": "UnknownWord",
                            "value": "sz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbf833fdc>",
                            "type": "UnknownWord",
                            "value": "variable_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe0baaadc>",
                            "type": "UnknownWord",
                            "value": "smram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc7d9530d>",
                            "type": "UnknownWord",
                            "value": "highresult"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe4787692>",
                            "type": "UnknownWord",
                            "value": "get_smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa3fc3ad5>",
                            "type": "UnknownWord",
                            "value": "0xfffffffffffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf83b6301>",
                            "type": "UnknownWord",
                            "value": "hdr_sz"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4bb7ce50>",
                            "type": "UnknownWord",
                            "value": "alloc_physical_mem"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x331ef1db>",
                            "type": "UnknownWord",
                            "value": "mem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9866b1f7>",
                            "type": "UnknownWord",
                            "value": "mem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbac8d6cc>",
                            "type": "UnknownWord",
                            "value": "x00"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0xf6b778c2>",
                    "type": "File",
                    "value": "chipsec.chipset.cs"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Lenovo variable storage and a vulnerable SW SMI handler"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x41b23ff4>",
                            "type": "UnknownWord",
                            "value": "smram_addr-hdr_szhdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1ecbb2a6>",
                            "type": "UnknownWord",
                            "value": "smramphys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x306ff259>",
                            "type": "UnknownWord",
                            "value": "smramsmram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x93ce8f1b>",
                            "type": "UnknownWord",
                            "value": "0xb2_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x99e01676>",
                            "type": "UnknownWord",
                            "value": "0x5380_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa0644f88>",
                            "type": "UnknownWord",
                            "value": "write_physical_memmem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xca336029>",
                            "type": "UnknownWord",
                            "value": "structimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb3b2cd6a>",
                            "type": "UnknownWord",
                            "value": "_rbx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xae3d31e>",
                            "type": "UnknownWord",
                            "value": "interruptsfrom"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa198a1de>",
                            "type": "UnknownWord",
                            "value": "_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4b81bccc>",
                            "type": "UnknownWord",
                            "value": "phys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1a6eaccf>",
                            "type": "UnknownWord",
                            "value": "addresssmram_addr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac287262>",
                            "type": "UnknownWord",
                            "value": ">>"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x20780444>",
                            "type": "UnknownWord",
                            "value": "<i"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x63dc41ff>",
                            "type": "UnknownWord",
                            "value": "lenovo"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc3f0b985>",
                            "type": "UnknownWord",
                            "value": "zeroe"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbbe4007d>",
                            "type": "UnknownWord",
                            "value": "0xffffffff_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa263693a>",
                            "type": "UnknownWord",
                            "value": "0x100var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb70921eb>",
                            "type": "UnknownWord",
                            "value": "out_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3131d19a>",
                            "type": "UnknownWord",
                            "value": "allocated"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2e75d5fb>",
                            "type": "UnknownWord",
                            "value": "_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x331ef1db>",
                            "type": "UnknownWord",
                            "value": "mem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc0845159>",
                            "type": "UnknownWord",
                            "value": "smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f6e4417>",
                            "type": "UnknownWord",
                            "value": "smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbac8d6cc>",
                            "type": "UnknownWord",
                            "value": "x00"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c9bd643>",
                            "type": "UnknownWord",
                            "value": "buffersz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4252f11e>",
                            "type": "UnknownWord",
                            "value": "var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe0baaadc>",
                            "type": "UnknownWord",
                            "value": "smram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2bd42a89>",
                            "type": "UnknownWord",
                            "value": "intr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbf833fdc>",
                            "type": "UnknownWord",
                            "value": "variable_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf60948a4>",
                            "type": "UnknownWord",
                            "value": "allocate"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd08a1abb>",
                            "type": "UnknownWord",
                            "value": "hdr_sz_va"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb629a9e5>",
                            "type": "UnknownWord",
                            "value": "0x20var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9471467e>",
                            "type": "UnknownWord",
                            "value": "mem_read"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc7d9530d>",
                            "type": "UnknownWord",
                            "value": "highresult"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa3fc3ad5>",
                            "type": "UnknownWord",
                            "value": "0xfffffffffffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd6e4e2d5>",
                            "type": "UnknownWord",
                            "value": "handler"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x94f3253e>",
                            "type": "UnknownWord",
                            "value": "_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcdebf4e6>",
                            "type": "UnknownWord",
                            "value": "sz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcb3c6be8>",
                            "type": "UnknownWord",
                            "value": "_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4a114121>",
                            "type": "UnknownWord",
                            "value": "read_physical_memmem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe4787692>",
                            "type": "UnknownWord",
                            "value": "get_smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa71c0661>",
                            "type": "UnknownWord",
                            "value": "bufferhigh"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9866b1f7>",
                            "type": "UnknownWord",
                            "value": "mem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x12bc107d>",
                            "type": "UnknownWord",
                            "value": "send_sw_smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac629237>",
                            "type": "UnknownWord",
                            "value": "binasciiimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf83b6301>",
                            "type": "UnknownWord",
                            "value": "hdr_sz"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4bb7ce50>",
                            "type": "UnknownWord",
                            "value": "alloc_physical_mem"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x33d5b2>",
                            "type": "UnknownWord",
                            "value": "smi_num"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc4344a4d>",
                            "type": "UnknownWord",
                            "value": "hdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8bbf54a1>",
                            "type": "UnknownWord",
                            "value": "0xfffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4c299b67>",
                            "type": "UnknownWord",
                            "value": "var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb0535127>",
                            "type": "UnknownWord",
                            "value": "highintr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f4e9d84>",
                            "type": "UnknownWord",
                            "value": "hexdump"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c54e4d3>",
                            "type": "UnknownWord",
                            "value": "interrupts"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x6e4743bd>",
                            "type": "UnknownWord",
                            "value": "low_rbx"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0x86c9cc4b>",
                    "type": "File",
                    "value": "cs.init"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Lenovo variable storage and a vulnerable SW SMI handler"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x33d5b2>",
                            "type": "UnknownWord",
                            "value": "smi_num"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc4344a4d>",
                            "type": "UnknownWord",
                            "value": "hdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x93ce8f1b>",
                            "type": "UnknownWord",
                            "value": "0xb2_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c54e4d3>",
                            "type": "UnknownWord",
                            "value": "interrupts"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb629a9e5>",
                            "type": "UnknownWord",
                            "value": "0x20var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4b81bccc>",
                            "type": "UnknownWord",
                            "value": "phys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1a6eaccf>",
                            "type": "UnknownWord",
                            "value": "addresssmram_addr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f4e9d84>",
                            "type": "UnknownWord",
                            "value": "hexdump"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x12bc107d>",
                            "type": "UnknownWord",
                            "value": "send_sw_smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x6e4743bd>",
                            "type": "UnknownWord",
                            "value": "low_rbx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa71c0661>",
                            "type": "UnknownWord",
                            "value": "bufferhigh"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac629237>",
                            "type": "UnknownWord",
                            "value": "binasciiimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8bbf54a1>",
                            "type": "UnknownWord",
                            "value": "0xfffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4c299b67>",
                            "type": "UnknownWord",
                            "value": "var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcdebf4e6>",
                            "type": "UnknownWord",
                            "value": "sz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe0baaadc>",
                            "type": "UnknownWord",
                            "value": "smram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbf833fdc>",
                            "type": "UnknownWord",
                            "value": "variable_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa3fc3ad5>",
                            "type": "UnknownWord",
                            "value": "0xfffffffffffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe4787692>",
                            "type": "UnknownWord",
                            "value": "get_smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc7d9530d>",
                            "type": "UnknownWord",
                            "value": "highresult"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4bb7ce50>",
                            "type": "UnknownWord",
                            "value": "alloc_physical_mem"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf83b6301>",
                            "type": "UnknownWord",
                            "value": "hdr_sz"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x331ef1db>",
                            "type": "UnknownWord",
                            "value": "mem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9866b1f7>",
                            "type": "UnknownWord",
                            "value": "mem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb3b2cd6a>",
                            "type": "UnknownWord",
                            "value": "_rbx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbac8d6cc>",
                            "type": "UnknownWord",
                            "value": "x00"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd6e4e2d5>",
                            "type": "UnknownWord",
                            "value": "handler"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x94f3253e>",
                            "type": "UnknownWord",
                            "value": "_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcb3c6be8>",
                            "type": "UnknownWord",
                            "value": "_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4a114121>",
                            "type": "UnknownWord",
                            "value": "read_physical_memmem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4252f11e>",
                            "type": "UnknownWord",
                            "value": "var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c9bd643>",
                            "type": "UnknownWord",
                            "value": "buffersz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac287262>",
                            "type": "UnknownWord",
                            "value": ">>"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x20780444>",
                            "type": "UnknownWord",
                            "value": "<i"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd08a1abb>",
                            "type": "UnknownWord",
                            "value": "hdr_sz_va"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9471467e>",
                            "type": "UnknownWord",
                            "value": "mem_read"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb70921eb>",
                            "type": "UnknownWord",
                            "value": "out_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2bd42a89>",
                            "type": "UnknownWord",
                            "value": "intr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf60948a4>",
                            "type": "UnknownWord",
                            "value": "allocate"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3131d19a>",
                            "type": "UnknownWord",
                            "value": "allocated"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbbe4007d>",
                            "type": "UnknownWord",
                            "value": "0xffffffff_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa263693a>",
                            "type": "UnknownWord",
                            "value": "0x100var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2e75d5fb>",
                            "type": "UnknownWord",
                            "value": "_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x306ff259>",
                            "type": "UnknownWord",
                            "value": "smramsmram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f6e4417>",
                            "type": "UnknownWord",
                            "value": "smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa198a1de>",
                            "type": "UnknownWord",
                            "value": "_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc0845159>",
                            "type": "UnknownWord",
                            "value": "smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xae3d31e>",
                            "type": "UnknownWord",
                            "value": "interruptsfrom"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x63dc41ff>",
                            "type": "UnknownWord",
                            "value": "lenovo"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc3f0b985>",
                            "type": "UnknownWord",
                            "value": "zeroe"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x41b23ff4>",
                            "type": "UnknownWord",
                            "value": "smram_addr-hdr_szhdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa0644f88>",
                            "type": "UnknownWord",
                            "value": "write_physical_memmem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x99e01676>",
                            "type": "UnknownWord",
                            "value": "0x5380_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1ecbb2a6>",
                            "type": "UnknownWord",
                            "value": "smramphys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb0535127>",
                            "type": "UnknownWord",
                            "value": "highintr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xca336029>",
                            "type": "UnknownWord",
                            "value": "structimport"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0x44f247c8>",
                    "type": "File",
                    "value": "binascii.unhexlify"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Lenovo variable storage and a vulnerable SW SMI handler"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x6e4743bd>",
                            "type": "UnknownWord",
                            "value": "low_rbx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc4344a4d>",
                            "type": "UnknownWord",
                            "value": "hdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbbe4007d>",
                            "type": "UnknownWord",
                            "value": "0xffffffff_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f4e9d84>",
                            "type": "UnknownWord",
                            "value": "hexdump"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x20780444>",
                            "type": "UnknownWord",
                            "value": "<i"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac287262>",
                            "type": "UnknownWord",
                            "value": ">>"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c54e4d3>",
                            "type": "UnknownWord",
                            "value": "interrupts"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb629a9e5>",
                            "type": "UnknownWord",
                            "value": "0x20var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa263693a>",
                            "type": "UnknownWord",
                            "value": "0x100var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb70921eb>",
                            "type": "UnknownWord",
                            "value": "out_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3131d19a>",
                            "type": "UnknownWord",
                            "value": "allocated"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x306ff259>",
                            "type": "UnknownWord",
                            "value": "smramsmram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2e75d5fb>",
                            "type": "UnknownWord",
                            "value": "_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc0845159>",
                            "type": "UnknownWord",
                            "value": "smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xae3d31e>",
                            "type": "UnknownWord",
                            "value": "interruptsfrom"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f6e4417>",
                            "type": "UnknownWord",
                            "value": "smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa198a1de>",
                            "type": "UnknownWord",
                            "value": "_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x63dc41ff>",
                            "type": "UnknownWord",
                            "value": "lenovo"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc3f0b985>",
                            "type": "UnknownWord",
                            "value": "zeroe"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe0baaadc>",
                            "type": "UnknownWord",
                            "value": "smram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbf833fdc>",
                            "type": "UnknownWord",
                            "value": "variable_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa3fc3ad5>",
                            "type": "UnknownWord",
                            "value": "0xfffffffffffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc7d9530d>",
                            "type": "UnknownWord",
                            "value": "highresult"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbac8d6cc>",
                            "type": "UnknownWord",
                            "value": "x00"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4a114121>",
                            "type": "UnknownWord",
                            "value": "read_physical_memmem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x331ef1db>",
                            "type": "UnknownWord",
                            "value": "mem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd6e4e2d5>",
                            "type": "UnknownWord",
                            "value": "handler"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2bd42a89>",
                            "type": "UnknownWord",
                            "value": "intr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf60948a4>",
                            "type": "UnknownWord",
                            "value": "allocate"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x94f3253e>",
                            "type": "UnknownWord",
                            "value": "_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcb3c6be8>",
                            "type": "UnknownWord",
                            "value": "_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd08a1abb>",
                            "type": "UnknownWord",
                            "value": "hdr_sz_va"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c9bd643>",
                            "type": "UnknownWord",
                            "value": "buffersz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4252f11e>",
                            "type": "UnknownWord",
                            "value": "var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9471467e>",
                            "type": "UnknownWord",
                            "value": "mem_read"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8bbf54a1>",
                            "type": "UnknownWord",
                            "value": "0xfffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x12bc107d>",
                            "type": "UnknownWord",
                            "value": "send_sw_smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1a6eaccf>",
                            "type": "UnknownWord",
                            "value": "addresssmram_addr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac629237>",
                            "type": "UnknownWord",
                            "value": "binasciiimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa71c0661>",
                            "type": "UnknownWord",
                            "value": "bufferhigh"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe4787692>",
                            "type": "UnknownWord",
                            "value": "get_smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcdebf4e6>",
                            "type": "UnknownWord",
                            "value": "sz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4c299b67>",
                            "type": "UnknownWord",
                            "value": "var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x41b23ff4>",
                            "type": "UnknownWord",
                            "value": "smram_addr-hdr_szhdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9866b1f7>",
                            "type": "UnknownWord",
                            "value": "mem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x93ce8f1b>",
                            "type": "UnknownWord",
                            "value": "0xb2_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1ecbb2a6>",
                            "type": "UnknownWord",
                            "value": "smramphys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf83b6301>",
                            "type": "UnknownWord",
                            "value": "hdr_sz"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4bb7ce50>",
                            "type": "UnknownWord",
                            "value": "alloc_physical_mem"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x99e01676>",
                            "type": "UnknownWord",
                            "value": "0x5380_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xca336029>",
                            "type": "UnknownWord",
                            "value": "structimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb3b2cd6a>",
                            "type": "UnknownWord",
                            "value": "_rbx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x33d5b2>",
                            "type": "UnknownWord",
                            "value": "smi_num"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa0644f88>",
                            "type": "UnknownWord",
                            "value": "write_physical_memmem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb0535127>",
                            "type": "UnknownWord",
                            "value": "highintr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4b81bccc>",
                            "type": "UnknownWord",
                            "value": "phys_buff"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0x32ed10af>",
                    "type": "File",
                    "value": "struct.pack"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Lenovo variable storage and a vulnerable SW SMI handler"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb0535127>",
                            "type": "UnknownWord",
                            "value": "highintr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x93ce8f1b>",
                            "type": "UnknownWord",
                            "value": "0xb2_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c54e4d3>",
                            "type": "UnknownWord",
                            "value": "interrupts"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1ecbb2a6>",
                            "type": "UnknownWord",
                            "value": "smramphys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x99e01676>",
                            "type": "UnknownWord",
                            "value": "0x5380_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x41b23ff4>",
                            "type": "UnknownWord",
                            "value": "smram_addr-hdr_szhdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc3f0b985>",
                            "type": "UnknownWord",
                            "value": "zeroe"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x63dc41ff>",
                            "type": "UnknownWord",
                            "value": "lenovo"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xae3d31e>",
                            "type": "UnknownWord",
                            "value": "interruptsfrom"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc0845159>",
                            "type": "UnknownWord",
                            "value": "smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa198a1de>",
                            "type": "UnknownWord",
                            "value": "_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f6e4417>",
                            "type": "UnknownWord",
                            "value": "smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xca336029>",
                            "type": "UnknownWord",
                            "value": "structimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x306ff259>",
                            "type": "UnknownWord",
                            "value": "smramsmram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2e75d5fb>",
                            "type": "UnknownWord",
                            "value": "_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbbe4007d>",
                            "type": "UnknownWord",
                            "value": "0xffffffff_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf60948a4>",
                            "type": "UnknownWord",
                            "value": "allocate"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3131d19a>",
                            "type": "UnknownWord",
                            "value": "allocated"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2bd42a89>",
                            "type": "UnknownWord",
                            "value": "intr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9471467e>",
                            "type": "UnknownWord",
                            "value": "mem_read"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd08a1abb>",
                            "type": "UnknownWord",
                            "value": "hdr_sz_va"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x20780444>",
                            "type": "UnknownWord",
                            "value": "<i"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac287262>",
                            "type": "UnknownWord",
                            "value": ">>"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb70921eb>",
                            "type": "UnknownWord",
                            "value": "out_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c9bd643>",
                            "type": "UnknownWord",
                            "value": "buffersz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa263693a>",
                            "type": "UnknownWord",
                            "value": "0x100var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4252f11e>",
                            "type": "UnknownWord",
                            "value": "var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4a114121>",
                            "type": "UnknownWord",
                            "value": "read_physical_memmem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcb3c6be8>",
                            "type": "UnknownWord",
                            "value": "_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd6e4e2d5>",
                            "type": "UnknownWord",
                            "value": "handler"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x94f3253e>",
                            "type": "UnknownWord",
                            "value": "_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbac8d6cc>",
                            "type": "UnknownWord",
                            "value": "x00"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9866b1f7>",
                            "type": "UnknownWord",
                            "value": "mem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x331ef1db>",
                            "type": "UnknownWord",
                            "value": "mem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4bb7ce50>",
                            "type": "UnknownWord",
                            "value": "alloc_physical_mem"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf83b6301>",
                            "type": "UnknownWord",
                            "value": "hdr_sz"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe4787692>",
                            "type": "UnknownWord",
                            "value": "get_smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc7d9530d>",
                            "type": "UnknownWord",
                            "value": "highresult"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa3fc3ad5>",
                            "type": "UnknownWord",
                            "value": "0xfffffffffffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe0baaadc>",
                            "type": "UnknownWord",
                            "value": "smram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbf833fdc>",
                            "type": "UnknownWord",
                            "value": "variable_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcdebf4e6>",
                            "type": "UnknownWord",
                            "value": "sz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4c299b67>",
                            "type": "UnknownWord",
                            "value": "var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8bbf54a1>",
                            "type": "UnknownWord",
                            "value": "0xfffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac629237>",
                            "type": "UnknownWord",
                            "value": "binasciiimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x6e4743bd>",
                            "type": "UnknownWord",
                            "value": "low_rbx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa71c0661>",
                            "type": "UnknownWord",
                            "value": "bufferhigh"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x12bc107d>",
                            "type": "UnknownWord",
                            "value": "send_sw_smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa0644f88>",
                            "type": "UnknownWord",
                            "value": "write_physical_memmem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f4e9d84>",
                            "type": "UnknownWord",
                            "value": "hexdump"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1a6eaccf>",
                            "type": "UnknownWord",
                            "value": "addresssmram_addr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4b81bccc>",
                            "type": "UnknownWord",
                            "value": "phys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb629a9e5>",
                            "type": "UnknownWord",
                            "value": "0x20var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc4344a4d>",
                            "type": "UnknownWord",
                            "value": "hdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x33d5b2>",
                            "type": "UnknownWord",
                            "value": "smi_num"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb3b2cd6a>",
                            "type": "UnknownWord",
                            "value": "_rbx"
                        }
                    }
                ]
            }
        ]
    },
    "unknownwords": {
        "UnknownWord": [
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2915bc78>",
                    "type": "UnknownWord",
                    "value": "highimpact"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "When secure isnt secure at all: Highimpact UEFI vulnerabilities discovered in Lenovo consumer laptops"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x63dc41ff>",
                    "type": "UnknownWord",
                    "value": "lenovo"
                },
                "references": {
                    "sentences": [
                        "Its used by the platform firmware to store various information, including the Lenovo product name, motherboard model name and version, OEM OS license, or as mentioned in the section above, in some cases it can be used to activate the ChgBootDxeHook driver in order to disable UEFI Secure Boot feature.",
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register.",
                        "Regarding the vulnerabilities described in this blogpost, we strongly advise all owners of Lenovo laptops to go through the list of affected devices and update their firmware, ideally by following the manufacturers instructions.",
                        "We reported all discovered vulnerabilities to Lenovo on October 11th, 2021. Altogether, the list of affected devices contains more than one hundred different consumer laptop models with millions of users worldwide, from affordable models like Ideapad-3 to more advanced ones like Legion 5 Pro-16ACH6 H or Yoga Slim 9-14ITL05. The full list of affected models with active development support is published in the Lenovo Advisory.",
                        "The firmware on certain Lenovo consumer laptop models implements a special LenovoVariable persistent storage, allowing data storage of up to 4KB in SPI flash.",
                        "In our analysis, we will work with the firmware image (version 1GCN25WW) of the Lenovo 110-15IBR, which is one of the devices affected by the CVE-2021-3971 vulnerability.",
                        "Read Read data from a Lenovo variable<crlf>Write Write data into a Lenovo variable<crlf>Lock Lock a Lenovo variable for write<crlf>Unlock Unlock a Lenovo variable for write",
                        "In the firmware we analyzed, the SMM version of the Lenovo variables functionality is provided to other drivers by the protocol BFD02359-8DFE-459A-8B69-A73A6BAFADC0 (lets name it LENOVO_VARIABLE_PROTOCOL_GUID) and it is installed by the LenovoVariableSmm SMM module.",
                        "In addition to the models listed in the advisory, several other devices we reported to Lenovo are also affected, but wont be fixed due to them reaching End Of Development Support (EODS). This includes devices where we spotted reported vulnerabilities for the first time: Ideapad 330-15IGM and Ideapad 110-15IGR. The list of such EODS devices that we have been able to identify will be available in ESETs vulnerability disclosures repository.",
                        "2021-10-11: Vulnerabilities reported to Lenovo<crlf>2021-10-12: Lenovo responded and confirmed it was investigating the issues<crlf>2021-11-17: Lenovo confirmed the vulnerabilities and informed us of the planned advisory publication date February 8th, 2022<crlf>2022-01-20: Lenovo asked to postpone public disclosure to the new date April 18th due to encountering development issues<crlf>2022-04-18: Lenovo security advisory published<crlf>2022-04-19: ESET Research blogpost published",
                        "ESET researchers have discovered and analyzed three vulnerabilities affecting various Lenovo consumer laptop models. The first two of these vulnerabilities CVE-2021-3971, CVE-2021-3972 affect UEFI firmware drivers originally meant to be used only during the manufacturing process of Lenovo consumer notebooks. Unfortunately, they were mistakenly included also in the production BIOS images without being properly deactivated. These affected firmware drivers can be activated by attacker to directly disable SPI flash protections (BIOS Control Register bits and Protected Range registers) or the UEFI Secure Boot feature from a privileged user-mode process during OS runtime. It means that exploitation of these vulnerabilities would allow attackers to deploy and successfully execute SPI flash or ESP implants, like LoJax or our latest UEFI malware discovery ESPecter, on the affected devices.",
                        "However, on some affected models (for instance on the Lenovo V14-IIL), its not that simple and just creating a ChgBootSecureBootDisable UEFI variable wont disable UEFI Secure Boot. So, whats the catch?",
                        "Find the SMRAM physical address.<crlf>Copy the LENV_HDR header to the physical address 32 bytes before the SMRAM the header should contain a variable identifier (it can be a random GUID) and the length of the data one would like to read from SMRAM (the maximum is something below 4KB).<crlf>Invoke SW SMI registered by the LenovoVariableSmm (SwSmiNumber 0x80), specifying the command with ID 0x02 in the BX register (meaning that you want to write into the Lenovo variable) and the address of previously created header in the ECX and EDI registers (to tell the SW SMI handler what you want to write into that variable).<crlf>Now, that variable contains a specified amount of SMRAM data so we only need to read it. We allocate a new buffer (equal to the size of the header plus the size of data to retrieve) and copy the same header into it, as used in step 2.<crlf>Invoke the SW SMI handler again, specifying the command with ID 0x01 in BX register (meaning that you want to read from the Lenovo variable) and the address of our newly allocated buffer from step 4 in the ECX and EDI registers (to tell the SW SMI handler where we want to copy the content of the Lenovo variable which at this moment contains data from the SMRAM).",
                        "As an example, to disable UEFI Secure Boot on Lenovo 330-15IGM, the user need only create a UEFI variable with:",
                        "Lenovo confirmed the vulnerabilities on November 17th, 2021, and assigned them the following CVEs:",
                        "This physical address passed as an argument to the SMI handler should contain data identifying the Lenovo variable to be read or written; the structure of this buffer is shown in Figure 16.",
                        "In our analysis, we will work with the firmware image (version 7XCN41WW) of the Lenovo 330-15IGM, which is affected by the CVE-2021-3972 vulnerability.",
                        "In this analysis, we will work with the firmware image (version 7XCN41WW) of the Lenovo 330-15IGM, which is affected by the CVE-2021-3970 vulnerability.",
                        "The buffer starts with the 0x20-byte header (LENV_HDR), containing the unique GUID that identifies the Lenovo variable and a 32-bit value specifying the length of the data to be retrieved from the variable or written to it. The memory space located immediately after the header is used as a source or destination location for LENOVO_VARIABLE_PROTOCOLs Read and Write functions.",
                        "To understand how we were able to find these vulnerabilities, consider the firmware drivers affected by CVE2021-3971. These drivers immediately caught our attention by their very unfortunate (but surprisingly honest) names: SecureBackDoor and SecureBackDoorPeim. After some initial analysis, we discovered other Lenovo drivers sharing a few common characteristics with the SecureBackDoor* drivers: ChgBootDxeHook and ChgBootSmm. As it turned out, their functionality was even more interesting and could be abused to disable UEFI Secure Boot (CVE-2021-3972).",
                        "ESET researchers discover multiple vulnerabilities in various Lenovo laptop models that allow an attacker with admin privileges to expose the user to firmware-level malware",
                        "We start with our analysis of the Lenovo drivers affected by CVE-2021-3971 and CVE-2021-3972, and then continue with the SMM vulnerability CVE-2021-3970.",
                        "To be able to write into SMRAM, the principle is almost the same first, the attackers need to write their own data into the Lenovo variable, and then read the data from the variable directly to the SMRAM."
                    ],
                    "titles": [
                        "When secure isnt secure at all: Highimpact UEFI vulnerabilities discovered in Lenovo consumer laptops",
                        "Lenovo variable storage and a vulnerable SW SMI handler"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x63dc41ff>",
                            "type": "UnknownWord",
                            "value": "lenovo"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x63dc41ff>",
                            "type": "UnknownWord",
                            "value": "lenovo"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x63dc41ff>",
                            "type": "UnknownWord",
                            "value": "lenovo"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x63dc41ff>",
                            "type": "UnknownWord",
                            "value": "lenovo"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x63dc41ff>",
                            "type": "UnknownWord",
                            "value": "lenovo"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x63dc41ff>",
                            "type": "UnknownWord",
                            "value": "lenovo"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb6be1193>",
                    "type": "UnknownWord",
                    "value": "firmware-level"
                },
                "references": {
                    "sentences": [
                        "ESET researchers discover multiple vulnerabilities in various Lenovo laptop models that allow an attacker with admin privileges to expose the user to firmware-level malware"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb6b4a231>",
                    "type": "UnknownWord",
                    "value": "notebooks"
                },
                "references": {
                    "sentences": [
                        "ESET researchers have discovered and analyzed three vulnerabilities affecting various Lenovo consumer laptop models. The first two of these vulnerabilities CVE-2021-3971, CVE-2021-3972 affect UEFI firmware drivers originally meant to be used only during the manufacturing process of Lenovo consumer notebooks. Unfortunately, they were mistakenly included also in the production BIOS images without being properly deactivated. These affected firmware drivers can be activated by attacker to directly disable SPI flash protections (BIOS Control Register bits and Protected Range registers) or the UEFI Secure Boot feature from a privileged user-mode process during OS runtime. It means that exploitation of these vulnerabilities would allow attackers to deploy and successfully execute SPI flash or ESP implants, like LoJax or our latest UEFI malware discovery ESPecter, on the affected devices."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8367e1ad>",
                    "type": "UnknownWord",
                    "value": "mistakenly"
                },
                "references": {
                    "sentences": [
                        "ESET researchers have discovered and analyzed three vulnerabilities affecting various Lenovo consumer laptop models. The first two of these vulnerabilities CVE-2021-3971, CVE-2021-3972 affect UEFI firmware drivers originally meant to be used only during the manufacturing process of Lenovo consumer notebooks. Unfortunately, they were mistakenly included also in the production BIOS images without being properly deactivated. These affected firmware drivers can be activated by attacker to directly disable SPI flash protections (BIOS Control Register bits and Protected Range registers) or the UEFI Secure Boot feature from a privileged user-mode process during OS runtime. It means that exploitation of these vulnerabilities would allow attackers to deploy and successfully execute SPI flash or ESP implants, like LoJax or our latest UEFI malware discovery ESPecter, on the affected devices."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe638e0f4>",
                    "type": "UnknownWord",
                    "value": "properly"
                },
                "references": {
                    "sentences": [
                        "Modern systems nowadays usually come with solutions providing hardware-based boot integrity (such as Intel Boot Guard) which, if configured properly and without additional vulnerabilities, protects from booting untrusted firmware code even if the above-mentioned chipset-provided protections fail to protect the SPI flash due to misconfiguration or vulnerability.",
                        "It is important to note that LenovoVariableSmm not only installs this protocol to be accessible by other SMM modules, but it also registers the SW SMI handler function that allows accessing this storage from the OS by invoking SW SMI. The worst part is that it doesnt properly validate parameters passed to the SW SMI handler, which can result in arbitrary read/write from/to the SMRAM.",
                        "ESET researchers have discovered and analyzed three vulnerabilities affecting various Lenovo consumer laptop models. The first two of these vulnerabilities CVE-2021-3971, CVE-2021-3972 affect UEFI firmware drivers originally meant to be used only during the manufacturing process of Lenovo consumer notebooks. Unfortunately, they were mistakenly included also in the production BIOS images without being properly deactivated. These affected firmware drivers can be activated by attacker to directly disable SPI flash protections (BIOS Control Register bits and Protected Range registers) or the UEFI Secure Boot feature from a privileged user-mode process during OS runtime. It means that exploitation of these vulnerabilities would allow attackers to deploy and successfully execute SPI flash or ESP implants, like LoJax or our latest UEFI malware discovery ESPecter, on the affected devices."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x27ef1958>",
                    "type": "UnknownWord",
                    "value": "deactivated"
                },
                "references": {
                    "sentences": [
                        "ESET researchers have discovered and analyzed three vulnerabilities affecting various Lenovo consumer laptop models. The first two of these vulnerabilities CVE-2021-3971, CVE-2021-3972 affect UEFI firmware drivers originally meant to be used only during the manufacturing process of Lenovo consumer notebooks. Unfortunately, they were mistakenly included also in the production BIOS images without being properly deactivated. These affected firmware drivers can be activated by attacker to directly disable SPI flash protections (BIOS Control Register bits and Protected Range registers) or the UEFI Secure Boot feature from a privileged user-mode process during OS runtime. It means that exploitation of these vulnerabilities would allow attackers to deploy and successfully execute SPI flash or ESP implants, like LoJax or our latest UEFI malware discovery ESPecter, on the affected devices."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2becac96>",
                    "type": "UnknownWord",
                    "value": "spi"
                },
                "references": {
                    "sentences": [
                        "Each register specifies independent read/write permissions for a specific range of SPI Flash BIOS region memory. They can be set only if the Flash Configuration Lock-Down (FLOCKDN) bit in Hardware Sequencing Flash Status (HSFS) register is not set.",
                        "We will start with the analysis of the CVE-2021-3971 vulnerability, which allows an attacker to disable SPI flash write-protections mechanisms by simply creating the NVRAM variable. When platform firmware detects this NVRAM variable during bootup, it skips execution of the code responsible for the setting up BIOS Control Register and Protected Range register-based SPI flash protections.",
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register.",
                        "As shown in Figure 8, if it finds out that the BiosLock bit is not set, it will simply skip code responsible for setting these registers and thus leave SPI flash unprotected.",
                        "To disable or deactivate the above-mentioned SPI flash protections by exploiting this vulnerability, the user only needs to create an NVRAM variable with:",
                        "To understand how it actually disables SPI flash protections, we need to look into two different firmware drivers:",
                        "The BIOS Control Register, Protection Range registers, and many other configuration registers can be read or written by accessing the PCI(e) configuration space. The location (or address) of the PCI(e) configuration space for the specific PCI-compatible devices (e.g., SPI flash) is specified by the three values:",
                        "This Disable SPI flash protections feature is implemented by the following drivers in the firmware of affected laptops:",
                        "The firmware on certain Lenovo consumer laptop models implements a special LenovoVariable persistent storage, allowing data storage of up to 4KB in SPI flash.",
                        "In addition, while investigating above mentioned vulnerable drivers, we discovered the third vulnerability: SMM memory corruption inside the SW SMI handler function (CVE-2021-3970). This vulnerability allows arbitrary read/write from/into SMRAM, which can lead to the execution of malicious code with SMM privileges and potentially lead to the deployment of an SPI flash implant.",
                        "As a result, the exploited system will allow modification of the SPI flash even when done from non-SMM code and thus allow an attacker to deploy malicious code directly to the firmware storage.",
                        "In this register, three specific bits are used for SPI flash access control. Note that although they may be named differently on other chipsets, the principle is the same.",
                        "UEFI Secure Boot is defined in the UEFI specification, and its main purpose is to verify the integrity of the boot components to ensure that only components trusted by the platform are allowed to be executed. What components will be included in this verification process depends on the UEFI Secure Boot policy implementation in the specific platform in most cases, only third-party UEFI drivers, applications and OPROMs are being verified, and the drivers on the SPI flash are implicitly considered trusted.",
                        "Modern systems nowadays usually come with solutions providing hardware-based boot integrity (such as Intel Boot Guard) which, if configured properly and without additional vulnerabilities, protects from booting untrusted firmware code even if the above-mentioned chipset-provided protections fail to protect the SPI flash due to misconfiguration or vulnerability.",
                        "Before we start with the analysis of the reported vulnerabilities, we would like to provide an introduction to the basic theory of UEFI protocols, System Management Mode, UEFI NVRAM variables, UEFI Secure Boot, and basic SPI flash write protection.",
                        "ESET researchers have discovered and analyzed three vulnerabilities affecting various Lenovo consumer laptop models. The first two of these vulnerabilities CVE-2021-3971, CVE-2021-3972 affect UEFI firmware drivers originally meant to be used only during the manufacturing process of Lenovo consumer notebooks. Unfortunately, they were mistakenly included also in the production BIOS images without being properly deactivated. These affected firmware drivers can be activated by attacker to directly disable SPI flash protections (BIOS Control Register bits and Protected Range registers) or the UEFI Secure Boot feature from a privileged user-mode process during OS runtime. It means that exploitation of these vulnerabilities would allow attackers to deploy and successfully execute SPI flash or ESP implants, like LoJax or our latest UEFI malware discovery ESPecter, on the affected devices.",
                        "Several security mechanisms are available for the prevention of unwanted modifications of the SPI flash and the primary line of defense is provided by the special memory-mapped configuration registers exposed by the chipset itself the BIOS Control Register and five Protected Range registers.",
                        "UEFI firmware usually resides in the embedded flash memory chip located on the computers motherboard (SPI flash chip). Its non-volatile memory and it is connected to the processor via the Serial Peripheral Interface (SPI).",
                        "We have provided an example of how to read only the first 0x100 bytes of the SMRAM; however, with additional modifications, its possible to read/write the whole SMRAM range. This could allow threat actors to execute their own malicious code in SMM or even worse considering the LenovoVariable SW SMI handlers ability to modify the SPI flash write the attackers own malicious firmware implant directly to the SPI flash.",
                        "CVE-2021-3970 LenovoVariableSmm SMM arbitrary read/write<crlf>CVE-2021-3971 SecureBackDoor disable SPI flash protections<crlf>CVE-2021-3972 ChgBootDxeHook disable UEFI Secure Boot",
                        "As a result, skipping this code will result in misconfiguration of the BIOS Control Registers, exposing the system to the risk of SPI flash modification.",
                        "Figure 6. Hex-Rays-decompiled code from PchBiosWriteProtect responsible for initialization of BIOS Control Register related SPI flash protections",
                        "SecureBackDoor is a DXE driver responsible for deactivating SPI flash protections if it finds a HOB identified by SECURE_BACKDOOR_HOB_GUID in the HOB list. In Figure 5 we can see that to find this HOB, it walks through the list of HOBs, and looks for the one created previously by the SecureBackDoorPeim module by matching it with the SECURE_BACKDOOR_HOB_GUID.",
                        "The second driver, BiosRegionLock, is responsible for setting up Protected Range registers PR0-PR4. Similar to the PchBiosWriteProtect described above, it uses the BiosLock bit inside DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig (type PCH_LOCK_DOWN_CONFIG) to decide whether or not to set SPI flash protections in this case Protected Range registers."
                    ],
                    "titles": [
                        "CVE-2021-3971 SecureBackDoor driver disable SPI flash protections",
                        "Primary SPI flash protection mechanisms"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2becac96>",
                            "type": "UnknownWord",
                            "value": "spi"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6aa78882>",
                    "type": "UnknownWord",
                    "value": "unfortunate"
                },
                "references": {
                    "sentences": [
                        "To understand how we were able to find these vulnerabilities, consider the firmware drivers affected by CVE2021-3971. These drivers immediately caught our attention by their very unfortunate (but surprisingly honest) names: SecureBackDoor and SecureBackDoorPeim. After some initial analysis, we discovered other Lenovo drivers sharing a few common characteristics with the SecureBackDoor* drivers: ChgBootDxeHook and ChgBootSmm. As it turned out, their functionality was even more interesting and could be abused to disable UEFI Secure Boot (CVE-2021-3972)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb2d9e559>",
                    "type": "UnknownWord",
                    "value": "honest"
                },
                "references": {
                    "sentences": [
                        "To understand how we were able to find these vulnerabilities, consider the firmware drivers affected by CVE2021-3971. These drivers immediately caught our attention by their very unfortunate (but surprisingly honest) names: SecureBackDoor and SecureBackDoorPeim. After some initial analysis, we discovered other Lenovo drivers sharing a few common characteristics with the SecureBackDoor* drivers: ChgBootDxeHook and ChgBootSmm. As it turned out, their functionality was even more interesting and could be abused to disable UEFI Secure Boot (CVE-2021-3972)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcfd895ae>",
                    "type": "UnknownWord",
                    "value": "securebackdoor"
                },
                "references": {
                    "sentences": [
                        "Use EFI_PEI_READ_ONLY_VARIABLE2_PPI.GetVariable function with the VariableName and VariableGuid parameters set to values cE! and LENOVO_BACKDOOR_NAMESPACE_GUID respectively.<crlf>To pass this information to the SecureBackDoor DXE driver, create a HOB data structure identified by the following GUID AD7934E7-D800-4305-BF6F-49ED9918E1AB. To make things simpler, lets name this HOB data structure GUID SECURE_BACKDOOR_HOB_GUID.<crlf>Finally, it saves the value retrieved from the cE! variable to offset 0x18 of the newly created HOB.",
                        "At the beginning of our blogpost, we mentioned that the SecureBackDoor* and ChgBoot* drivers share some common characteristics, so what is the connection between them? Both use the UEFI variables within the 6ACCE65D-DA35-4B39-B64B-5ED927A7DC7E namespace as a control mechanism for deciding whether to activate their functionality (we will refer to this GUID as LENOVO_BACKDOOR_NAMESPACE_GUID).",
                        "CVE-2021-3970 LenovoVariableSmm SMM arbitrary read/write<crlf>CVE-2021-3971 SecureBackDoor disable SPI flash protections<crlf>CVE-2021-3972 ChgBootDxeHook disable UEFI Secure Boot",
                        "SecureBackDoor is a DXE driver responsible for deactivating SPI flash protections if it finds a HOB identified by SECURE_BACKDOOR_HOB_GUID in the HOB list. In Figure 5 we can see that to find this HOB, it walks through the list of HOBs, and looks for the one created previously by the SecureBackDoorPeim module by matching it with the SECURE_BACKDOOR_HOB_GUID.",
                        "Figure 5. Hex-Rays-decompiled SecureBackDoor code responsible for finding HOB created by SecureBackdoorPeim",
                        "To understand how we were able to find these vulnerabilities, consider the firmware drivers affected by CVE2021-3971. These drivers immediately caught our attention by their very unfortunate (but surprisingly honest) names: SecureBackDoor and SecureBackDoorPeim. After some initial analysis, we discovered other Lenovo drivers sharing a few common characteristics with the SecureBackDoor* drivers: ChgBootDxeHook and ChgBootSmm. As it turned out, their functionality was even more interesting and could be abused to disable UEFI Secure Boot (CVE-2021-3972).",
                        "SecureBackDoorPeim is a PEI module responsible for both reading the content of the UEFI variable cE!, which belongs to the namespace LENOVO_BACKDOOR_NAMESPACE_GUID, and preparing the correct HOB data structure to pass its value to the SecureBackDoor DXE phase driver.",
                        "SecureBackDoorPeim (16F41157-1DE8-484E-B316-DDB77CB4080C)<crlf>SecureBackDoor (32F16D8C-C094-4102-BD6C-1E533F8810F4)"
                    ],
                    "titles": [
                        "CVE-2021-3971 SecureBackDoor driver disable SPI flash protections",
                        "SecureBackDoor analysis"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa54c5b94>",
                    "type": "UnknownWord",
                    "value": "securebackdoorpeim"
                },
                "references": {
                    "sentences": [
                        "SecureBackDoor is a DXE driver responsible for deactivating SPI flash protections if it finds a HOB identified by SECURE_BACKDOOR_HOB_GUID in the HOB list. In Figure 5 we can see that to find this HOB, it walks through the list of HOBs, and looks for the one created previously by the SecureBackDoorPeim module by matching it with the SECURE_BACKDOOR_HOB_GUID.",
                        "Figure 5. Hex-Rays-decompiled SecureBackDoor code responsible for finding HOB created by SecureBackdoorPeim",
                        "To understand how we were able to find these vulnerabilities, consider the firmware drivers affected by CVE2021-3971. These drivers immediately caught our attention by their very unfortunate (but surprisingly honest) names: SecureBackDoor and SecureBackDoorPeim. After some initial analysis, we discovered other Lenovo drivers sharing a few common characteristics with the SecureBackDoor* drivers: ChgBootDxeHook and ChgBootSmm. As it turned out, their functionality was even more interesting and could be abused to disable UEFI Secure Boot (CVE-2021-3972).",
                        "If this HOB is found, the driver gets the byte value at offset 0x18 which is the value previously retrieved from the cE! UEFI variable by SecureBackDoorPeim and if this value is different from 0x00, it registers the DXE_PCH_PLATFORM_POLICY_PROTOCOL protocol notify function that zeroes the BiosLock bit inside the DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig bitmask (for related type definitions, see TianoCores PchPlatformPolicy.h header file at GitHub).",
                        "SecureBackDoorPeim is a PEI module responsible for both reading the content of the UEFI variable cE!, which belongs to the namespace LENOVO_BACKDOOR_NAMESPACE_GUID, and preparing the correct HOB data structure to pass its value to the SecureBackDoor DXE phase driver.",
                        "SecureBackDoorPeim (16F41157-1DE8-484E-B316-DDB77CB4080C)<crlf>SecureBackDoor (32F16D8C-C094-4102-BD6C-1E533F8810F4)",
                        "Figure 4. Hex-Rays-decompiled code of SecureBackDoorPeim module"
                    ],
                    "titles": [
                        "SecureBackDoorPeim analysis"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa54c5b94>",
                            "type": "UnknownWord",
                            "value": "securebackdoorpeim"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf213589d>",
                    "type": "UnknownWord",
                    "value": "chgbootdxehook"
                },
                "references": {
                    "sentences": [
                        "Its used by the platform firmware to store various information, including the Lenovo product name, motherboard model name and version, OEM OS license, or as mentioned in the section above, in some cases it can be used to activate the ChgBootDxeHook driver in order to disable UEFI Secure Boot feature.",
                        "ChgBootSecureBootDisable and ChgBootChangeLegacy If created (any of them), ChgBootDxeHook disables the UEFI Secure Boot feature during the next boot.<crlf>ChgBootRestoreFactory If created, ChgBootDxeHook restores factory default values for UEFI Secure Boot variables PK, KEK, db, and dbx during the next boot. This might cause several problems, from corrupting the custom Secure Boot keys used by the victim and thus preventing booting the system, to loading the dbx, which might not contain the latest revocation information. The latter could expose the system to the risk of deploying some UEFI applications, such as bootloaders, with known vulnerabilities (e.g. BootHole) and thus allowing an attacker to bypass UEFI Secure Boot verification too.",
                        "CVE-2021-3970 LenovoVariableSmm SMM arbitrary read/write<crlf>CVE-2021-3971 SecureBackDoor disable SPI flash protections<crlf>CVE-2021-3972 ChgBootDxeHook disable UEFI Secure Boot",
                        "Notice the variables starting with the ChgBoot string: these variables are used as commands for the ChgBootDxeHook DXE driver, indicating whether to perform some action or not. In most cases their names are quite self-explanatory and from the security point of view, the following are the most interesting:",
                        "Figure 13. Hex-Rays-decompiled code from ChgBootDxeHook responsible for disabling UEFI Secure Boot",
                        "To understand how we were able to find these vulnerabilities, consider the firmware drivers affected by CVE2021-3971. These drivers immediately caught our attention by their very unfortunate (but surprisingly honest) names: SecureBackDoor and SecureBackDoorPeim. After some initial analysis, we discovered other Lenovo drivers sharing a few common characteristics with the SecureBackDoor* drivers: ChgBootDxeHook and ChgBootSmm. As it turned out, their functionality was even more interesting and could be abused to disable UEFI Secure Boot (CVE-2021-3972).",
                        "Figure 11. Hex-Rays-decompiled function from ChgBootDxeHook checking ChgBoot variables.",
                        "Figure 12. Hex-Rays-decompiled function from ChgBootDxeHook checking the existence of ChgBootSecureBootDisable NVRAM variable",
                        "So far, we know that attackers would need to create the appropriate ChgBoot* UEFI variable to disable UEFI Secure Boot or restore factory UEFI Secure Boot keys during the boot. So how does it work under the hood? This functionality is handled by the ChgBootDxeHook DXE Driver and all of the ChgBoot* UEFI variables are being checked in its sub_3370 function shown in Figure 11."
                    ],
                    "titles": [
                        "CVE-2021-3972 ChgBootDxeHook driver disable UEFI Secure Boot",
                        "ChgBootDxeHook analysis"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe97b5717>",
                    "type": "UnknownWord",
                    "value": "chgbootsmm"
                },
                "references": {
                    "sentences": [
                        "ChgBootSmm is an SMM module responsible for registration of the SW SMI handler function. As shown in Figure 9, it registers this SMI handler using the EFI_SMM_SW_DISPATCH2_PROTOCOL.Register function and sets the SwSmiInputValue to 0xCA. This means that one can trigger execution of this function by writing the value 0xCA to I/O port 0xB2.",
                        "Figure 9. Hex-Rays-decompiled code ChgBootSmm registers SW SMI handler number 0xCA",
                        "Figure 10. Hex-Rays-decompiled code of SW SMI handler installed by the ChgBootSmm driver",
                        "ChgBootSmm (4CA0062A-66FE-4BE7-ACE6-FDE992C1C5EC)<crlf>ChgBootDxeHook (C9C3D147-9A92-4D00-B3AE-970E58B5C3AC)",
                        "To understand how we were able to find these vulnerabilities, consider the firmware drivers affected by CVE2021-3971. These drivers immediately caught our attention by their very unfortunate (but surprisingly honest) names: SecureBackDoor and SecureBackDoorPeim. After some initial analysis, we discovered other Lenovo drivers sharing a few common characteristics with the SecureBackDoor* drivers: ChgBootDxeHook and ChgBootSmm. As it turned out, their functionality was even more interesting and could be abused to disable UEFI Secure Boot (CVE-2021-3972)."
                    ],
                    "titles": [
                        "ChgBootSmm analysis"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd07192c5>",
                    "type": "UnknownWord",
                    "value": "smm"
                },
                "references": {
                    "sentences": [
                        "ChgBootSmm is an SMM module responsible for registration of the SW SMI handler function. As shown in Figure 9, it registers this SMI handler using the EFI_SMM_SW_DISPATCH2_PROTOCOL.Register function and sets the SwSmiInputValue to 0xCA. This means that one can trigger execution of this function by writing the value 0xCA to I/O port 0xB2.",
                        "As written in the specification, this protocol can be used by SMM modules to install handler functions that will respond to specific software interrupts.",
                        "SMM code is written within the context of the system firmware and is usually used for various tasks including advanced power management, execution of OEM proprietary code, and secure firmware updates. It provides an independent execution environment completely invisible to the running operating system, and the code and data used in SMM are stored in hardware-protected memory accessible only from SMM called SMRAM.",
                        "SMM is a highly privileged execution mode of x86 processors, often referred to as ring 2.",
                        "Only in the last year, we have seen numerous high-impact UEFI firmware vulnerabilities being publicly disclosed. Most notable are those by the researchers from Binarly, in their An In-Depth Look At The 23 High-Impact Vulnerabilities and 16 High Impact Vulnerabilities Discovered In HP Devices blogposts, and by researchers from SentinelOne in their Another Brick in the Wall: Uncovering SMM Vulnerabilities in HP Firmware blogpost.",
                        "PchBiosWriteProtect is a SMM module. In Figure 6 we can see that it checks whether the BiosLock bit inside DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig (type PCH_LOCK_DOWN_CONFIG) is set, by performing a bitwise AND operation with value 0x08 (which is 0b1000 in binary representation).",
                        "It is important to note that LenovoVariableSmm not only installs this protocol to be accessible by other SMM modules, but it also registers the SW SMI handler function that allows accessing this storage from the OS by invoking SW SMI. The worst part is that it doesnt properly validate parameters passed to the SW SMI handler, which can result in arbitrary read/write from/to the SMRAM.",
                        "In addition, while investigating above mentioned vulnerable drivers, we discovered the third vulnerability: SMM memory corruption inside the SW SMI handler function (CVE-2021-3970). This vulnerability allows arbitrary read/write from/into SMRAM, which can lead to the execution of malicious code with SMM privileges and potentially lead to the deployment of an SPI flash implant.",
                        "And how does this function from LENOVO_SECURE_BOOT_SERVICES_PROTOCOL disable UEFI Secure Boot? It does so by invoking the SW SMI handler 0xEC registered by VariableRuntimeDxe combined SMM/DXE driver, which in turn sets the authenticated UEFI variable named SecureBootEnforce (namespace EFI_GENERIC_VARIABLE_GUID) to 0x00.",
                        "To enter SMM, a special processor interrupt called SMI (System Management Interrupt) needs to be triggered. SMIs can be triggered via software means or by the platform hardware. For the purposes of this blogpost, its sufficient to understand that one of the ways to generate an SMI (specifically a software SMI SW SMI) and enter SMM on Intel architecture systems is to write to I/O port 0xB2 (using the OUT instruction). This is often used by software to invoke firmware services during system runtime.",
                        "In this last section, we are going to look at the analysis of the CVE-2021-3970 vulnerability caused by an improper input validation in the SW SMI handler function, which can lead to the arbitrary read/write from/to the SMRAM and subsequent arbitrary code execution in SMM execution mode.",
                        "In the firmware we analyzed, the SMM version of the Lenovo variables functionality is provided to other drivers by the protocol BFD02359-8DFE-459A-8B69-A73A6BAFADC0 (lets name it LENOVO_VARIABLE_PROTOCOL_GUID) and it is installed by the LenovoVariableSmm SMM module.",
                        "For models including this check, higher privileges are required to disable secure boot from the OS, but its still possible by invoking the SW SMI handler registered by the LenovoVariableSmm SMM module.",
                        "We have provided an example of how to read only the first 0x100 bytes of the SMRAM; however, with additional modifications, its possible to read/write the whole SMRAM range. This could allow threat actors to execute their own malicious code in SMM or even worse considering the LenovoVariable SW SMI handlers ability to modify the SPI flash write the attackers own malicious firmware implant directly to the SPI flash.",
                        "When set, the BIOS region is not writable unless all processors are in SMM and BIOSWE is 1. Setting this bit resolves the Speed Racer race condition vulnerability (an exploit for this vulnerability was present in the ReWriter_binary tool, which was used by the Sednit group to deploy LoJax).",
                        "CVE-2021-3970 LenovoVariableSmm SMM arbitrary read/write<crlf>CVE-2021-3971 SecureBackDoor disable SPI flash protections<crlf>CVE-2021-3972 ChgBootDxeHook disable UEFI Secure Boot",
                        "When set, BIOSWE could be set from 0 to 1 only by SMM code. Any attempt to set BIOSWE from non-SMM code will trigger SMI. This provides an opportunity for the OEM to implement an SMI handler to protect the BIOSWE bit by setting it back to 0.",
                        "This FLOCKDN bit should be set by the platform firmware during platform initialization right after setting the Protected Range (PR) registers. Once FLOCKDN is set, it is cleared only after the next hardware reset. It means that memory ranges protected by Protected Range registers cant be modified by any runtime code (including SMM code) after they are locked. Even legitimate firmware updates must be performed before PR registers are locked.",
                        "We start with our analysis of the Lenovo drivers affected by CVE-2021-3971 and CVE-2021-3972, and then continue with the SMM vulnerability CVE-2021-3970."
                    ],
                    "titles": [
                        "CVE-2021-3970 Arbitrary SMM read/write",
                        "System Management Mode (SMM)"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2f6c54f9>",
                    "type": "UnknownWord",
                    "value": "corruption"
                },
                "references": {
                    "sentences": [
                        "In addition, while investigating above mentioned vulnerable drivers, we discovered the third vulnerability: SMM memory corruption inside the SW SMI handler function (CVE-2021-3970). This vulnerability allows arbitrary read/write from/into SMRAM, which can lead to the execution of malicious code with SMM privileges and potentially lead to the deployment of an SPI flash implant."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7f6e4417>",
                    "type": "UnknownWord",
                    "value": "smi"
                },
                "references": {
                    "sentences": [
                        "Figure 15. Hex-Rays-decompiled code of SW SMI handler function registered by the LenovoVariableSmm module",
                        "ChgBootSmm is an SMM module responsible for registration of the SW SMI handler function. As shown in Figure 9, it registers this SMI handler using the EFI_SMM_SW_DISPATCH2_PROTOCOL.Register function and sets the SwSmiInputValue to 0xCA. This means that one can trigger execution of this function by writing the value 0xCA to I/O port 0xB2.",
                        "This service installs a DispatchFunction function that will be called when the software SMI source specified by RegisterContext>SwSmiInputValue is detected. In other words, this DispatchFunction will be called when we generate an SW SMI interrupt by writing the same SwSmiInputValue as was specified in the RegisterContext>SwSmiInputValue during handler installation, to the I/O port 0xB2.",
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register.",
                        "The full list of the variables that can be accessed using this SW SMI handler are:",
                        "All of the above-mentioned ChgBoot* UEFI variables can be created even without the help of this SW SMI handler for example using Windows APIs because they are not protected against runtime access. This means that attackers can disable crucial security mechanisms from a user-mode process with administrator privileges.",
                        "In addition, while investigating above mentioned vulnerable drivers, we discovered the third vulnerability: SMM memory corruption inside the SW SMI handler function (CVE-2021-3970). This vulnerability allows arbitrary read/write from/into SMRAM, which can lead to the execution of malicious code with SMM privileges and potentially lead to the deployment of an SPI flash implant.",
                        "It is important to note that LenovoVariableSmm not only installs this protocol to be accessible by other SMM modules, but it also registers the SW SMI handler function that allows accessing this storage from the OS by invoking SW SMI. The worst part is that it doesnt properly validate parameters passed to the SW SMI handler, which can result in arbitrary read/write from/to the SMRAM.",
                        "But still, if there are some readers interested in how it can be done by invoking the SW SMI handler, here is the CHIPSEC command that can be used to create the ChgBootSecureBootDisable variable:",
                        "Figure 10. Hex-Rays-decompiled code of SW SMI handler installed by the ChgBootSmm driver",
                        "And how does this function from LENOVO_SECURE_BOOT_SERVICES_PROTOCOL disable UEFI Secure Boot? It does so by invoking the SW SMI handler 0xEC registered by VariableRuntimeDxe combined SMM/DXE driver, which in turn sets the authenticated UEFI variable named SecureBootEnforce (namespace EFI_GENERIC_VARIABLE_GUID) to 0x00.",
                        "To enter SMM, a special processor interrupt called SMI (System Management Interrupt) needs to be triggered. SMIs can be triggered via software means or by the platform hardware. For the purposes of this blogpost, its sufficient to understand that one of the ways to generate an SMI (specifically a software SMI SW SMI) and enter SMM on Intel architecture systems is to write to I/O port 0xB2 (using the OUT instruction). This is often used by software to invoke firmware services during system runtime.",
                        "In this last section, we are going to look at the analysis of the CVE-2021-3970 vulnerability caused by an improper input validation in the SW SMI handler function, which can lead to the arbitrary read/write from/to the SMRAM and subsequent arbitrary code execution in SMM execution mode.",
                        "For the SW SMI interrupts, parameters are most often passed to the SMI handler using CPU registers. When the SW SMI interrupt is triggered, the context for all of the CPUs at the time of triggering the interrupt is saved to the SMRAM. The invoked SMI handler can easily read and modify this context using the EFI_SMM_CPU_PROTOCOL functions ReadSaveState and WriteSaveState, respectively.",
                        "For models including this check, higher privileges are required to disable secure boot from the OS, but its still possible by invoking the SW SMI handler registered by the LenovoVariableSmm SMM module.",
                        "Find the SMRAM physical address.<crlf>Copy the LENV_HDR header to the physical address 32 bytes before the SMRAM the header should contain a variable identifier (it can be a random GUID) and the length of the data one would like to read from SMRAM (the maximum is something below 4KB).<crlf>Invoke SW SMI registered by the LenovoVariableSmm (SwSmiNumber 0x80), specifying the command with ID 0x02 in the BX register (meaning that you want to write into the Lenovo variable) and the address of previously created header in the ECX and EDI registers (to tell the SW SMI handler what you want to write into that variable).<crlf>Now, that variable contains a specified amount of SMRAM data so we only need to read it. We allocate a new buffer (equal to the size of the header plus the size of data to retrieve) and copy the same header into it, as used in step 2.<crlf>Invoke the SW SMI handler again, specifying the command with ID 0x01 in BX register (meaning that you want to read from the Lenovo variable) and the address of our newly allocated buffer from step 4 in the ECX and EDI registers (to tell the SW SMI handler where we want to copy the content of the Lenovo variable which at this moment contains data from the SMRAM).",
                        "We have provided an example of how to read only the first 0x100 bytes of the SMRAM; however, with additional modifications, its possible to read/write the whole SMRAM range. This could allow threat actors to execute their own malicious code in SMM or even worse considering the LenovoVariable SW SMI handlers ability to modify the SPI flash write the attackers own malicious firmware implant directly to the SPI flash.",
                        "Figure 9. Hex-Rays-decompiled code ChgBootSmm registers SW SMI handler number 0xCA",
                        "To understand what happens under the hood when we use the above-mentioned method of triggering an SW SMI, we need to look into volume 4 of the UEFI Platform Initialization Specification, Version 1.4 (ZIP archive), and find the definition of the EFI_SMM_SW_DISPATCH2_PROTOCOL (shown in Figure 1).",
                        "chipsec_util.py smi send 0 0xCA 0x53 0x53CA 0x1D 0 0xB2",
                        "When set, BIOSWE could be set from 0 to 1 only by SMM code. Any attempt to set BIOSWE from non-SMM code will trigger SMI. This provides an opportunity for the OEM to implement an SMI handler to protect the BIOSWE bit by setting it back to 0.",
                        "This physical address passed as an argument to the SMI handler should contain data identifying the Lenovo variable to be read or written; the structure of this buffer is shown in Figure 16.",
                        "Looking closely at the SW SMI handler function in Figure 15, we see that it begins with reading the user parameters from the CPU saved state registers which are registers saved at the moment of SMI invocation."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f6e4417>",
                            "type": "UnknownWord",
                            "value": "smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f6e4417>",
                            "type": "UnknownWord",
                            "value": "smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f6e4417>",
                            "type": "UnknownWord",
                            "value": "smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f6e4417>",
                            "type": "UnknownWord",
                            "value": "smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdcb228d>",
                            "type": "File",
                            "value": "efi_smm_sw_dispatch2_protocol.register"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f6e4417>",
                            "type": "UnknownWord",
                            "value": "smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f6e4417>",
                            "type": "UnknownWord",
                            "value": "smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f6e4417>",
                            "type": "UnknownWord",
                            "value": "smi"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd6e4e2d5>",
                    "type": "UnknownWord",
                    "value": "handler"
                },
                "references": {
                    "sentences": [
                        "Figure 15. Hex-Rays-decompiled code of SW SMI handler function registered by the LenovoVariableSmm module",
                        "ChgBootSmm is an SMM module responsible for registration of the SW SMI handler function. As shown in Figure 9, it registers this SMI handler using the EFI_SMM_SW_DISPATCH2_PROTOCOL.Register function and sets the SwSmiInputValue to 0xCA. This means that one can trigger execution of this function by writing the value 0xCA to I/O port 0xB2.",
                        "This service installs a DispatchFunction function that will be called when the software SMI source specified by RegisterContext>SwSmiInputValue is detected. In other words, this DispatchFunction will be called when we generate an SW SMI interrupt by writing the same SwSmiInputValue as was specified in the RegisterContext>SwSmiInputValue during handler installation, to the I/O port 0xB2.",
                        "As written in the specification, this protocol can be used by SMM modules to install handler functions that will respond to specific software interrupts.",
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register.",
                        "In the end, DispatchFunction is also responsible for registering SMI handler function (ClearBIOSWE in Figure 7) handling the SMI interrupt, which is triggered when someone tries to set the BIOSWE bit inside the BIOS Control Register from non-SMM code while the BIOS Control Register BLE bit is set. In that case, the installed handler will set BIOSWE (or WPD for our chipset) bit back to 0.",
                        "The full list of the variables that can be accessed using this SW SMI handler are:",
                        "All of the above-mentioned ChgBoot* UEFI variables can be created even without the help of this SW SMI handler for example using Windows APIs because they are not protected against runtime access. This means that attackers can disable crucial security mechanisms from a user-mode process with administrator privileges.",
                        "In addition, while investigating above mentioned vulnerable drivers, we discovered the third vulnerability: SMM memory corruption inside the SW SMI handler function (CVE-2021-3970). This vulnerability allows arbitrary read/write from/into SMRAM, which can lead to the execution of malicious code with SMM privileges and potentially lead to the deployment of an SPI flash implant.",
                        "It is important to note that LenovoVariableSmm not only installs this protocol to be accessible by other SMM modules, but it also registers the SW SMI handler function that allows accessing this storage from the OS by invoking SW SMI. The worst part is that it doesnt properly validate parameters passed to the SW SMI handler, which can result in arbitrary read/write from/to the SMRAM.",
                        "But still, if there are some readers interested in how it can be done by invoking the SW SMI handler, here is the CHIPSEC command that can be used to create the ChgBootSecureBootDisable variable:",
                        "Figure 10. Hex-Rays-decompiled code of SW SMI handler installed by the ChgBootSmm driver",
                        "And how does this function from LENOVO_SECURE_BOOT_SERVICES_PROTOCOL disable UEFI Secure Boot? It does so by invoking the SW SMI handler 0xEC registered by VariableRuntimeDxe combined SMM/DXE driver, which in turn sets the authenticated UEFI variable named SecureBootEnforce (namespace EFI_GENERIC_VARIABLE_GUID) to 0x00.",
                        "In this last section, we are going to look at the analysis of the CVE-2021-3970 vulnerability caused by an improper input validation in the SW SMI handler function, which can lead to the arbitrary read/write from/to the SMRAM and subsequent arbitrary code execution in SMM execution mode.",
                        "For the SW SMI interrupts, parameters are most often passed to the SMI handler using CPU registers. When the SW SMI interrupt is triggered, the context for all of the CPUs at the time of triggering the interrupt is saved to the SMRAM. The invoked SMI handler can easily read and modify this context using the EFI_SMM_CPU_PROTOCOL functions ReadSaveState and WriteSaveState, respectively.",
                        "For models including this check, higher privileges are required to disable secure boot from the OS, but its still possible by invoking the SW SMI handler registered by the LenovoVariableSmm SMM module.",
                        "Find the SMRAM physical address.<crlf>Copy the LENV_HDR header to the physical address 32 bytes before the SMRAM the header should contain a variable identifier (it can be a random GUID) and the length of the data one would like to read from SMRAM (the maximum is something below 4KB).<crlf>Invoke SW SMI registered by the LenovoVariableSmm (SwSmiNumber 0x80), specifying the command with ID 0x02 in the BX register (meaning that you want to write into the Lenovo variable) and the address of previously created header in the ECX and EDI registers (to tell the SW SMI handler what you want to write into that variable).<crlf>Now, that variable contains a specified amount of SMRAM data so we only need to read it. We allocate a new buffer (equal to the size of the header plus the size of data to retrieve) and copy the same header into it, as used in step 2.<crlf>Invoke the SW SMI handler again, specifying the command with ID 0x01 in BX register (meaning that you want to read from the Lenovo variable) and the address of our newly allocated buffer from step 4 in the ECX and EDI registers (to tell the SW SMI handler where we want to copy the content of the Lenovo variable which at this moment contains data from the SMRAM).",
                        "Figure 9. Hex-Rays-decompiled code ChgBootSmm registers SW SMI handler number 0xCA",
                        "To install such a handler function, the EFI_SMM_SW_DISPATCH2_PROTOCOL.Register service function is used; the function type definition is shown in Figure 2.",
                        "This physical address passed as an argument to the SMI handler should contain data identifying the Lenovo variable to be read or written; the structure of this buffer is shown in Figure 16.",
                        "When set, BIOSWE could be set from 0 to 1 only by SMM code. Any attempt to set BIOSWE from non-SMM code will trigger SMI. This provides an opportunity for the OEM to implement an SMI handler to protect the BIOSWE bit by setting it back to 0.",
                        "Looking closely at the SW SMI handler function in Figure 15, we see that it begins with reading the user parameters from the CPU saved state registers which are registers saved at the moment of SMI invocation."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd6e4e2d5>",
                            "type": "UnknownWord",
                            "value": "handler"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd6e4e2d5>",
                            "type": "UnknownWord",
                            "value": "handler"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd6e4e2d5>",
                            "type": "UnknownWord",
                            "value": "handler"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd6e4e2d5>",
                            "type": "UnknownWord",
                            "value": "handler"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd6e4e2d5>",
                            "type": "UnknownWord",
                            "value": "handler"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd6e4e2d5>",
                            "type": "UnknownWord",
                            "value": "handler"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xdcb228d>",
                            "type": "File",
                            "value": "efi_smm_sw_dispatch2_protocol.register"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd6e4e2d5>",
                            "type": "UnknownWord",
                            "value": "handler"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc0845159>",
                    "type": "UnknownWord",
                    "value": "smram"
                },
                "references": {
                    "sentences": [
                        "We have provided an example of how to read only the first 0x100 bytes of the SMRAM; however, with additional modifications, its possible to read/write the whole SMRAM range. This could allow threat actors to execute their own malicious code in SMM or even worse considering the LenovoVariable SW SMI handlers ability to modify the SPI flash write the attackers own malicious firmware implant directly to the SPI flash.",
                        "The problem is, the physical address provided by the caller is not validated or checked in any way and its directly passed as an argument to the LENOVO_VARIABLE_PROTOCOL functions (see line 41 in Figure 15). This allows an attacker to pass any physical address including an address from the SMRAM range.",
                        "In addition, while investigating above mentioned vulnerable drivers, we discovered the third vulnerability: SMM memory corruption inside the SW SMI handler function (CVE-2021-3970). This vulnerability allows arbitrary read/write from/into SMRAM, which can lead to the execution of malicious code with SMM privileges and potentially lead to the deployment of an SPI flash implant.",
                        "It is important to note that LenovoVariableSmm not only installs this protocol to be accessible by other SMM modules, but it also registers the SW SMI handler function that allows accessing this storage from the OS by invoking SW SMI. The worst part is that it doesnt properly validate parameters passed to the SW SMI handler, which can result in arbitrary read/write from/to the SMRAM.",
                        "Figure 18. CHIPSEC script output dumping the first 0x100 bytes of SMRAM",
                        "SMM code is written within the context of the system firmware and is usually used for various tasks including advanced power management, execution of OEM proprietary code, and secure firmware updates. It provides an independent execution environment completely invisible to the running operating system, and the code and data used in SMM are stored in hardware-protected memory accessible only from SMM called SMRAM.",
                        "An example of the above-described steps using the CHIPSEC framework is shown in Figure 17; the output of the script containing the first 0x100 bytes of the SMRAM is shown in Figure 18.",
                        "But how could this be used by an attacker to read/write from/into the SMRAM? To read the SMRAM content, the following steps are required:",
                        "Figure 17. CHIPSEC example read 0x100 bytes from SMRAM by exploiting CVE-2021-3972",
                        "In this last section, we are going to look at the analysis of the CVE-2021-3970 vulnerability caused by an improper input validation in the SW SMI handler function, which can lead to the arbitrary read/write from/to the SMRAM and subsequent arbitrary code execution in SMM execution mode.",
                        "To be able to write into SMRAM, the principle is almost the same first, the attackers need to write their own data into the Lenovo variable, and then read the data from the variable directly to the SMRAM.",
                        "For the SW SMI interrupts, parameters are most often passed to the SMI handler using CPU registers. When the SW SMI interrupt is triggered, the context for all of the CPUs at the time of triggering the interrupt is saved to the SMRAM. The invoked SMI handler can easily read and modify this context using the EFI_SMM_CPU_PROTOCOL functions ReadSaveState and WriteSaveState, respectively.",
                        "Find the SMRAM physical address.<crlf>Copy the LENV_HDR header to the physical address 32 bytes before the SMRAM the header should contain a variable identifier (it can be a random GUID) and the length of the data one would like to read from SMRAM (the maximum is something below 4KB).<crlf>Invoke SW SMI registered by the LenovoVariableSmm (SwSmiNumber 0x80), specifying the command with ID 0x02 in the BX register (meaning that you want to write into the Lenovo variable) and the address of previously created header in the ECX and EDI registers (to tell the SW SMI handler what you want to write into that variable).<crlf>Now, that variable contains a specified amount of SMRAM data so we only need to read it. We allocate a new buffer (equal to the size of the header plus the size of data to retrieve) and copy the same header into it, as used in step 2.<crlf>Invoke the SW SMI handler again, specifying the command with ID 0x01 in BX register (meaning that you want to read from the Lenovo variable) and the address of our newly allocated buffer from step 4 in the ECX and EDI registers (to tell the SW SMI handler where we want to copy the content of the Lenovo variable which at this moment contains data from the SMRAM)."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc0845159>",
                            "type": "UnknownWord",
                            "value": "smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc0845159>",
                            "type": "UnknownWord",
                            "value": "smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc0845159>",
                            "type": "UnknownWord",
                            "value": "smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc0845159>",
                            "type": "UnknownWord",
                            "value": "smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc0845159>",
                            "type": "UnknownWord",
                            "value": "smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc0845159>",
                            "type": "UnknownWord",
                            "value": "smram"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xac9dce9e>",
                    "type": "UnknownWord",
                    "value": "11th"
                },
                "references": {
                    "sentences": [
                        "We reported all discovered vulnerabilities to Lenovo on October 11th, 2021. Altogether, the list of affected devices contains more than one hundred different consumer laptop models with millions of users worldwide, from affordable models like Ideapad-3 to more advanced ones like Legion 5 Pro-16ACH6 H or Yoga Slim 9-14ITL05. The full list of affected models with active development support is published in the Lenovo Advisory."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3d3e9cc4>",
                    "type": "UnknownWord",
                    "value": "altogether"
                },
                "references": {
                    "sentences": [
                        "We reported all discovered vulnerabilities to Lenovo on October 11th, 2021. Altogether, the list of affected devices contains more than one hundred different consumer laptop models with millions of users worldwide, from affordable models like Ideapad-3 to more advanced ones like Legion 5 Pro-16ACH6 H or Yoga Slim 9-14ITL05. The full list of affected models with active development support is published in the Lenovo Advisory."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1aa2610a>",
                    "type": "UnknownWord",
                    "value": "affordable"
                },
                "references": {
                    "sentences": [
                        "We reported all discovered vulnerabilities to Lenovo on October 11th, 2021. Altogether, the list of affected devices contains more than one hundred different consumer laptop models with millions of users worldwide, from affordable models like Ideapad-3 to more advanced ones like Legion 5 Pro-16ACH6 H or Yoga Slim 9-14ITL05. The full list of affected models with active development support is published in the Lenovo Advisory."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcb042814>",
                    "type": "UnknownWord",
                    "value": "ideapad-3"
                },
                "references": {
                    "sentences": [
                        "We reported all discovered vulnerabilities to Lenovo on October 11th, 2021. Altogether, the list of affected devices contains more than one hundred different consumer laptop models with millions of users worldwide, from affordable models like Ideapad-3 to more advanced ones like Legion 5 Pro-16ACH6 H or Yoga Slim 9-14ITL05. The full list of affected models with active development support is published in the Lenovo Advisory."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x64fddf9c>",
                    "type": "UnknownWord",
                    "value": "legion"
                },
                "references": {
                    "sentences": [
                        "We reported all discovered vulnerabilities to Lenovo on October 11th, 2021. Altogether, the list of affected devices contains more than one hundred different consumer laptop models with millions of users worldwide, from affordable models like Ideapad-3 to more advanced ones like Legion 5 Pro-16ACH6 H or Yoga Slim 9-14ITL05. The full list of affected models with active development support is published in the Lenovo Advisory."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb27a132f>",
                    "type": "UnknownWord",
                    "value": "pro-16ach6"
                },
                "references": {
                    "sentences": [
                        "We reported all discovered vulnerabilities to Lenovo on October 11th, 2021. Altogether, the list of affected devices contains more than one hundred different consumer laptop models with millions of users worldwide, from affordable models like Ideapad-3 to more advanced ones like Legion 5 Pro-16ACH6 H or Yoga Slim 9-14ITL05. The full list of affected models with active development support is published in the Lenovo Advisory."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbb917da1>",
                    "type": "UnknownWord",
                    "value": "yoga"
                },
                "references": {
                    "sentences": [
                        "We reported all discovered vulnerabilities to Lenovo on October 11th, 2021. Altogether, the list of affected devices contains more than one hundred different consumer laptop models with millions of users worldwide, from affordable models like Ideapad-3 to more advanced ones like Legion 5 Pro-16ACH6 H or Yoga Slim 9-14ITL05. The full list of affected models with active development support is published in the Lenovo Advisory."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe378b2f>",
                    "type": "UnknownWord",
                    "value": "slim"
                },
                "references": {
                    "sentences": [
                        "We reported all discovered vulnerabilities to Lenovo on October 11th, 2021. Altogether, the list of affected devices contains more than one hundred different consumer laptop models with millions of users worldwide, from affordable models like Ideapad-3 to more advanced ones like Legion 5 Pro-16ACH6 H or Yoga Slim 9-14ITL05. The full list of affected models with active development support is published in the Lenovo Advisory."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfe58b95a>",
                    "type": "UnknownWord",
                    "value": "9-14itl05"
                },
                "references": {
                    "sentences": [
                        "We reported all discovered vulnerabilities to Lenovo on October 11th, 2021. Altogether, the list of affected devices contains more than one hundred different consumer laptop models with millions of users worldwide, from affordable models like Ideapad-3 to more advanced ones like Legion 5 Pro-16ACH6 H or Yoga Slim 9-14ITL05. The full list of affected models with active development support is published in the Lenovo Advisory."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2c179a4e>",
                    "type": "UnknownWord",
                    "value": "eods"
                },
                "references": {
                    "sentences": [
                        "In addition to the models listed in the advisory, several other devices we reported to Lenovo are also affected, but wont be fixed due to them reaching End Of Development Support (EODS). This includes devices where we spotted reported vulnerabilities for the first time: Ideapad 330-15IGM and Ideapad 110-15IGR. The list of such EODS devices that we have been able to identify will be available in ESETs vulnerability disclosures repository.",
                        "For those using End Of Development Support (EODS) devices affected by the CVE-2021-3972, without any fixes available: one thing that can help you protect against unwanted modification of the UEFI Secure Boot state is using a TPM-aware full-disk encryption solution capable of making disk data inaccessible if the UEFI Secure Boot configuration changes."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc66bae46>",
                    "type": "UnknownWord",
                    "value": "ideapad"
                },
                "references": {
                    "sentences": [
                        "In addition to the models listed in the advisory, several other devices we reported to Lenovo are also affected, but wont be fixed due to them reaching End Of Development Support (EODS). This includes devices where we spotted reported vulnerabilities for the first time: Ideapad 330-15IGM and Ideapad 110-15IGR. The list of such EODS devices that we have been able to identify will be available in ESETs vulnerability disclosures repository."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4ea9b01f>",
                    "type": "UnknownWord",
                    "value": "330-15igm"
                },
                "references": {
                    "sentences": [
                        "In addition to the models listed in the advisory, several other devices we reported to Lenovo are also affected, but wont be fixed due to them reaching End Of Development Support (EODS). This includes devices where we spotted reported vulnerabilities for the first time: Ideapad 330-15IGM and Ideapad 110-15IGR. The list of such EODS devices that we have been able to identify will be available in ESETs vulnerability disclosures repository.",
                        "In our analysis, we will work with the firmware image (version 7XCN41WW) of the Lenovo 330-15IGM, which is affected by the CVE-2021-3972 vulnerability.",
                        "As an example, to disable UEFI Secure Boot on Lenovo 330-15IGM, the user need only create a UEFI variable with:",
                        "In this analysis, we will work with the firmware image (version 7XCN41WW) of the Lenovo 330-15IGM, which is affected by the CVE-2021-3970 vulnerability."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xab4f5a25>",
                    "type": "UnknownWord",
                    "value": "110-15igr"
                },
                "references": {
                    "sentences": [
                        "In addition to the models listed in the advisory, several other devices we reported to Lenovo are also affected, but wont be fixed due to them reaching End Of Development Support (EODS). This includes devices where we spotted reported vulnerabilities for the first time: Ideapad 330-15IGM and Ideapad 110-15IGR. The list of such EODS devices that we have been able to identify will be available in ESETs vulnerability disclosures repository."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc1becb5e>",
                    "type": "UnknownWord",
                    "value": "17th"
                },
                "references": {
                    "sentences": [
                        "Lenovo confirmed the vulnerabilities on November 17th, 2021, and assigned them the following CVEs:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7d1052b3>",
                    "type": "UnknownWord",
                    "value": "lenovovariablesmm"
                },
                "references": {
                    "sentences": [
                        "Figure 15. Hex-Rays-decompiled code of SW SMI handler function registered by the LenovoVariableSmm module",
                        "It is important to note that LenovoVariableSmm not only installs this protocol to be accessible by other SMM modules, but it also registers the SW SMI handler function that allows accessing this storage from the OS by invoking SW SMI. The worst part is that it doesnt properly validate parameters passed to the SW SMI handler, which can result in arbitrary read/write from/to the SMRAM.",
                        "CVE-2021-3970 LenovoVariableSmm SMM arbitrary read/write<crlf>CVE-2021-3971 SecureBackDoor disable SPI flash protections<crlf>CVE-2021-3972 ChgBootDxeHook disable UEFI Secure Boot",
                        "In the firmware we analyzed, the SMM version of the Lenovo variables functionality is provided to other drivers by the protocol BFD02359-8DFE-459A-8B69-A73A6BAFADC0 (lets name it LENOVO_VARIABLE_PROTOCOL_GUID) and it is installed by the LenovoVariableSmm SMM module.",
                        "Figure 16. Structure of the buffer passed to the LenovoVariableSmm SW SMI handler",
                        "For models including this check, higher privileges are required to disable secure boot from the OS, but its still possible by invoking the SW SMI handler registered by the LenovoVariableSmm SMM module.",
                        "Find the SMRAM physical address.<crlf>Copy the LENV_HDR header to the physical address 32 bytes before the SMRAM the header should contain a variable identifier (it can be a random GUID) and the length of the data one would like to read from SMRAM (the maximum is something below 4KB).<crlf>Invoke SW SMI registered by the LenovoVariableSmm (SwSmiNumber 0x80), specifying the command with ID 0x02 in the BX register (meaning that you want to write into the Lenovo variable) and the address of previously created header in the ECX and EDI registers (to tell the SW SMI handler what you want to write into that variable).<crlf>Now, that variable contains a specified amount of SMRAM data so we only need to read it. We allocate a new buffer (equal to the size of the header plus the size of data to retrieve) and copy the same header into it, as used in step 2.<crlf>Invoke the SW SMI handler again, specifying the command with ID 0x01 in BX register (meaning that you want to read from the Lenovo variable) and the address of our newly allocated buffer from step 4 in the ECX and EDI registers (to tell the SW SMI handler where we want to copy the content of the Lenovo variable which at this moment contains data from the SMRAM)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdea0b432>",
                    "type": "UnknownWord",
                    "value": "informed"
                },
                "references": {
                    "sentences": [
                        "2021-10-11: Vulnerabilities reported to Lenovo<crlf>2021-10-12: Lenovo responded and confirmed it was investigating the issues<crlf>2021-11-17: Lenovo confirmed the vulnerabilities and informed us of the planned advisory publication date February 8th, 2022<crlf>2022-01-20: Lenovo asked to postpone public disclosure to the new date April 18th due to encountering development issues<crlf>2022-04-18: Lenovo security advisory published<crlf>2022-04-19: ESET Research blogpost published"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc218076c>",
                    "type": "UnknownWord",
                    "value": "planned"
                },
                "references": {
                    "sentences": [
                        "2021-10-11: Vulnerabilities reported to Lenovo<crlf>2021-10-12: Lenovo responded and confirmed it was investigating the issues<crlf>2021-11-17: Lenovo confirmed the vulnerabilities and informed us of the planned advisory publication date February 8th, 2022<crlf>2022-01-20: Lenovo asked to postpone public disclosure to the new date April 18th due to encountering development issues<crlf>2022-04-18: Lenovo security advisory published<crlf>2022-04-19: ESET Research blogpost published"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8f2e440>",
                    "type": "UnknownWord",
                    "value": "8th"
                },
                "references": {
                    "sentences": [
                        "2021-10-11: Vulnerabilities reported to Lenovo<crlf>2021-10-12: Lenovo responded and confirmed it was investigating the issues<crlf>2021-11-17: Lenovo confirmed the vulnerabilities and informed us of the planned advisory publication date February 8th, 2022<crlf>2022-01-20: Lenovo asked to postpone public disclosure to the new date April 18th due to encountering development issues<crlf>2022-04-18: Lenovo security advisory published<crlf>2022-04-19: ESET Research blogpost published"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x88db56aa>",
                    "type": "UnknownWord",
                    "value": "postpone"
                },
                "references": {
                    "sentences": [
                        "2021-10-11: Vulnerabilities reported to Lenovo<crlf>2021-10-12: Lenovo responded and confirmed it was investigating the issues<crlf>2021-11-17: Lenovo confirmed the vulnerabilities and informed us of the planned advisory publication date February 8th, 2022<crlf>2022-01-20: Lenovo asked to postpone public disclosure to the new date April 18th due to encountering development issues<crlf>2022-04-18: Lenovo security advisory published<crlf>2022-04-19: ESET Research blogpost published"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf9c52bcc>",
                    "type": "UnknownWord",
                    "value": "18th"
                },
                "references": {
                    "sentences": [
                        "2021-10-11: Vulnerabilities reported to Lenovo<crlf>2021-10-12: Lenovo responded and confirmed it was investigating the issues<crlf>2021-11-17: Lenovo confirmed the vulnerabilities and informed us of the planned advisory publication date February 8th, 2022<crlf>2022-01-20: Lenovo asked to postpone public disclosure to the new date April 18th due to encountering development issues<crlf>2022-04-18: Lenovo security advisory published<crlf>2022-04-19: ESET Research blogpost published"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x54c5f348>",
                    "type": "UnknownWord",
                    "value": "encountering"
                },
                "references": {
                    "sentences": [
                        "2021-10-11: Vulnerabilities reported to Lenovo<crlf>2021-10-12: Lenovo responded and confirmed it was investigating the issues<crlf>2021-11-17: Lenovo confirmed the vulnerabilities and informed us of the planned advisory publication date February 8th, 2022<crlf>2022-01-20: Lenovo asked to postpone public disclosure to the new date April 18th due to encountering development issues<crlf>2022-04-18: Lenovo security advisory published<crlf>2022-04-19: ESET Research blogpost published"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x85beba5a>",
                    "type": "UnknownWord",
                    "value": "theoretical"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "UEFI firmware theoretical basics"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdcbc706>",
                    "type": "UnknownWord",
                    "value": "nvram"
                },
                "references": {
                    "sentences": [
                        "To decide what is trusted and what is not, UEFI Secure Boot uses special databases stored in the authenticated NVRAM variables, namely db and dbx.",
                        "We will start with the analysis of the CVE-2021-3971 vulnerability, which allows an attacker to disable SPI flash write-protections mechanisms by simply creating the NVRAM variable. When platform firmware detects this NVRAM variable during bootup, it skips execution of the code responsible for the setting up BIOS Control Register and Protected Range register-based SPI flash protections.",
                        "When creating a UEFI variable, attributes are used to indicate how the variable should be stored and maintained by the system this way one can make variables persistent (surviving power cycles), temporary, or even authenticated. Authenticated in the context of the NVRAM variables means that the variable content can be changed only if the new variable data is correctly signed by the authorized private key read access to the variable is allowed to anyone.",
                        "To disable or deactivate the above-mentioned SPI flash protections by exploiting this vulnerability, the user only needs to create an NVRAM variable with:",
                        "Figure 12. Hex-Rays-decompiled function from ChgBootDxeHook checking the existence of ChgBootSecureBootDisable NVRAM variable",
                        "Before we start with the analysis of the reported vulnerabilities, we would like to provide an introduction to the basic theory of UEFI protocols, System Management Mode, UEFI NVRAM variables, UEFI Secure Boot, and basic SPI flash write protection.",
                        "VARIABLE_ATTRIBUTE_NON_VOLATILE (NV)(0x00000001) Variables using this attribute persist across the power cycles and are stored in fixed hardware storage (NVRAM) with limited capacity (typically around 64MB).<crlf>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS (BS)(0x00000002) If the BS attribute is set, variables without the RT attribute set will not be visible to the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices.<crlf>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS (RT)0x00000004) To access a variable via the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices, the RT attribute must be set.<crlf>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS (AW)(0x00000010)<crlf>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS (AWT)(0x00000020)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe4f4a2d1>",
                    "type": "UnknownWord",
                    "value": "jumping"
                },
                "references": {
                    "sentences": [
                        "Note that our aim is to explain only the necessary minimum required for an understanding of the analysis of the vulnerabilities reported here. For those who are already familiar with these topics, we suggest jumping directly to the Technical analysis section. For those who consider this introduction insufficient, we highly recommend looking into the series of blogposts written by researchers from SentinelOne and the UEFI Specification."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8491ab4d>",
                    "type": "UnknownWord",
                    "value": "insufficient"
                },
                "references": {
                    "sentences": [
                        "Note that our aim is to explain only the necessary minimum required for an understanding of the analysis of the vulnerabilities reported here. For those who are already familiar with these topics, we suggest jumping directly to the Technical analysis section. For those who consider this introduction insufficient, we highly recommend looking into the series of blogposts written by researchers from SentinelOne and the UEFI Specification."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x56d92a8d>",
                    "type": "UnknownWord",
                    "value": "specification"
                },
                "references": {
                    "sentences": [
                        "A full list of attributes and their usage rules can be found in the UEFI specification.",
                        "Note that our aim is to explain only the necessary minimum required for an understanding of the analysis of the vulnerabilities reported here. For those who are already familiar with these topics, we suggest jumping directly to the Technical analysis section. For those who consider this introduction insufficient, we highly recommend looking into the series of blogposts written by researchers from SentinelOne and the UEFI Specification.",
                        "As written in the specification, this protocol can be used by SMM modules to install handler functions that will respond to specific software interrupts.",
                        "UEFI Secure Boot is defined in the UEFI specification, and its main purpose is to verify the integrity of the boot components to ensure that only components trusted by the platform are allowed to be executed. What components will be included in this verification process depends on the UEFI Secure Boot policy implementation in the specific platform in most cases, only third-party UEFI drivers, applications and OPROMs are being verified, and the drivers on the SPI flash are implicitly considered trusted.",
                        "To understand what happens under the hood when we use the above-mentioned method of triggering an SW SMI, we need to look into volume 4 of the UEFI Platform Initialization Specification, Version 1.4 (ZIP archive), and find the definition of the EFI_SMM_SW_DISPATCH2_PROTOCOL (shown in Figure 1).",
                        "UEFI boot drivers and applications use protocols extensively. In the context of UEFI, protocols are simply groups of functions identified by a GUID. These protocols, once installed, reside in memory and can be used by other drivers or applications, until EFI_BOOT_SERVICES.ExitBootServices is called. The UEFI specification defines many such protocols to cover the most common firmware use-case scenarios, but firmware developers are still able to define their own protocols to extend this basic functionality."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3f6fec74>",
                    "type": "UnknownWord",
                    "value": "efi_boot_services"
                },
                "references": {
                    "sentences": [
                        "UEFI defines two types of services to be used by UEFI drivers and applications Boot (EFI_BOOT_SERVICES) and Runtime (EFI_RUNTIME_SERVICES) services. Both are passed to the drivers or applications entry point via the EFI_SYSTEM_TABLE argument."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x21ac0891>",
                    "type": "UnknownWord",
                    "value": "efi_runtime_services"
                },
                "references": {
                    "sentences": [
                        "UEFI defines two types of services to be used by UEFI drivers and applications Boot (EFI_BOOT_SERVICES) and Runtime (EFI_RUNTIME_SERVICES) services. Both are passed to the drivers or applications entry point via the EFI_SYSTEM_TABLE argument."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa0d86b23>",
                    "type": "UnknownWord",
                    "value": "efi_system_table"
                },
                "references": {
                    "sentences": [
                        "UEFI defines two types of services to be used by UEFI drivers and applications Boot (EFI_BOOT_SERVICES) and Runtime (EFI_RUNTIME_SERVICES) services. Both are passed to the drivers or applications entry point via the EFI_SYSTEM_TABLE argument."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa46a9646>",
                    "type": "UnknownWord",
                    "value": "locating"
                },
                "references": {
                    "sentences": [
                        "They provide the basic functions and data structures necessary for the drivers and applications to do their job, such as installing protocols, locating existing protocols, memory allocation, UEFI variable manipulation, etc."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xac8b186b>",
                    "type": "UnknownWord",
                    "value": "reside"
                },
                "references": {
                    "sentences": [
                        "UEFI boot drivers and applications use protocols extensively. In the context of UEFI, protocols are simply groups of functions identified by a GUID. These protocols, once installed, reside in memory and can be used by other drivers or applications, until EFI_BOOT_SERVICES.ExitBootServices is called. The UEFI specification defines many such protocols to cover the most common firmware use-case scenarios, but firmware developers are still able to define their own protocols to extend this basic functionality."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xd7ac1e69>",
                            "type": "File",
                            "value": "efi_boot_services.exitbootservices"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac8b186b>",
                            "type": "UnknownWord",
                            "value": "reside"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcf71d910>",
                    "type": "UnknownWord",
                    "value": "use-case"
                },
                "references": {
                    "sentences": [
                        "UEFI boot drivers and applications use protocols extensively. In the context of UEFI, protocols are simply groups of functions identified by a GUID. These protocols, once installed, reside in memory and can be used by other drivers or applications, until EFI_BOOT_SERVICES.ExitBootServices is called. The UEFI specification defines many such protocols to cover the most common firmware use-case scenarios, but firmware developers are still able to define their own protocols to extend this basic functionality."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfb05f48>",
                    "type": "UnknownWord",
                    "value": "namespace"
                },
                "references": {
                    "sentences": [
                        "SecureBackDoorPeim is a PEI module responsible for both reading the content of the UEFI variable cE!, which belongs to the namespace LENOVO_BACKDOOR_NAMESPACE_GUID, and preparing the correct HOB data structure to pass its value to the SecureBackDoor DXE phase driver.",
                        "At the beginning of our blogpost, we mentioned that the SecureBackDoor* and ChgBoot* drivers share some common characteristics, so what is the connection between them? Both use the UEFI variables within the 6ACCE65D-DA35-4B39-B64B-5ED927A7DC7E namespace as a control mechanism for deciding whether to activate their functionality (we will refer to this GUID as LENOVO_BACKDOOR_NAMESPACE_GUID).",
                        "UEFI variables are a special firmware storage mechanism used by UEFI modules to store various configuration data, including boot configuration, UEFI Secure Boot settings, certificates, and similar data. These variables are always identified by a variable name and a namespace (GUID).",
                        "And how does this function from LENOVO_SECURE_BOOT_SERVICES_PROTOCOL disable UEFI Secure Boot? It does so by invoking the SW SMI handler 0xEC registered by VariableRuntimeDxe combined SMM/DXE driver, which in turn sets the authenticated UEFI variable named SecureBootEnforce (namespace EFI_GENERIC_VARIABLE_GUID) to 0x00.",
                        "Namespace: LENOVO_BACKDOOR_NAMESPACE_GUID ChgBootSecureBootDisable ChgBootSetPxeToFirst ChgBootSetEfiPxeOneTime ChgBootRestoreFactory ChgBootFullRese ChgBootSecureBootEnable ChgBootBootOrderSetDefault ChgBootChangeLegacy ChgBootLegacyLoadDefault ChgBootUefiLoadDefault @Rm OneTimeDisableFastBoot<crlf>ChgBootSecureBootDisable<crlf>ChgBootSetPxeToFirst<crlf>ChgBootSetEfiPxeOneTime<crlf>ChgBootRestoreFactory<crlf>ChgBootFullRese<crlf>ChgBootSecureBootEnable<crlf>ChgBootBootOrderSetDefault<crlf>ChgBootChangeLegacy<crlf>ChgBootLegacyLoadDefault<crlf>ChgBootUefiLoadDefault<crlf>@Rm<crlf>OneTimeDisableFastBoot<crlf>Namespace: A04A27F4-DF00-4D42-B552-39511302113D BootType Setup<crlf>BootType<crlf>Setup"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5c0829cd>",
                    "type": "UnknownWord",
                    "value": "surviving"
                },
                "references": {
                    "sentences": [
                        "When creating a UEFI variable, attributes are used to indicate how the variable should be stored and maintained by the system this way one can make variables persistent (surviving power cycles), temporary, or even authenticated. Authenticated in the context of the NVRAM variables means that the variable content can be changed only if the new variable data is correctly signed by the authorized private key read access to the variable is allowed to anyone."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4392f68f>",
                    "type": "UnknownWord",
                    "value": "cycles"
                },
                "references": {
                    "sentences": [
                        "When creating a UEFI variable, attributes are used to indicate how the variable should be stored and maintained by the system this way one can make variables persistent (surviving power cycles), temporary, or even authenticated. Authenticated in the context of the NVRAM variables means that the variable content can be changed only if the new variable data is correctly signed by the authorized private key read access to the variable is allowed to anyone.",
                        "VARIABLE_ATTRIBUTE_NON_VOLATILE (NV)(0x00000001) Variables using this attribute persist across the power cycles and are stored in fixed hardware storage (NVRAM) with limited capacity (typically around 64MB).<crlf>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS (BS)(0x00000002) If the BS attribute is set, variables without the RT attribute set will not be visible to the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices.<crlf>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS (RT)0x00000004) To access a variable via the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices, the RT attribute must be set.<crlf>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS (AW)(0x00000010)<crlf>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS (AWT)(0x00000020)",
                        "When set, access to the BIOS space is enabled for both read and write cycles, otherwise access is read only."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x57cd007c>",
                    "type": "UnknownWord",
                    "value": "correctly"
                },
                "references": {
                    "sentences": [
                        "When creating a UEFI variable, attributes are used to indicate how the variable should be stored and maintained by the system this way one can make variables persistent (surviving power cycles), temporary, or even authenticated. Authenticated in the context of the NVRAM variables means that the variable content can be changed only if the new variable data is correctly signed by the authorized private key read access to the variable is allowed to anyone."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x176ff791>",
                    "type": "UnknownWord",
                    "value": "variable_attribute_non_volatile"
                },
                "references": {
                    "sentences": [
                        "VARIABLE_ATTRIBUTE_NON_VOLATILE (NV)(0x00000001) Variables using this attribute persist across the power cycles and are stored in fixed hardware storage (NVRAM) with limited capacity (typically around 64MB).<crlf>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS (BS)(0x00000002) If the BS attribute is set, variables without the RT attribute set will not be visible to the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices.<crlf>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS (RT)0x00000004) To access a variable via the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices, the RT attribute must be set.<crlf>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS (AW)(0x00000010)<crlf>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS (AWT)(0x00000020)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe388f1f3>",
                    "type": "UnknownWord",
                    "value": "capacity"
                },
                "references": {
                    "sentences": [
                        "VARIABLE_ATTRIBUTE_NON_VOLATILE (NV)(0x00000001) Variables using this attribute persist across the power cycles and are stored in fixed hardware storage (NVRAM) with limited capacity (typically around 64MB).<crlf>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS (BS)(0x00000002) If the BS attribute is set, variables without the RT attribute set will not be visible to the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices.<crlf>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS (RT)0x00000004) To access a variable via the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices, the RT attribute must be set.<crlf>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS (AW)(0x00000010)<crlf>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS (AWT)(0x00000020)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7b0ab366>",
                    "type": "UnknownWord",
                    "value": "64mb"
                },
                "references": {
                    "sentences": [
                        "VARIABLE_ATTRIBUTE_NON_VOLATILE (NV)(0x00000001) Variables using this attribute persist across the power cycles and are stored in fixed hardware storage (NVRAM) with limited capacity (typically around 64MB).<crlf>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS (BS)(0x00000002) If the BS attribute is set, variables without the RT attribute set will not be visible to the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices.<crlf>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS (RT)0x00000004) To access a variable via the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices, the RT attribute must be set.<crlf>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS (AW)(0x00000010)<crlf>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS (AWT)(0x00000020)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc1a8beee>",
                    "type": "UnknownWord",
                    "value": "variable_attribute_bootservice_access"
                },
                "references": {
                    "sentences": [
                        "VARIABLE_ATTRIBUTE_NON_VOLATILE (NV)(0x00000001) Variables using this attribute persist across the power cycles and are stored in fixed hardware storage (NVRAM) with limited capacity (typically around 64MB).<crlf>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS (BS)(0x00000002) If the BS attribute is set, variables without the RT attribute set will not be visible to the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices.<crlf>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS (RT)0x00000004) To access a variable via the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices, the RT attribute must be set.<crlf>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS (AW)(0x00000010)<crlf>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS (AWT)(0x00000020)"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xd7ac1e69>",
                            "type": "File",
                            "value": "efi_boot_services.exitbootservices"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc1a8beee>",
                            "type": "UnknownWord",
                            "value": "variable_attribute_bootservice_access"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd4ba4ffe>",
                    "type": "UnknownWord",
                    "value": "getvariable"
                },
                "references": {
                    "sentences": [
                        "VARIABLE_ATTRIBUTE_NON_VOLATILE (NV)(0x00000001) Variables using this attribute persist across the power cycles and are stored in fixed hardware storage (NVRAM) with limited capacity (typically around 64MB).<crlf>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS (BS)(0x00000002) If the BS attribute is set, variables without the RT attribute set will not be visible to the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices.<crlf>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS (RT)0x00000004) To access a variable via the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices, the RT attribute must be set.<crlf>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS (AW)(0x00000010)<crlf>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS (AWT)(0x00000020)",
                        "As we can see in Figure 12, the function checks for the existence of the ChgBootSecureBootDisable UEFI variable using runtime services GetVariable function and in case it exists whatever its value executes a function we named DisableSecureBoot."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xd7ac1e69>",
                            "type": "File",
                            "value": "efi_boot_services.exitbootservices"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd4ba4ffe>",
                            "type": "UnknownWord",
                            "value": "getvariable"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3ab09ddb>",
                    "type": "UnknownWord",
                    "value": "variable_attribute_runtime_access"
                },
                "references": {
                    "sentences": [
                        "VARIABLE_ATTRIBUTE_NON_VOLATILE (NV)(0x00000001) Variables using this attribute persist across the power cycles and are stored in fixed hardware storage (NVRAM) with limited capacity (typically around 64MB).<crlf>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS (BS)(0x00000002) If the BS attribute is set, variables without the RT attribute set will not be visible to the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices.<crlf>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS (RT)0x00000004) To access a variable via the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices, the RT attribute must be set.<crlf>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS (AW)(0x00000010)<crlf>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS (AWT)(0x00000020)"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xd7ac1e69>",
                            "type": "File",
                            "value": "efi_boot_services.exitbootservices"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3ab09ddb>",
                            "type": "UnknownWord",
                            "value": "variable_attribute_runtime_access"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa8d70925>",
                    "type": "UnknownWord",
                    "value": "variable_attribute_authenticated_write_access"
                },
                "references": {
                    "sentences": [
                        "VARIABLE_ATTRIBUTE_NON_VOLATILE (NV)(0x00000001) Variables using this attribute persist across the power cycles and are stored in fixed hardware storage (NVRAM) with limited capacity (typically around 64MB).<crlf>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS (BS)(0x00000002) If the BS attribute is set, variables without the RT attribute set will not be visible to the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices.<crlf>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS (RT)0x00000004) To access a variable via the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices, the RT attribute must be set.<crlf>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS (AW)(0x00000010)<crlf>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS (AWT)(0x00000020)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb388d81d>",
                    "type": "UnknownWord",
                    "value": "variable_attribute_time_based_authenticated_write_access"
                },
                "references": {
                    "sentences": [
                        "VARIABLE_ATTRIBUTE_NON_VOLATILE (NV)(0x00000001) Variables using this attribute persist across the power cycles and are stored in fixed hardware storage (NVRAM) with limited capacity (typically around 64MB).<crlf>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS (BS)(0x00000002) If the BS attribute is set, variables without the RT attribute set will not be visible to the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices.<crlf>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS (RT)0x00000004) To access a variable via the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices, the RT attribute must be set.<crlf>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS (AW)(0x00000010)<crlf>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS (AWT)(0x00000020)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdba9fba3>",
                    "type": "UnknownWord",
                    "value": "awt"
                },
                "references": {
                    "sentences": [
                        "VARIABLE_ATTRIBUTE_NON_VOLATILE (NV)(0x00000001) Variables using this attribute persist across the power cycles and are stored in fixed hardware storage (NVRAM) with limited capacity (typically around 64MB).<crlf>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS (BS)(0x00000002) If the BS attribute is set, variables without the RT attribute set will not be visible to the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices.<crlf>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS (RT)0x00000004) To access a variable via the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices, the RT attribute must be set.<crlf>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS (AW)(0x00000010)<crlf>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS (AWT)(0x00000020)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7a4888e1>",
                    "type": "UnknownWord",
                    "value": "se_system_environment_name"
                },
                "references": {
                    "sentences": [
                        "To understand how easy this is, Windows users can disable these protections by exploiting the CVE-2021-3971 vulnerability directly from the privileged userland process (administrator with SE_SYSTEM_ENVIRONMENT_NAME privilege) using the Windows API function SetFirmwareEnvironmentVariable.",
                        "To illustrate how easy it is, Windows users can create these variables from the privileged userland process (administrator with SE_SYSTEM_ENVIRONMENT_NAME privilege) using the Windows API function SetFirmwareEnvironmentVariable.",
                        "Its important to note that since Windows 8 an API allows access to UEFI variables from a privileged userland process (administrator with SE_SYSTEM_ENVIRONMENT_NAME privilege).These API functions are:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x60a73242>",
                    "type": "UnknownWord",
                    "value": "setfirmwareenvironmentvariable"
                },
                "references": {
                    "sentences": [
                        "To understand how easy this is, Windows users can disable these protections by exploiting the CVE-2021-3971 vulnerability directly from the privileged userland process (administrator with SE_SYSTEM_ENVIRONMENT_NAME privilege) using the Windows API function SetFirmwareEnvironmentVariable.",
                        "SetFirmwareEnvironmentVariable write/delete variable<crlf>GetFirmwareEnvironmentVariable read variable",
                        "To illustrate how easy it is, Windows users can create these variables from the privileged userland process (administrator with SE_SYSTEM_ENVIRONMENT_NAME privilege) using the Windows API function SetFirmwareEnvironmentVariable."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x579d8844>",
                    "type": "UnknownWord",
                    "value": "getfirmwareenvironmentvariable"
                },
                "references": {
                    "sentences": [
                        "SetFirmwareEnvironmentVariable write/delete variable<crlf>GetFirmwareEnvironmentVariable read variable"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf5cfc06a>",
                    "type": "UnknownWord",
                    "value": "ring"
                },
                "references": {
                    "sentences": [
                        "SMM is a highly privileged execution mode of x86 processors, often referred to as ring 2."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcb0b6d3a>",
                    "type": "UnknownWord",
                    "value": "oem"
                },
                "references": {
                    "sentences": [
                        "Its used by the platform firmware to store various information, including the Lenovo product name, motherboard model name and version, OEM OS license, or as mentioned in the section above, in some cases it can be used to activate the ChgBootDxeHook driver in order to disable UEFI Secure Boot feature.",
                        "SMM code is written within the context of the system firmware and is usually used for various tasks including advanced power management, execution of OEM proprietary code, and secure firmware updates. It provides an independent execution environment completely invisible to the running operating system, and the code and data used in SMM are stored in hardware-protected memory accessible only from SMM called SMRAM.",
                        "When set, BIOSWE could be set from 0 to 1 only by SMM code. Any attempt to set BIOSWE from non-SMM code will trigger SMI. This provides an opportunity for the OEM to implement an SMI handler to protect the BIOSWE bit by setting it back to 0."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9c097051>",
                    "type": "UnknownWord",
                    "value": "invisible"
                },
                "references": {
                    "sentences": [
                        "SMM code is written within the context of the system firmware and is usually used for various tasks including advanced power management, execution of OEM proprietary code, and secure firmware updates. It provides an independent execution environment completely invisible to the running operating system, and the code and data used in SMM are stored in hardware-protected memory accessible only from SMM called SMRAM."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfb76813b>",
                    "type": "UnknownWord",
                    "value": "hardware-protected"
                },
                "references": {
                    "sentences": [
                        "SMM code is written within the context of the system firmware and is usually used for various tasks including advanced power management, execution of OEM proprietary code, and secure firmware updates. It provides an independent execution environment completely invisible to the running operating system, and the code and data used in SMM are stored in hardware-protected memory accessible only from SMM called SMRAM."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x80ab9416>",
                    "type": "UnknownWord",
                    "value": "processor"
                },
                "references": {
                    "sentences": [
                        "To enter SMM, a special processor interrupt called SMI (System Management Interrupt) needs to be triggered. SMIs can be triggered via software means or by the platform hardware. For the purposes of this blogpost, its sufficient to understand that one of the ways to generate an SMI (specifically a software SMI SW SMI) and enter SMM on Intel architecture systems is to write to I/O port 0xB2 (using the OUT instruction). This is often used by software to invoke firmware services during system runtime.",
                        "UEFI firmware usually resides in the embedded flash memory chip located on the computers motherboard (SPI flash chip). Its non-volatile memory and it is connected to the processor via the Serial Peripheral Interface (SPI)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5d6903a>",
                    "type": "UnknownWord",
                    "value": "interrupt"
                },
                "references": {
                    "sentences": [
                        "This service installs a DispatchFunction function that will be called when the software SMI source specified by RegisterContext>SwSmiInputValue is detected. In other words, this DispatchFunction will be called when we generate an SW SMI interrupt by writing the same SwSmiInputValue as was specified in the RegisterContext>SwSmiInputValue during handler installation, to the I/O port 0xB2.",
                        "This vulnerability can be exploited from a privileged kernel-mode process by triggering the software SMI interrupt and passing a physical address of a specially crafted buffer as a parameter to the vulnerable SW SMI handler.",
                        "To enter SMM, a special processor interrupt called SMI (System Management Interrupt) needs to be triggered. SMIs can be triggered via software means or by the platform hardware. For the purposes of this blogpost, its sufficient to understand that one of the ways to generate an SMI (specifically a software SMI SW SMI) and enter SMM on Intel architecture systems is to write to I/O port 0xB2 (using the OUT instruction). This is often used by software to invoke firmware services during system runtime.",
                        "In the end, DispatchFunction is also responsible for registering SMI handler function (ClearBIOSWE in Figure 7) handling the SMI interrupt, which is triggered when someone tries to set the BIOSWE bit inside the BIOS Control Register from non-SMM code while the BIOS Control Register BLE bit is set. In that case, the installed handler will set BIOSWE (or WPD for our chipset) bit back to 0.",
                        "For the SW SMI interrupts, parameters are most often passed to the SMI handler using CPU registers. When the SW SMI interrupt is triggered, the context for all of the CPUs at the time of triggering the interrupt is saved to the SMRAM. The invoked SMI handler can easily read and modify this context using the EFI_SMM_CPU_PROTOCOL functions ReadSaveState and WriteSaveState, respectively."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf0621a40>",
                    "type": "UnknownWord",
                    "value": "smis"
                },
                "references": {
                    "sentences": [
                        "To enter SMM, a special processor interrupt called SMI (System Management Interrupt) needs to be triggered. SMIs can be triggered via software means or by the platform hardware. For the purposes of this blogpost, its sufficient to understand that one of the ways to generate an SMI (specifically a software SMI SW SMI) and enter SMM on Intel architecture systems is to write to I/O port 0xB2 (using the OUT instruction). This is often used by software to invoke firmware services during system runtime."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xaa9e8db5>",
                    "type": "UnknownWord",
                    "value": "smi sw smi"
                },
                "references": {
                    "sentences": [
                        "To enter SMM, a special processor interrupt called SMI (System Management Interrupt) needs to be triggered. SMIs can be triggered via software means or by the platform hardware. For the purposes of this blogpost, its sufficient to understand that one of the ways to generate an SMI (specifically a software SMI SW SMI) and enter SMM on Intel architecture systems is to write to I/O port 0xB2 (using the OUT instruction). This is often used by software to invoke firmware services during system runtime."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb3ac8774>",
                    "type": "UnknownWord",
                    "value": "defining sw smi"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Defining SW SMI handlers in the UEFI firmware"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3b9a0e2a>",
                    "type": "UnknownWord",
                    "value": "hood"
                },
                "references": {
                    "sentences": [
                        "To understand what happens under the hood when we use the above-mentioned method of triggering an SW SMI, we need to look into volume 4 of the UEFI Platform Initialization Specification, Version 1.4 (ZIP archive), and find the definition of the EFI_SMM_SW_DISPATCH2_PROTOCOL (shown in Figure 1).",
                        "So far, we know that attackers would need to create the appropriate ChgBoot* UEFI variable to disable UEFI Secure Boot or restore factory UEFI Secure Boot keys during the boot. So how does it work under the hood? This functionality is handled by the ChgBootDxeHook DXE Driver and all of the ChgBoot* UEFI variables are being checked in its sub_3370 function shown in Figure 11."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x245833ab>",
                    "type": "UnknownWord",
                    "value": "above-mentioned"
                },
                "references": {
                    "sentences": [
                        "All of the above-mentioned ChgBoot* UEFI variables can be created even without the help of this SW SMI handler for example using Windows APIs because they are not protected against runtime access. This means that attackers can disable crucial security mechanisms from a user-mode process with administrator privileges.",
                        "Our discovery, together with the above-mentioned ones, demonstrates that in some cases, deployment of UEFI threats might not be as difficult as expected, and the larger number of real-world UEFI threats discovered in the last years suggests that adversaries are aware of this.",
                        "Modern systems nowadays usually come with solutions providing hardware-based boot integrity (such as Intel Boot Guard) which, if configured properly and without additional vulnerabilities, protects from booting untrusted firmware code even if the above-mentioned chipset-provided protections fail to protect the SPI flash due to misconfiguration or vulnerability.",
                        "To understand what happens under the hood when we use the above-mentioned method of triggering an SW SMI, we need to look into volume 4 of the UEFI Platform Initialization Specification, Version 1.4 (ZIP archive), and find the definition of the EFI_SMM_SW_DISPATCH2_PROTOCOL (shown in Figure 1).",
                        "To disable or deactivate the above-mentioned SPI flash protections by exploiting this vulnerability, the user only needs to create an NVRAM variable with:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x424309bc>",
                    "type": "UnknownWord",
                    "value": "efi_smm_sw_dispatch2_protocol"
                },
                "references": {
                    "sentences": [
                        "To understand what happens under the hood when we use the above-mentioned method of triggering an SW SMI, we need to look into volume 4 of the UEFI Platform Initialization Specification, Version 1.4 (ZIP archive), and find the definition of the EFI_SMM_SW_DISPATCH2_PROTOCOL (shown in Figure 1).",
                        "Figure 1. EFI_SMM_SW_DISPATCH2_PROTOCOL definition"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5c54e4d3>",
                    "type": "UnknownWord",
                    "value": "interrupts"
                },
                "references": {
                    "sentences": [
                        "As written in the specification, this protocol can be used by SMM modules to install handler functions that will respond to specific software interrupts.",
                        "For the SW SMI interrupts, parameters are most often passed to the SMI handler using CPU registers. When the SW SMI interrupt is triggered, the context for all of the CPUs at the time of triggering the interrupt is saved to the SMRAM. The invoked SMI handler can easily read and modify this context using the EFI_SMM_CPU_PROTOCOL functions ReadSaveState and WriteSaveState, respectively."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c54e4d3>",
                            "type": "UnknownWord",
                            "value": "interrupts"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c54e4d3>",
                            "type": "UnknownWord",
                            "value": "interrupts"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c54e4d3>",
                            "type": "UnknownWord",
                            "value": "interrupts"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c54e4d3>",
                            "type": "UnknownWord",
                            "value": "interrupts"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c54e4d3>",
                            "type": "UnknownWord",
                            "value": "interrupts"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c54e4d3>",
                            "type": "UnknownWord",
                            "value": "interrupts"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x17ee68cf>",
                    "type": "UnknownWord",
                    "value": "dispatchfunction"
                },
                "references": {
                    "sentences": [
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register.",
                        "Figure 7. Hex-Rays-decompiled code of DispatchFunction from PchBiosWriteProtect",
                        "In the end, DispatchFunction is also responsible for registering SMI handler function (ClearBIOSWE in Figure 7) handling the SMI interrupt, which is triggered when someone tries to set the BIOSWE bit inside the BIOS Control Register from non-SMM code while the BIOS Control Register BLE bit is set. In that case, the installed handler will set BIOSWE (or WPD for our chipset) bit back to 0.",
                        "This service installs a DispatchFunction function that will be called when the software SMI source specified by RegisterContext>SwSmiInputValue is detected. In other words, this DispatchFunction will be called when we generate an SW SMI interrupt by writing the same SwSmiInputValue as was specified in the RegisterContext>SwSmiInputValue during handler installation, to the I/O port 0xB2."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xaeba899b>",
                    "type": "UnknownWord",
                    "value": "registercontext>swsmiinputvalue"
                },
                "references": {
                    "sentences": [
                        "This service installs a DispatchFunction function that will be called when the software SMI source specified by RegisterContext>SwSmiInputValue is detected. In other words, this DispatchFunction will be called when we generate an SW SMI interrupt by writing the same SwSmiInputValue as was specified in the RegisterContext>SwSmiInputValue during handler installation, to the I/O port 0xB2."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x79b9c207>",
                    "type": "UnknownWord",
                    "value": "swsmiinputvalue"
                },
                "references": {
                    "sentences": [
                        "ChgBootSmm is an SMM module responsible for registration of the SW SMI handler function. As shown in Figure 9, it registers this SMI handler using the EFI_SMM_SW_DISPATCH2_PROTOCOL.Register function and sets the SwSmiInputValue to 0xCA. This means that one can trigger execution of this function by writing the value 0xCA to I/O port 0xB2.",
                        "This service installs a DispatchFunction function that will be called when the software SMI source specified by RegisterContext>SwSmiInputValue is detected. In other words, this DispatchFunction will be called when we generate an SW SMI interrupt by writing the same SwSmiInputValue as was specified in the RegisterContext>SwSmiInputValue during handler installation, to the I/O port 0xB2."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdcb228d>",
                            "type": "File",
                            "value": "efi_smm_sw_dispatch2_protocol.register"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x79b9c207>",
                            "type": "UnknownWord",
                            "value": "swsmiinputvalue"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9a5a3ada>",
                    "type": "UnknownWord",
                    "value": "smi handler"
                },
                "references": {
                    "sentences": [
                        "This vulnerability can be exploited from a privileged kernel-mode process by triggering the software SMI interrupt and passing a physical address of a specially crafted buffer as a parameter to the vulnerable SW SMI handler.",
                        "In the end, DispatchFunction is also responsible for registering SMI handler function (ClearBIOSWE in Figure 7) handling the SMI interrupt, which is triggered when someone tries to set the BIOSWE bit inside the BIOS Control Register from non-SMM code while the BIOS Control Register BLE bit is set. In that case, the installed handler will set BIOSWE (or WPD for our chipset) bit back to 0.",
                        "Figure 16. Structure of the buffer passed to the LenovoVariableSmm SW SMI handler",
                        "For the SW SMI interrupts, parameters are most often passed to the SMI handler using CPU registers. When the SW SMI interrupt is triggered, the context for all of the CPUs at the time of triggering the interrupt is saved to the SMRAM. The invoked SMI handler can easily read and modify this context using the EFI_SMM_CPU_PROTOCOL functions ReadSaveState and WriteSaveState, respectively.",
                        "By looking into this installed SMI handler in Figure 10, we can see that it uses EFI_SMM_VARIABLE_PROTOCOL functions SmmGetVariable and SmmSetVariable to read from and write into various UEFI variables and the decision of what variable will be created or modified is made based on the value from RBX register saved state."
                    ],
                    "titles": [
                        "Lenovo variable storage and a vulnerable SW SMI handler"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5323e639>",
                    "type": "UnknownWord",
                    "value": "invoked"
                },
                "references": {
                    "sentences": [
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register.",
                        "For the SW SMI interrupts, parameters are most often passed to the SMI handler using CPU registers. When the SW SMI interrupt is triggered, the context for all of the CPUs at the time of triggering the interrupt is saved to the SMRAM. The invoked SMI handler can easily read and modify this context using the EFI_SMM_CPU_PROTOCOL functions ReadSaveState and WriteSaveState, respectively."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc72a7380>",
                    "type": "UnknownWord",
                    "value": "efi_smm_cpu_protocol"
                },
                "references": {
                    "sentences": [
                        "For the SW SMI interrupts, parameters are most often passed to the SMI handler using CPU registers. When the SW SMI interrupt is triggered, the context for all of the CPUs at the time of triggering the interrupt is saved to the SMRAM. The invoked SMI handler can easily read and modify this context using the EFI_SMM_CPU_PROTOCOL functions ReadSaveState and WriteSaveState, respectively."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x89c9d24a>",
                    "type": "UnknownWord",
                    "value": "readsavestate"
                },
                "references": {
                    "sentences": [
                        "For the SW SMI interrupts, parameters are most often passed to the SMI handler using CPU registers. When the SW SMI interrupt is triggered, the context for all of the CPUs at the time of triggering the interrupt is saved to the SMRAM. The invoked SMI handler can easily read and modify this context using the EFI_SMM_CPU_PROTOCOL functions ReadSaveState and WriteSaveState, respectively."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf704b75>",
                    "type": "UnknownWord",
                    "value": "writesavestate"
                },
                "references": {
                    "sentences": [
                        "For the SW SMI interrupts, parameters are most often passed to the SMI handler using CPU registers. When the SW SMI interrupt is triggered, the context for all of the CPUs at the time of triggering the interrupt is saved to the SMRAM. The invoked SMI handler can easily read and modify this context using the EFI_SMM_CPU_PROTOCOL functions ReadSaveState and WriteSaveState, respectively."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb7f5b2b5>",
                    "type": "UnknownWord",
                    "value": "resides"
                },
                "references": {
                    "sentences": [
                        "UEFI firmware usually resides in the embedded flash memory chip located on the computers motherboard (SPI flash chip). Its non-volatile memory and it is connected to the processor via the Serial Peripheral Interface (SPI)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbba5694c>",
                    "type": "UnknownWord",
                    "value": "chip"
                },
                "references": {
                    "sentences": [
                        "UEFI firmware usually resides in the embedded flash memory chip located on the computers motherboard (SPI flash chip). Its non-volatile memory and it is connected to the processor via the Serial Peripheral Interface (SPI)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x634a20de>",
                    "type": "UnknownWord",
                    "value": "motherboard"
                },
                "references": {
                    "sentences": [
                        "UEFI firmware usually resides in the embedded flash memory chip located on the computers motherboard (SPI flash chip). Its non-volatile memory and it is connected to the processor via the Serial Peripheral Interface (SPI).",
                        "Its used by the platform firmware to store various information, including the Lenovo product name, motherboard model name and version, OEM OS license, or as mentioned in the section above, in some cases it can be used to activate the ChgBootDxeHook driver in order to disable UEFI Secure Boot feature."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb48c23ab>",
                    "type": "UnknownWord",
                    "value": "non-volatile"
                },
                "references": {
                    "sentences": [
                        "UEFI firmware usually resides in the embedded flash memory chip located on the computers motherboard (SPI flash chip). Its non-volatile memory and it is connected to the processor via the Serial Peripheral Interface (SPI).",
                        "Moreover, each written variable has the same attributes bitmask 0x00000007 (NV|BS|RT) meaning that all of the variables created will be stored in non-volatile storage and thus survive a power cycle."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6c0cbc1f>",
                    "type": "UnknownWord",
                    "value": "peripheral"
                },
                "references": {
                    "sentences": [
                        "UEFI firmware usually resides in the embedded flash memory chip located on the computers motherboard (SPI flash chip). Its non-volatile memory and it is connected to the processor via the Serial Peripheral Interface (SPI)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbfa14442>",
                    "type": "UnknownWord",
                    "value": "reinstallation"
                },
                "references": {
                    "sentences": [
                        "This memory is not affected by operating system reinstallation and therefore presents a tempting target for threat actors deploying their implants as was the case of LoJax, MosaicRegressor, and MoonBounce."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x568942c6>",
                    "type": "UnknownWord",
                    "value": "tempting"
                },
                "references": {
                    "sentences": [
                        "This memory is not affected by operating system reinstallation and therefore presents a tempting target for threat actors deploying their implants as was the case of LoJax, MosaicRegressor, and MoonBounce."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x606bf8f8>",
                    "type": "UnknownWord",
                    "value": "mosaicregressor"
                },
                "references": {
                    "sentences": [
                        "All of the real-world UEFI threats discovered in recent years (LoJax, MosaicRegressor, MoonBounce, ESPecter, FinSpy) needed to bypass or disable the security mechanisms in some way in order to be deployed and executed. However, only in the case of LoJax, the first in-the-wild UEFI rootkit (discovered by ESET Research in 2018), do we have a clue how it was done by using the ReWriter_binary capable of exploiting the Speed Racer vulnerability.",
                        "This memory is not affected by operating system reinstallation and therefore presents a tempting target for threat actors deploying their implants as was the case of LoJax, MosaicRegressor, and MoonBounce."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9bbba92e>",
                    "type": "UnknownWord",
                    "value": "unwanted"
                },
                "references": {
                    "sentences": [
                        "For those using End Of Development Support (EODS) devices affected by the CVE-2021-3972, without any fixes available: one thing that can help you protect against unwanted modification of the UEFI Secure Boot state is using a TPM-aware full-disk encryption solution capable of making disk data inaccessible if the UEFI Secure Boot configuration changes.",
                        "Several security mechanisms are available for the prevention of unwanted modifications of the SPI flash and the primary line of defense is provided by the special memory-mapped configuration registers exposed by the chipset itself the BIOS Control Register and five Protected Range registers."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x53358eff>",
                    "type": "UnknownWord",
                    "value": "memory-mapped"
                },
                "references": {
                    "sentences": [
                        "Several security mechanisms are available for the prevention of unwanted modifications of the SPI flash and the primary line of defense is provided by the special memory-mapped configuration registers exposed by the chipset itself the BIOS Control Register and five Protected Range registers.",
                        "When using Memory-Mapped I/O, the PCI configuration space is mapped directly to main memory address space; therefore, the configuration data can be accessed almost the same way as any other data. All that needs to be known is the PCI address of the desired data, so where can we find this address? We can construct it on our own if we know:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa6e4fcb5>",
                    "type": "UnknownWord",
                    "value": "principle"
                },
                "references": {
                    "sentences": [
                        "To be able to write into SMRAM, the principle is almost the same first, the attackers need to write their own data into the Lenovo variable, and then read the data from the variable directly to the SMRAM.",
                        "In this register, three specific bits are used for SPI flash access control. Note that although they may be named differently on other chipsets, the principle is the same."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4e1f886f>",
                    "type": "UnknownWord",
                    "value": "bioswe"
                },
                "references": {
                    "sentences": [
                        "BIOSWE (bit 0)",
                        "When set, the BIOS region is not writable unless all processors are in SMM and BIOSWE is 1. Setting this bit resolves the Speed Racer race condition vulnerability (an exploit for this vulnerability was present in the ReWriter_binary tool, which was used by the Sednit group to deploy LoJax).",
                        "In the end, DispatchFunction is also responsible for registering SMI handler function (ClearBIOSWE in Figure 7) handling the SMI interrupt, which is triggered when someone tries to set the BIOSWE bit inside the BIOS Control Register from non-SMM code while the BIOS Control Register BLE bit is set. In that case, the installed handler will set BIOSWE (or WPD for our chipset) bit back to 0.",
                        "When set, BIOSWE could be set from 0 to 1 only by SMM code. Any attempt to set BIOSWE from non-SMM code will trigger SMI. This provides an opportunity for the OEM to implement an SMI handler to protect the BIOSWE bit by setting it back to 0."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe8cbee13>",
                    "type": "UnknownWord",
                    "value": "ble"
                },
                "references": {
                    "sentences": [
                        "BLE (bit 1)",
                        "In the end, DispatchFunction is also responsible for registering SMI handler function (ClearBIOSWE in Figure 7) handling the SMI interrupt, which is triggered when someone tries to set the BIOSWE bit inside the BIOS Control Register from non-SMM code while the BIOS Control Register BLE bit is set. In that case, the installed handler will set BIOSWE (or WPD for our chipset) bit back to 0."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd5522e2a>",
                    "type": "UnknownWord",
                    "value": "non-smm"
                },
                "references": {
                    "sentences": [
                        "As a result, the exploited system will allow modification of the SPI flash even when done from non-SMM code and thus allow an attacker to deploy malicious code directly to the firmware storage.",
                        "In the end, DispatchFunction is also responsible for registering SMI handler function (ClearBIOSWE in Figure 7) handling the SMI interrupt, which is triggered when someone tries to set the BIOSWE bit inside the BIOS Control Register from non-SMM code while the BIOS Control Register BLE bit is set. In that case, the installed handler will set BIOSWE (or WPD for our chipset) bit back to 0.",
                        "When set, BIOSWE could be set from 0 to 1 only by SMM code. Any attempt to set BIOSWE from non-SMM code will trigger SMI. This provides an opportunity for the OEM to implement an SMI handler to protect the BIOSWE bit by setting it back to 0."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1d402266>",
                    "type": "UnknownWord",
                    "value": "smm_bwp"
                },
                "references": {
                    "sentences": [
                        "SMM_BWP (bit 5)",
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1470e3ba>",
                    "type": "UnknownWord",
                    "value": "writable"
                },
                "references": {
                    "sentences": [
                        "When set, the BIOS region is not writable unless all processors are in SMM and BIOSWE is 1. Setting this bit resolves the Speed Racer race condition vulnerability (an exploit for this vulnerability was present in the ReWriter_binary tool, which was used by the Sednit group to deploy LoJax)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc126d1be>",
                    "type": "UnknownWord",
                    "value": "unless"
                },
                "references": {
                    "sentences": [
                        "When set, the BIOS region is not writable unless all processors are in SMM and BIOSWE is 1. Setting this bit resolves the Speed Racer race condition vulnerability (an exploit for this vulnerability was present in the ReWriter_binary tool, which was used by the Sednit group to deploy LoJax)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xea9e288a>",
                    "type": "UnknownWord",
                    "value": "racer"
                },
                "references": {
                    "sentences": [
                        "All of the real-world UEFI threats discovered in recent years (LoJax, MosaicRegressor, MoonBounce, ESPecter, FinSpy) needed to bypass or disable the security mechanisms in some way in order to be deployed and executed. However, only in the case of LoJax, the first in-the-wild UEFI rootkit (discovered by ESET Research in 2018), do we have a clue how it was done by using the ReWriter_binary capable of exploiting the Speed Racer vulnerability.",
                        "When set, the BIOS region is not writable unless all processors are in SMM and BIOSWE is 1. Setting this bit resolves the Speed Racer race condition vulnerability (an exploit for this vulnerability was present in the ReWriter_binary tool, which was used by the Sednit group to deploy LoJax)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe0fa9b2e>",
                    "type": "UnknownWord",
                    "value": "race"
                },
                "references": {
                    "sentences": [
                        "When set, the BIOS region is not writable unless all processors are in SMM and BIOSWE is 1. Setting this bit resolves the Speed Racer race condition vulnerability (an exploit for this vulnerability was present in the ReWriter_binary tool, which was used by the Sednit group to deploy LoJax)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe015e56c>",
                    "type": "UnknownWord",
                    "value": "rewriter_binary"
                },
                "references": {
                    "sentences": [
                        "All of the real-world UEFI threats discovered in recent years (LoJax, MosaicRegressor, MoonBounce, ESPecter, FinSpy) needed to bypass or disable the security mechanisms in some way in order to be deployed and executed. However, only in the case of LoJax, the first in-the-wild UEFI rootkit (discovered by ESET Research in 2018), do we have a clue how it was done by using the ReWriter_binary capable of exploiting the Speed Racer vulnerability.",
                        "When set, the BIOS region is not writable unless all processors are in SMM and BIOSWE is 1. Setting this bit resolves the Speed Racer race condition vulnerability (an exploit for this vulnerability was present in the ReWriter_binary tool, which was used by the Sednit group to deploy LoJax)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe0c757ab>",
                    "type": "UnknownWord",
                    "value": "pr0-pr4"
                },
                "references": {
                    "sentences": [
                        "The second driver, BiosRegionLock, is responsible for setting up Protected Range registers PR0-PR4. Similar to the PchBiosWriteProtect described above, it uses the BiosLock bit inside DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig (type PCH_LOCK_DOWN_CONFIG) to decide whether or not to set SPI flash protections in this case Protected Range registers."
                    ],
                    "titles": [
                        "Protected Range registers (PR0-PR4)"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2095f311>",
                    "type": "UnknownWord",
                    "value": "specifies"
                },
                "references": {
                    "sentences": [
                        "Each register specifies independent read/write permissions for a specific range of SPI Flash BIOS region memory. They can be set only if the Flash Configuration Lock-Down (FLOCKDN) bit in Hardware Sequencing Flash Status (HSFS) register is not set."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcc8948da>",
                    "type": "UnknownWord",
                    "value": "lock-down"
                },
                "references": {
                    "sentences": [
                        "Each register specifies independent read/write permissions for a specific range of SPI Flash BIOS region memory. They can be set only if the Flash Configuration Lock-Down (FLOCKDN) bit in Hardware Sequencing Flash Status (HSFS) register is not set."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe4715ac9>",
                    "type": "UnknownWord",
                    "value": "flockdn"
                },
                "references": {
                    "sentences": [
                        "Each register specifies independent read/write permissions for a specific range of SPI Flash BIOS region memory. They can be set only if the Flash Configuration Lock-Down (FLOCKDN) bit in Hardware Sequencing Flash Status (HSFS) register is not set.",
                        "This FLOCKDN bit should be set by the platform firmware during platform initialization right after setting the Protected Range (PR) registers. Once FLOCKDN is set, it is cleared only after the next hardware reset. It means that memory ranges protected by Protected Range registers cant be modified by any runtime code (including SMM code) after they are locked. Even legitimate firmware updates must be performed before PR registers are locked."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x861f7da9>",
                    "type": "UnknownWord",
                    "value": "sequencing"
                },
                "references": {
                    "sentences": [
                        "Each register specifies independent read/write permissions for a specific range of SPI Flash BIOS region memory. They can be set only if the Flash Configuration Lock-Down (FLOCKDN) bit in Hardware Sequencing Flash Status (HSFS) register is not set."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x679c8a78>",
                    "type": "UnknownWord",
                    "value": "hsfs"
                },
                "references": {
                    "sentences": [
                        "Each register specifies independent read/write permissions for a specific range of SPI Flash BIOS region memory. They can be set only if the Flash Configuration Lock-Down (FLOCKDN) bit in Hardware Sequencing Flash Status (HSFS) register is not set."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7075834a>",
                    "type": "UnknownWord",
                    "value": "chipset-provided"
                },
                "references": {
                    "sentences": [
                        "Modern systems nowadays usually come with solutions providing hardware-based boot integrity (such as Intel Boot Guard) which, if configured properly and without additional vulnerabilities, protects from booting untrusted firmware code even if the above-mentioned chipset-provided protections fail to protect the SPI flash due to misconfiguration or vulnerability."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe6f70764>",
                    "type": "UnknownWord",
                    "value": "misconfiguration"
                },
                "references": {
                    "sentences": [
                        "Modern systems nowadays usually come with solutions providing hardware-based boot integrity (such as Intel Boot Guard) which, if configured properly and without additional vulnerabilities, protects from booting untrusted firmware code even if the above-mentioned chipset-provided protections fail to protect the SPI flash due to misconfiguration or vulnerability.",
                        "As a result, skipping this code will result in misconfiguration of the BIOS Control Registers, exposing the system to the risk of SPI flash modification."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf1d95265>",
                    "type": "UnknownWord",
                    "value": "pci"
                },
                "references": {
                    "sentences": [
                        "The BIOS Control Register, Protection Range registers, and many other configuration registers can be read or written by accessing the PCI(e) configuration space. The location (or address) of the PCI(e) configuration space for the specific PCI-compatible devices (e.g., SPI flash) is specified by the three values:",
                        "An example of the macro encoding these values into PCI address can be found in EDK2s PciLib.h header file. Alternatively, a Python implementation of the functions translating MMIO PCI address to individual identifiers and vice versa is shown in Figure 3.",
                        "When using Memory-Mapped I/O, the PCI configuration space is mapped directly to main memory address space; therefore, the configuration data can be accessed almost the same way as any other data. All that needs to be known is the PCI address of the desired data, so where can we find this address? We can construct it on our own if we know:",
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register.",
                        "Configurations related to this device are located at the offsets within this configuration space. There are two common ways to access the PCI(e) configuration space:",
                        "In this case, machine I/O instructions IN and OUT in combination with 0xCF8 (CONFIG_ADDRESS) and 0xCFC (CONFIG_DATA) I/O ports are used to access specific configuration data in PCI configuration space. As it is not necessary for the purpose of our blogpost, we will not be diving into the details here.",
                        "Figure 3. PCI address encoding/decoding in Python"
                    ],
                    "titles": [
                        "How to access PCI/PCIe configuration space"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x270462eb>",
                    "type": "UnknownWord",
                    "value": "pcie"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "How to access PCI/PCIe configuration space"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8f508b24>",
                    "type": "UnknownWord",
                    "value": "pci-compatible"
                },
                "references": {
                    "sentences": [
                        "The BIOS Control Register, Protection Range registers, and many other configuration registers can be read or written by accessing the PCI(e) configuration space. The location (or address) of the PCI(e) configuration space for the specific PCI-compatible devices (e.g., SPI flash) is specified by the three values:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdf0e2633>",
                    "type": "UnknownWord",
                    "value": "bus"
                },
                "references": {
                    "sentences": [
                        "Bus<crlf>Device<crlf>Function",
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register.",
                        "the MMIO base address (can be found inside MCFG ACPI table)<crlf>Bus, Device, Function, and Offset (also referred to as Register) values identifying the data that we want to access (you can find them in a chipsets datasheet)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x215c2d55>",
                    "type": "UnknownWord",
                    "value": "offsets"
                },
                "references": {
                    "sentences": [
                        "Configurations related to this device are located at the offsets within this configuration space. There are two common ways to access the PCI(e) configuration space:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xff0d585b>",
                    "type": "UnknownWord",
                    "value": "config_address"
                },
                "references": {
                    "sentences": [
                        "In this case, machine I/O instructions IN and OUT in combination with 0xCF8 (CONFIG_ADDRESS) and 0xCFC (CONFIG_DATA) I/O ports are used to access specific configuration data in PCI configuration space. As it is not necessary for the purpose of our blogpost, we will not be diving into the details here."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf90f4038>",
                    "type": "UnknownWord",
                    "value": "config_data"
                },
                "references": {
                    "sentences": [
                        "In this case, machine I/O instructions IN and OUT in combination with 0xCF8 (CONFIG_ADDRESS) and 0xCFC (CONFIG_DATA) I/O ports are used to access specific configuration data in PCI configuration space. As it is not necessary for the purpose of our blogpost, we will not be diving into the details here."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x29503c7c>",
                    "type": "UnknownWord",
                    "value": "mmio"
                },
                "references": {
                    "sentences": [
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register.",
                        "Using Memory Mapped I/O (MMIO)",
                        "the MMIO base address (can be found inside MCFG ACPI table)<crlf>Bus, Device, Function, and Offset (also referred to as Register) values identifying the data that we want to access (you can find them in a chipsets datasheet).",
                        "An example of the macro encoding these values into PCI address can be found in EDK2s PciLib.h header file. Alternatively, a Python implementation of the functions translating MMIO PCI address to individual identifiers and vice versa is shown in Figure 3."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xedd6f487>",
                    "type": "UnknownWord",
                    "value": "accessed"
                },
                "references": {
                    "sentences": [
                        "As we can see in Figure 14, after the ChgBootSecureBootDisable variable check, another condition is present it disables UEFI Secure Boot only if the value retrieved from the special LenovoVariable persistent storage, accessed using a protocol identified by the GUID C20E5755-1169-4C56-A48A-9824AB430D00 (LENOVO_VARIABLE_PROTOCOL_GUID in Figure 14), contains value Y (0x59).",
                        "The full list of the variables that can be accessed using this SW SMI handler are:",
                        "When using Memory-Mapped I/O, the PCI configuration space is mapped directly to main memory address space; therefore, the configuration data can be accessed almost the same way as any other data. All that needs to be known is the PCI address of the desired data, so where can we find this address? We can construct it on our own if we know:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe04a1488>",
                    "type": "UnknownWord",
                    "value": "mcfg"
                },
                "references": {
                    "sentences": [
                        "the MMIO base address (can be found inside MCFG ACPI table)<crlf>Bus, Device, Function, and Offset (also referred to as Register) values identifying the data that we want to access (you can find them in a chipsets datasheet)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd02ded66>",
                    "type": "UnknownWord",
                    "value": "acpi"
                },
                "references": {
                    "sentences": [
                        "the MMIO base address (can be found inside MCFG ACPI table)<crlf>Bus, Device, Function, and Offset (also referred to as Register) values identifying the data that we want to access (you can find them in a chipsets datasheet)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7bf80a4>",
                    "type": "UnknownWord",
                    "value": "offset"
                },
                "references": {
                    "sentences": [
                        "Use EFI_PEI_READ_ONLY_VARIABLE2_PPI.GetVariable function with the VariableName and VariableGuid parameters set to values cE! and LENOVO_BACKDOOR_NAMESPACE_GUID respectively.<crlf>To pass this information to the SecureBackDoor DXE driver, create a HOB data structure identified by the following GUID AD7934E7-D800-4305-BF6F-49ED9918E1AB. To make things simpler, lets name this HOB data structure GUID SECURE_BACKDOOR_HOB_GUID.<crlf>Finally, it saves the value retrieved from the cE! variable to offset 0x18 of the newly created HOB.",
                        "Sets byte value of the Setup UEFI variable at offset 0x4D9 to zero; this byte seems to be an indicator of the UEFI Secure Boot status inside the BIOS Setup utility.<crlf>Invokes protocol function (protocol GUID C706D63F-6CCE-48AD-A2B4-72A5EF9E220C or LENOVO_SECURE_BOOT_SERVICES_PROTOCOL_GUID in Figure 13) installed by the SecureBootService DXE driver with a parameter identifying an operation to be performed, in this case the operation identified by the value 0x02 which means the disabling of UEFI Secure Boot.",
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register.",
                        "If this HOB is found, the driver gets the byte value at offset 0x18 which is the value previously retrieved from the cE! UEFI variable by SecureBackDoorPeim and if this value is different from 0x00, it registers the DXE_PCH_PLATFORM_POLICY_PROTOCOL protocol notify function that zeroes the BiosLock bit inside the DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig bitmask (for related type definitions, see TianoCores PchPlatformPolicy.h header file at GitHub).",
                        "the MMIO base address (can be found inside MCFG ACPI table)<crlf>Bus, Device, Function, and Offset (also referred to as Register) values identifying the data that we want to access (you can find them in a chipsets datasheet)."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7bf80a4>",
                            "type": "UnknownWord",
                            "value": "offset"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x790ae60e>",
                    "type": "UnknownWord",
                    "value": "datasheet"
                },
                "references": {
                    "sentences": [
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register.",
                        "the MMIO base address (can be found inside MCFG ACPI table)<crlf>Bus, Device, Function, and Offset (also referred to as Register) values identifying the data that we want to access (you can find them in a chipsets datasheet)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x58635d4d>",
                    "type": "UnknownWord",
                    "value": "edk2s"
                },
                "references": {
                    "sentences": [
                        "An example of the macro encoding these values into PCI address can be found in EDK2s PciLib.h header file. Alternatively, a Python implementation of the functions translating MMIO PCI address to individual identifiers and vice versa is shown in Figure 3."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9f1fa703>",
                    "type": "UnknownWord",
                    "value": "pcilib"
                },
                "references": {
                    "sentences": [
                        "An example of the macro encoding these values into PCI address can be found in EDK2s PciLib.h header file. Alternatively, a Python implementation of the functions translating MMIO PCI address to individual identifiers and vice versa is shown in Figure 3."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe4bc47e6>",
                    "type": "UnknownWord",
                    "value": "alternatively"
                },
                "references": {
                    "sentences": [
                        "An example of the macro encoding these values into PCI address can be found in EDK2s PciLib.h header file. Alternatively, a Python implementation of the functions translating MMIO PCI address to individual identifiers and vice versa is shown in Figure 3."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3191c3c1>",
                    "type": "UnknownWord",
                    "value": "translating"
                },
                "references": {
                    "sentences": [
                        "An example of the macro encoding these values into PCI address can be found in EDK2s PciLib.h header file. Alternatively, a Python implementation of the functions translating MMIO PCI address to individual identifiers and vice versa is shown in Figure 3."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1bd4cd7d>",
                    "type": "UnknownWord",
                    "value": "vice"
                },
                "references": {
                    "sentences": [
                        "An example of the macro encoding these values into PCI address can be found in EDK2s PciLib.h header file. Alternatively, a Python implementation of the functions translating MMIO PCI address to individual identifiers and vice versa is shown in Figure 3."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf6a0532c>",
                    "type": "UnknownWord",
                    "value": "versa"
                },
                "references": {
                    "sentences": [
                        "An example of the macro encoding these values into PCI address can be found in EDK2s PciLib.h header file. Alternatively, a Python implementation of the functions translating MMIO PCI address to individual identifiers and vice versa is shown in Figure 3."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd98f7463>",
                    "type": "UnknownWord",
                    "value": "oproms"
                },
                "references": {
                    "sentences": [
                        "UEFI Secure Boot is defined in the UEFI specification, and its main purpose is to verify the integrity of the boot components to ensure that only components trusted by the platform are allowed to be executed. What components will be included in this verification process depends on the UEFI Secure Boot policy implementation in the specific platform in most cases, only third-party UEFI drivers, applications and OPROMs are being verified, and the drivers on the SPI flash are implicitly considered trusted."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4e2f3e6c>",
                    "type": "UnknownWord",
                    "value": "implicitly"
                },
                "references": {
                    "sentences": [
                        "UEFI Secure Boot is defined in the UEFI specification, and its main purpose is to verify the integrity of the boot components to ensure that only components trusted by the platform are allowed to be executed. What components will be included in this verification process depends on the UEFI Secure Boot policy implementation in the specific platform in most cases, only third-party UEFI drivers, applications and OPROMs are being verified, and the drivers on the SPI flash are implicitly considered trusted."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe42e0cf1>",
                    "type": "UnknownWord",
                    "value": "decide"
                },
                "references": {
                    "sentences": [
                        "To decide what is trusted and what is not, UEFI Secure Boot uses special databases stored in the authenticated NVRAM variables, namely db and dbx.",
                        "The second driver, BiosRegionLock, is responsible for setting up Protected Range registers PR0-PR4. Similar to the PchBiosWriteProtect described above, it uses the BiosLock bit inside DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig (type PCH_LOCK_DOWN_CONFIG) to decide whether or not to set SPI flash protections in this case Protected Range registers."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe42e0cf1>",
                            "type": "UnknownWord",
                            "value": "decide"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5b9bb413>",
                    "type": "UnknownWord",
                    "value": "dbx"
                },
                "references": {
                    "sentences": [
                        "To decide what is trusted and what is not, UEFI Secure Boot uses special databases stored in the authenticated NVRAM variables, namely db and dbx.",
                        "The db database contains a list of trusted public key certificates that are authorized to authenticate boot component signatures or, in addition to the certificates, it can also contain a list of hashes of the components that are allowed to be executed whether or not they are signed.<crlf>The dbx database contains public key certificates or hashes of UEFI executables that are not allowed to be executed to prevent execution of signed executables with known vulnerabilities, revoked certificates, etc.",
                        "ChgBootSecureBootDisable and ChgBootChangeLegacy If created (any of them), ChgBootDxeHook disables the UEFI Secure Boot feature during the next boot.<crlf>ChgBootRestoreFactory If created, ChgBootDxeHook restores factory default values for UEFI Secure Boot variables PK, KEK, db, and dbx during the next boot. This might cause several problems, from corrupting the custom Secure Boot keys used by the victim and thus preventing booting the system, to loading the dbx, which might not contain the latest revocation information. The latter could expose the system to the risk of deploying some UEFI applications, such as bootloaders, with known vulnerabilities (e.g. BootHole) and thus allowing an attacker to bypass UEFI Secure Boot verification too."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x631cbc26>",
                    "type": "UnknownWord",
                    "value": "authenticate"
                },
                "references": {
                    "sentences": [
                        "The db database contains a list of trusted public key certificates that are authorized to authenticate boot component signatures or, in addition to the certificates, it can also contain a list of hashes of the components that are allowed to be executed whether or not they are signed.<crlf>The dbx database contains public key certificates or hashes of UEFI executables that are not allowed to be executed to prevent execution of signed executables with known vulnerabilities, revoked certificates, etc."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4944aa5>",
                    "type": "UnknownWord",
                    "value": "chgboot"
                },
                "references": {
                    "sentences": [
                        "All of the above-mentioned ChgBoot* UEFI variables can be created even without the help of this SW SMI handler for example using Windows APIs because they are not protected against runtime access. This means that attackers can disable crucial security mechanisms from a user-mode process with administrator privileges.",
                        "At the beginning of our blogpost, we mentioned that the SecureBackDoor* and ChgBoot* drivers share some common characteristics, so what is the connection between them? Both use the UEFI variables within the 6ACCE65D-DA35-4B39-B64B-5ED927A7DC7E namespace as a control mechanism for deciding whether to activate their functionality (we will refer to this GUID as LENOVO_BACKDOOR_NAMESPACE_GUID).",
                        "Notice the variables starting with the ChgBoot string: these variables are used as commands for the ChgBootDxeHook DXE driver, indicating whether to perform some action or not. In most cases their names are quite self-explanatory and from the security point of view, the following are the most interesting:",
                        "Figure 11. Hex-Rays-decompiled function from ChgBootDxeHook checking ChgBoot variables.",
                        "So far, we know that attackers would need to create the appropriate ChgBoot* UEFI variable to disable UEFI Secure Boot or restore factory UEFI Secure Boot keys during the boot. So how does it work under the hood? This functionality is handled by the ChgBootDxeHook DXE Driver and all of the ChgBoot* UEFI variables are being checked in its sub_3370 function shown in Figure 11."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4722ed8b>",
                    "type": "UnknownWord",
                    "value": "deciding"
                },
                "references": {
                    "sentences": [
                        "At the beginning of our blogpost, we mentioned that the SecureBackDoor* and ChgBoot* drivers share some common characteristics, so what is the connection between them? Both use the UEFI variables within the 6ACCE65D-DA35-4B39-B64B-5ED927A7DC7E namespace as a control mechanism for deciding whether to activate their functionality (we will refer to this GUID as LENOVO_BACKDOOR_NAMESPACE_GUID)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb66c08bb>",
                    "type": "UnknownWord",
                    "value": "lenovo_backdoor_namespace_guid"
                },
                "references": {
                    "sentences": [
                        "Use EFI_PEI_READ_ONLY_VARIABLE2_PPI.GetVariable function with the VariableName and VariableGuid parameters set to values cE! and LENOVO_BACKDOOR_NAMESPACE_GUID respectively.<crlf>To pass this information to the SecureBackDoor DXE driver, create a HOB data structure identified by the following GUID AD7934E7-D800-4305-BF6F-49ED9918E1AB. To make things simpler, lets name this HOB data structure GUID SECURE_BACKDOOR_HOB_GUID.<crlf>Finally, it saves the value retrieved from the cE! variable to offset 0x18 of the newly created HOB.",
                        "SecureBackDoorPeim is a PEI module responsible for both reading the content of the UEFI variable cE!, which belongs to the namespace LENOVO_BACKDOOR_NAMESPACE_GUID, and preparing the correct HOB data structure to pass its value to the SecureBackDoor DXE phase driver.",
                        "At the beginning of our blogpost, we mentioned that the SecureBackDoor* and ChgBoot* drivers share some common characteristics, so what is the connection between them? Both use the UEFI variables within the 6ACCE65D-DA35-4B39-B64B-5ED927A7DC7E namespace as a control mechanism for deciding whether to activate their functionality (we will refer to this GUID as LENOVO_BACKDOOR_NAMESPACE_GUID).",
                        "Name: cE!<crlf>Namespace GUID: LENOVO_BACKDOOR_NAMESPACE_GUID<crlf>Attributes: NV + BS + RT (0x00000007)<crlf>Value: Any non-null byte",
                        "Name: ChgBootSecureBootDisable or ChgBootChangeLegacy<crlf>Namespace GUID: LENOVO_BACKDOOR_NAMESPACE_GUID<crlf>Attributes: NV + BS + RT (0x00000007)<crlf>Value: Any non-null byte",
                        "Namespace: LENOVO_BACKDOOR_NAMESPACE_GUID ChgBootSecureBootDisable ChgBootSetPxeToFirst ChgBootSetEfiPxeOneTime ChgBootRestoreFactory ChgBootFullRese ChgBootSecureBootEnable ChgBootBootOrderSetDefault ChgBootChangeLegacy ChgBootLegacyLoadDefault ChgBootUefiLoadDefault @Rm OneTimeDisableFastBoot<crlf>ChgBootSecureBootDisable<crlf>ChgBootSetPxeToFirst<crlf>ChgBootSetEfiPxeOneTime<crlf>ChgBootRestoreFactory<crlf>ChgBootFullRese<crlf>ChgBootSecureBootEnable<crlf>ChgBootBootOrderSetDefault<crlf>ChgBootChangeLegacy<crlf>ChgBootLegacyLoadDefault<crlf>ChgBootUefiLoadDefault<crlf>@Rm<crlf>OneTimeDisableFastBoot<crlf>Namespace: A04A27F4-DF00-4D42-B552-39511302113D BootType Setup<crlf>BootType<crlf>Setup"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x87e9007>",
                            "type": "File",
                            "value": "efi_pei_read_only_variable2_ppi.getvariable"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb66c08bb>",
                            "type": "UnknownWord",
                            "value": "lenovo_backdoor_namespace_guid"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc818d33c>",
                    "type": "UnknownWord",
                    "value": "write-protections"
                },
                "references": {
                    "sentences": [
                        "We will start with the analysis of the CVE-2021-3971 vulnerability, which allows an attacker to disable SPI flash write-protections mechanisms by simply creating the NVRAM variable. When platform firmware detects this NVRAM variable during bootup, it skips execution of the code responsible for the setting up BIOS Control Register and Protected Range register-based SPI flash protections."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x11fae619>",
                    "type": "UnknownWord",
                    "value": "register-based"
                },
                "references": {
                    "sentences": [
                        "We will start with the analysis of the CVE-2021-3971 vulnerability, which allows an attacker to disable SPI flash write-protections mechanisms by simply creating the NVRAM variable. When platform firmware detects this NVRAM variable during bootup, it skips execution of the code responsible for the setting up BIOS Control Register and Protected Range register-based SPI flash protections."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3482a97e>",
                    "type": "UnknownWord",
                    "value": "namespace guid"
                },
                "references": {
                    "sentences": [
                        "Name: cE!<crlf>Namespace GUID: LENOVO_BACKDOOR_NAMESPACE_GUID<crlf>Attributes: NV + BS + RT (0x00000007)<crlf>Value: Any non-null byte",
                        "Name: ChgBootSecureBootDisable or ChgBootChangeLegacy<crlf>Namespace GUID: LENOVO_BACKDOOR_NAMESPACE_GUID<crlf>Attributes: NV + BS + RT (0x00000007)<crlf>Value: Any non-null byte"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1d687489>",
                    "type": "UnknownWord",
                    "value": "nv bs rt"
                },
                "references": {
                    "sentences": [
                        "Name: cE!<crlf>Namespace GUID: LENOVO_BACKDOOR_NAMESPACE_GUID<crlf>Attributes: NV + BS + RT (0x00000007)<crlf>Value: Any non-null byte",
                        "Name: ChgBootSecureBootDisable or ChgBootChangeLegacy<crlf>Namespace GUID: LENOVO_BACKDOOR_NAMESPACE_GUID<crlf>Attributes: NV + BS + RT (0x00000007)<crlf>Value: Any non-null byte"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x23174c0a>",
                    "type": "UnknownWord",
                    "value": "non-null"
                },
                "references": {
                    "sentences": [
                        "Name: cE!<crlf>Namespace GUID: LENOVO_BACKDOOR_NAMESPACE_GUID<crlf>Attributes: NV + BS + RT (0x00000007)<crlf>Value: Any non-null byte",
                        "Name: ChgBootSecureBootDisable or ChgBootChangeLegacy<crlf>Namespace GUID: LENOVO_BACKDOOR_NAMESPACE_GUID<crlf>Attributes: NV + BS + RT (0x00000007)<crlf>Value: Any non-null byte"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf7f5ef52>",
                    "type": "UnknownWord",
                    "value": "1gcn25ww"
                },
                "references": {
                    "sentences": [
                        "In our analysis, we will work with the firmware image (version 1GCN25WW) of the Lenovo 110-15IBR, which is one of the devices affected by the CVE-2021-3971 vulnerability."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9743564a>",
                    "type": "UnknownWord",
                    "value": "110-15ibr"
                },
                "references": {
                    "sentences": [
                        "In our analysis, we will work with the firmware image (version 1GCN25WW) of the Lenovo 110-15IBR, which is one of the devices affected by the CVE-2021-3971 vulnerability.",
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd1419ffe>",
                    "type": "UnknownWord",
                    "value": "pre-efi"
                },
                "references": {
                    "sentences": [
                        "To return to a bit of theory, the UEFI boot sequence consists of various phases and one of the earliest is called the Pre-EFI Initialization (PEI) phase. During this phase, Pre-EFI Initialization Modules (PEIMs) are executed to perform various tasks including initialization of permanent memory and invocation of the next boot phase Driver Execution Environment (DXE). To pass information from the PEI phase to the DXE phase, special data structures called Hand-Off Blocks (HOBs) are used."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc72c2a12>",
                    "type": "UnknownWord",
                    "value": "pei"
                },
                "references": {
                    "sentences": [
                        "To return to a bit of theory, the UEFI boot sequence consists of various phases and one of the earliest is called the Pre-EFI Initialization (PEI) phase. During this phase, Pre-EFI Initialization Modules (PEIMs) are executed to perform various tasks including initialization of permanent memory and invocation of the next boot phase Driver Execution Environment (DXE). To pass information from the PEI phase to the DXE phase, special data structures called Hand-Off Blocks (HOBs) are used.",
                        "SecureBackDoorPeim is a PEI module responsible for both reading the content of the UEFI variable cE!, which belongs to the namespace LENOVO_BACKDOOR_NAMESPACE_GUID, and preparing the correct HOB data structure to pass its value to the SecureBackDoor DXE phase driver."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbf675097>",
                    "type": "UnknownWord",
                    "value": "peims"
                },
                "references": {
                    "sentences": [
                        "To return to a bit of theory, the UEFI boot sequence consists of various phases and one of the earliest is called the Pre-EFI Initialization (PEI) phase. During this phase, Pre-EFI Initialization Modules (PEIMs) are executed to perform various tasks including initialization of permanent memory and invocation of the next boot phase Driver Execution Environment (DXE). To pass information from the PEI phase to the DXE phase, special data structures called Hand-Off Blocks (HOBs) are used."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x86dbc22a>",
                    "type": "UnknownWord",
                    "value": "permanent"
                },
                "references": {
                    "sentences": [
                        "To return to a bit of theory, the UEFI boot sequence consists of various phases and one of the earliest is called the Pre-EFI Initialization (PEI) phase. During this phase, Pre-EFI Initialization Modules (PEIMs) are executed to perform various tasks including initialization of permanent memory and invocation of the next boot phase Driver Execution Environment (DXE). To pass information from the PEI phase to the DXE phase, special data structures called Hand-Off Blocks (HOBs) are used."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x46f1bff>",
                    "type": "UnknownWord",
                    "value": "invocation"
                },
                "references": {
                    "sentences": [
                        "Looking closely at the SW SMI handler function in Figure 15, we see that it begins with reading the user parameters from the CPU saved state registers which are registers saved at the moment of SMI invocation.",
                        "To return to a bit of theory, the UEFI boot sequence consists of various phases and one of the earliest is called the Pre-EFI Initialization (PEI) phase. During this phase, Pre-EFI Initialization Modules (PEIMs) are executed to perform various tasks including initialization of permanent memory and invocation of the next boot phase Driver Execution Environment (DXE). To pass information from the PEI phase to the DXE phase, special data structures called Hand-Off Blocks (HOBs) are used."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x199c8075>",
                    "type": "UnknownWord",
                    "value": "dxe"
                },
                "references": {
                    "sentences": [
                        "Use EFI_PEI_READ_ONLY_VARIABLE2_PPI.GetVariable function with the VariableName and VariableGuid parameters set to values cE! and LENOVO_BACKDOOR_NAMESPACE_GUID respectively.<crlf>To pass this information to the SecureBackDoor DXE driver, create a HOB data structure identified by the following GUID AD7934E7-D800-4305-BF6F-49ED9918E1AB. To make things simpler, lets name this HOB data structure GUID SECURE_BACKDOOR_HOB_GUID.<crlf>Finally, it saves the value retrieved from the cE! variable to offset 0x18 of the newly created HOB.",
                        "Sets byte value of the Setup UEFI variable at offset 0x4D9 to zero; this byte seems to be an indicator of the UEFI Secure Boot status inside the BIOS Setup utility.<crlf>Invokes protocol function (protocol GUID C706D63F-6CCE-48AD-A2B4-72A5EF9E220C or LENOVO_SECURE_BOOT_SERVICES_PROTOCOL_GUID in Figure 13) installed by the SecureBootService DXE driver with a parameter identifying an operation to be performed, in this case the operation identified by the value 0x02 which means the disabling of UEFI Secure Boot.",
                        "SecureBackDoor is a DXE driver responsible for deactivating SPI flash protections if it finds a HOB identified by SECURE_BACKDOOR_HOB_GUID in the HOB list. In Figure 5 we can see that to find this HOB, it walks through the list of HOBs, and looks for the one created previously by the SecureBackDoorPeim module by matching it with the SECURE_BACKDOOR_HOB_GUID.",
                        "Notice the variables starting with the ChgBoot string: these variables are used as commands for the ChgBootDxeHook DXE driver, indicating whether to perform some action or not. In most cases their names are quite self-explanatory and from the security point of view, the following are the most interesting:",
                        "And how does this function from LENOVO_SECURE_BOOT_SERVICES_PROTOCOL disable UEFI Secure Boot? It does so by invoking the SW SMI handler 0xEC registered by VariableRuntimeDxe combined SMM/DXE driver, which in turn sets the authenticated UEFI variable named SecureBootEnforce (namespace EFI_GENERIC_VARIABLE_GUID) to 0x00.",
                        "To return to a bit of theory, the UEFI boot sequence consists of various phases and one of the earliest is called the Pre-EFI Initialization (PEI) phase. During this phase, Pre-EFI Initialization Modules (PEIMs) are executed to perform various tasks including initialization of permanent memory and invocation of the next boot phase Driver Execution Environment (DXE). To pass information from the PEI phase to the DXE phase, special data structures called Hand-Off Blocks (HOBs) are used.",
                        "SecureBackDoorPeim is a PEI module responsible for both reading the content of the UEFI variable cE!, which belongs to the namespace LENOVO_BACKDOOR_NAMESPACE_GUID, and preparing the correct HOB data structure to pass its value to the SecureBackDoor DXE phase driver.",
                        "So far, we know that attackers would need to create the appropriate ChgBoot* UEFI variable to disable UEFI Secure Boot or restore factory UEFI Secure Boot keys during the boot. So how does it work under the hood? This functionality is handled by the ChgBootDxeHook DXE Driver and all of the ChgBoot* UEFI variables are being checked in its sub_3370 function shown in Figure 11."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6298a170>",
                    "type": "UnknownWord",
                    "value": "hand-off"
                },
                "references": {
                    "sentences": [
                        "To return to a bit of theory, the UEFI boot sequence consists of various phases and one of the earliest is called the Pre-EFI Initialization (PEI) phase. During this phase, Pre-EFI Initialization Modules (PEIMs) are executed to perform various tasks including initialization of permanent memory and invocation of the next boot phase Driver Execution Environment (DXE). To pass information from the PEI phase to the DXE phase, special data structures called Hand-Off Blocks (HOBs) are used."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa0dfa897>",
                    "type": "UnknownWord",
                    "value": "hobs"
                },
                "references": {
                    "sentences": [
                        "To return to a bit of theory, the UEFI boot sequence consists of various phases and one of the earliest is called the Pre-EFI Initialization (PEI) phase. During this phase, Pre-EFI Initialization Modules (PEIMs) are executed to perform various tasks including initialization of permanent memory and invocation of the next boot phase Driver Execution Environment (DXE). To pass information from the PEI phase to the DXE phase, special data structures called Hand-Off Blocks (HOBs) are used.",
                        "SecureBackDoor is a DXE driver responsible for deactivating SPI flash protections if it finds a HOB identified by SECURE_BACKDOOR_HOB_GUID in the HOB list. In Figure 5 we can see that to find this HOB, it walks through the list of HOBs, and looks for the one created previously by the SecureBackDoorPeim module by matching it with the SECURE_BACKDOOR_HOB_GUID."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x775a62dd>",
                    "type": "UnknownWord",
                    "value": "hob"
                },
                "references": {
                    "sentences": [
                        "Use EFI_PEI_READ_ONLY_VARIABLE2_PPI.GetVariable function with the VariableName and VariableGuid parameters set to values cE! and LENOVO_BACKDOOR_NAMESPACE_GUID respectively.<crlf>To pass this information to the SecureBackDoor DXE driver, create a HOB data structure identified by the following GUID AD7934E7-D800-4305-BF6F-49ED9918E1AB. To make things simpler, lets name this HOB data structure GUID SECURE_BACKDOOR_HOB_GUID.<crlf>Finally, it saves the value retrieved from the cE! variable to offset 0x18 of the newly created HOB.",
                        "SecureBackDoor is a DXE driver responsible for deactivating SPI flash protections if it finds a HOB identified by SECURE_BACKDOOR_HOB_GUID in the HOB list. In Figure 5 we can see that to find this HOB, it walks through the list of HOBs, and looks for the one created previously by the SecureBackDoorPeim module by matching it with the SECURE_BACKDOOR_HOB_GUID.",
                        "Figure 5. Hex-Rays-decompiled SecureBackDoor code responsible for finding HOB created by SecureBackdoorPeim",
                        "If this HOB is found, the driver gets the byte value at offset 0x18 which is the value previously retrieved from the cE! UEFI variable by SecureBackDoorPeim and if this value is different from 0x00, it registers the DXE_PCH_PLATFORM_POLICY_PROTOCOL protocol notify function that zeroes the BiosLock bit inside the DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig bitmask (for related type definitions, see TianoCores PchPlatformPolicy.h header file at GitHub).",
                        "SecureBackDoorPeim is a PEI module responsible for both reading the content of the UEFI variable cE!, which belongs to the namespace LENOVO_BACKDOOR_NAMESPACE_GUID, and preparing the correct HOB data structure to pass its value to the SecureBackDoor DXE phase driver."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x775a62dd>",
                            "type": "UnknownWord",
                            "value": "hob"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc4b160aa>",
                    "type": "UnknownWord",
                    "value": "hex-rays-decompiled"
                },
                "references": {
                    "sentences": [
                        "Figure 15. Hex-Rays-decompiled code of SW SMI handler function registered by the LenovoVariableSmm module",
                        "Figure 7. Hex-Rays-decompiled code of DispatchFunction from PchBiosWriteProtect",
                        "Figure 6. Hex-Rays-decompiled code from PchBiosWriteProtect responsible for initialization of BIOS Control Register related SPI flash protections",
                        "Figure 9. Hex-Rays-decompiled code ChgBootSmm registers SW SMI handler number 0xCA",
                        "Figure 8. Hex-Rays-decompiled code responsible for setting the Protected Range registers",
                        "Figure 10. Hex-Rays-decompiled code of SW SMI handler installed by the ChgBootSmm driver",
                        "Figure 14. Hex-Rays-decompiled code Disable UEFI Secure Boot with additional LenovoVariable check",
                        "Figure 13. Hex-Rays-decompiled code from ChgBootDxeHook responsible for disabling UEFI Secure Boot",
                        "Figure 5. Hex-Rays-decompiled SecureBackDoor code responsible for finding HOB created by SecureBackdoorPeim",
                        "Figure 11. Hex-Rays-decompiled function from ChgBootDxeHook checking ChgBoot variables.",
                        "Figure 12. Hex-Rays-decompiled function from ChgBootDxeHook checking the existence of ChgBootSecureBootDisable NVRAM variable",
                        "Figure 4. Hex-Rays-decompiled code of SecureBackDoorPeim module"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5ea0aa68>",
                    "type": "UnknownWord",
                    "value": "variablename"
                },
                "references": {
                    "sentences": [
                        "Use EFI_PEI_READ_ONLY_VARIABLE2_PPI.GetVariable function with the VariableName and VariableGuid parameters set to values cE! and LENOVO_BACKDOOR_NAMESPACE_GUID respectively.<crlf>To pass this information to the SecureBackDoor DXE driver, create a HOB data structure identified by the following GUID AD7934E7-D800-4305-BF6F-49ED9918E1AB. To make things simpler, lets name this HOB data structure GUID SECURE_BACKDOOR_HOB_GUID.<crlf>Finally, it saves the value retrieved from the cE! variable to offset 0x18 of the newly created HOB."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x87e9007>",
                            "type": "File",
                            "value": "efi_pei_read_only_variable2_ppi.getvariable"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5ea0aa68>",
                            "type": "UnknownWord",
                            "value": "variablename"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe6e39654>",
                    "type": "UnknownWord",
                    "value": "variableguid"
                },
                "references": {
                    "sentences": [
                        "Use EFI_PEI_READ_ONLY_VARIABLE2_PPI.GetVariable function with the VariableName and VariableGuid parameters set to values cE! and LENOVO_BACKDOOR_NAMESPACE_GUID respectively.<crlf>To pass this information to the SecureBackDoor DXE driver, create a HOB data structure identified by the following GUID AD7934E7-D800-4305-BF6F-49ED9918E1AB. To make things simpler, lets name this HOB data structure GUID SECURE_BACKDOOR_HOB_GUID.<crlf>Finally, it saves the value retrieved from the cE! variable to offset 0x18 of the newly created HOB."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x87e9007>",
                            "type": "File",
                            "value": "efi_pei_read_only_variable2_ppi.getvariable"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe6e39654>",
                            "type": "UnknownWord",
                            "value": "variableguid"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe50ec6ad>",
                    "type": "UnknownWord",
                    "value": "simpler"
                },
                "references": {
                    "sentences": [
                        "Use EFI_PEI_READ_ONLY_VARIABLE2_PPI.GetVariable function with the VariableName and VariableGuid parameters set to values cE! and LENOVO_BACKDOOR_NAMESPACE_GUID respectively.<crlf>To pass this information to the SecureBackDoor DXE driver, create a HOB data structure identified by the following GUID AD7934E7-D800-4305-BF6F-49ED9918E1AB. To make things simpler, lets name this HOB data structure GUID SECURE_BACKDOOR_HOB_GUID.<crlf>Finally, it saves the value retrieved from the cE! variable to offset 0x18 of the newly created HOB."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x645bdec1>",
                    "type": "UnknownWord",
                    "value": "secure_backdoor_hob_guid"
                },
                "references": {
                    "sentences": [
                        "Use EFI_PEI_READ_ONLY_VARIABLE2_PPI.GetVariable function with the VariableName and VariableGuid parameters set to values cE! and LENOVO_BACKDOOR_NAMESPACE_GUID respectively.<crlf>To pass this information to the SecureBackDoor DXE driver, create a HOB data structure identified by the following GUID AD7934E7-D800-4305-BF6F-49ED9918E1AB. To make things simpler, lets name this HOB data structure GUID SECURE_BACKDOOR_HOB_GUID.<crlf>Finally, it saves the value retrieved from the cE! variable to offset 0x18 of the newly created HOB.",
                        "SecureBackDoor is a DXE driver responsible for deactivating SPI flash protections if it finds a HOB identified by SECURE_BACKDOOR_HOB_GUID in the HOB list. In Figure 5 we can see that to find this HOB, it walks through the list of HOBs, and looks for the one created previously by the SecureBackDoorPeim module by matching it with the SECURE_BACKDOOR_HOB_GUID."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x907fe9f>",
                    "type": "UnknownWord",
                    "value": "deactivating"
                },
                "references": {
                    "sentences": [
                        "SecureBackDoor is a DXE driver responsible for deactivating SPI flash protections if it finds a HOB identified by SECURE_BACKDOOR_HOB_GUID in the HOB list. In Figure 5 we can see that to find this HOB, it walks through the list of HOBs, and looks for the one created previously by the SecureBackDoorPeim module by matching it with the SECURE_BACKDOOR_HOB_GUID."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3ec06f36>",
                    "type": "UnknownWord",
                    "value": "dxe_pch_platform_policy_protocol"
                },
                "references": {
                    "sentences": [
                        "If this HOB is found, the driver gets the byte value at offset 0x18 which is the value previously retrieved from the cE! UEFI variable by SecureBackDoorPeim and if this value is different from 0x00, it registers the DXE_PCH_PLATFORM_POLICY_PROTOCOL protocol notify function that zeroes the BiosLock bit inside the DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig bitmask (for related type definitions, see TianoCores PchPlatformPolicy.h header file at GitHub)."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3ec06f36>",
                            "type": "UnknownWord",
                            "value": "dxe_pch_platform_policy_protocol"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x38e3d7d7>",
                    "type": "UnknownWord",
                    "value": "zeroes"
                },
                "references": {
                    "sentences": [
                        "If this HOB is found, the driver gets the byte value at offset 0x18 which is the value previously retrieved from the cE! UEFI variable by SecureBackDoorPeim and if this value is different from 0x00, it registers the DXE_PCH_PLATFORM_POLICY_PROTOCOL protocol notify function that zeroes the BiosLock bit inside the DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig bitmask (for related type definitions, see TianoCores PchPlatformPolicy.h header file at GitHub)."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x38e3d7d7>",
                            "type": "UnknownWord",
                            "value": "zeroes"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x57d9752c>",
                    "type": "UnknownWord",
                    "value": "bioslock"
                },
                "references": {
                    "sentences": [
                        "PchBiosWriteProtect is a SMM module. In Figure 6 we can see that it checks whether the BiosLock bit inside DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig (type PCH_LOCK_DOWN_CONFIG) is set, by performing a bitwise AND operation with value 0x08 (which is 0b1000 in binary representation).",
                        "As shown in Figure 8, if it finds out that the BiosLock bit is not set, it will simply skip code responsible for setting these registers and thus leave SPI flash unprotected.",
                        "If this HOB is found, the driver gets the byte value at offset 0x18 which is the value previously retrieved from the cE! UEFI variable by SecureBackDoorPeim and if this value is different from 0x00, it registers the DXE_PCH_PLATFORM_POLICY_PROTOCOL protocol notify function that zeroes the BiosLock bit inside the DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig bitmask (for related type definitions, see TianoCores PchPlatformPolicy.h header file at GitHub).",
                        "The second driver, BiosRegionLock, is responsible for setting up Protected Range registers PR0-PR4. Similar to the PchBiosWriteProtect described above, it uses the BiosLock bit inside DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig (type PCH_LOCK_DOWN_CONFIG) to decide whether or not to set SPI flash protections in this case Protected Range registers."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x57d9752c>",
                            "type": "UnknownWord",
                            "value": "bioslock"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x901f8bb6>",
                    "type": "UnknownWord",
                    "value": "bitmask"
                },
                "references": {
                    "sentences": [
                        "Moreover, each written variable has the same attributes bitmask 0x00000007 (NV|BS|RT) meaning that all of the variables created will be stored in non-volatile storage and thus survive a power cycle.",
                        "If this HOB is found, the driver gets the byte value at offset 0x18 which is the value previously retrieved from the cE! UEFI variable by SecureBackDoorPeim and if this value is different from 0x00, it registers the DXE_PCH_PLATFORM_POLICY_PROTOCOL protocol notify function that zeroes the BiosLock bit inside the DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig bitmask (for related type definitions, see TianoCores PchPlatformPolicy.h header file at GitHub)."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x901f8bb6>",
                            "type": "UnknownWord",
                            "value": "bitmask"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x85dab752>",
                    "type": "UnknownWord",
                    "value": "tianocores"
                },
                "references": {
                    "sentences": [
                        "If this HOB is found, the driver gets the byte value at offset 0x18 which is the value previously retrieved from the cE! UEFI variable by SecureBackDoorPeim and if this value is different from 0x00, it registers the DXE_PCH_PLATFORM_POLICY_PROTOCOL protocol notify function that zeroes the BiosLock bit inside the DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig bitmask (for related type definitions, see TianoCores PchPlatformPolicy.h header file at GitHub)."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x85dab752>",
                            "type": "UnknownWord",
                            "value": "tianocores"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x55f1f9b4>",
                    "type": "UnknownWord",
                    "value": "pchplatformpolicy"
                },
                "references": {
                    "sentences": [
                        "If this HOB is found, the driver gets the byte value at offset 0x18 which is the value previously retrieved from the cE! UEFI variable by SecureBackDoorPeim and if this value is different from 0x00, it registers the DXE_PCH_PLATFORM_POLICY_PROTOCOL protocol notify function that zeroes the BiosLock bit inside the DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig bitmask (for related type definitions, see TianoCores PchPlatformPolicy.h header file at GitHub)."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x55f1f9b4>",
                            "type": "UnknownWord",
                            "value": "pchplatformpolicy"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x93aed084>",
                    "type": "UnknownWord",
                    "value": "pchbioswriteprotect"
                },
                "references": {
                    "sentences": [
                        "PchBiosWriteProtect is a SMM module. In Figure 6 we can see that it checks whether the BiosLock bit inside DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig (type PCH_LOCK_DOWN_CONFIG) is set, by performing a bitwise AND operation with value 0x08 (which is 0b1000 in binary representation).",
                        "Figure 7. Hex-Rays-decompiled code of DispatchFunction from PchBiosWriteProtect",
                        "Figure 6. Hex-Rays-decompiled code from PchBiosWriteProtect responsible for initialization of BIOS Control Register related SPI flash protections",
                        "The second driver, BiosRegionLock, is responsible for setting up Protected Range registers PR0-PR4. Similar to the PchBiosWriteProtect described above, it uses the BiosLock bit inside DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig (type PCH_LOCK_DOWN_CONFIG) to decide whether or not to set SPI flash protections in this case Protected Range registers.",
                        "PchBiosWriteProtect (B8B8B609-0B6C-4B8C-A731-DE03A6C3F3DC)<crlf>BiosRegionLock (77892615-7C7A-4AEF-A320-2A0C15C44B95)"
                    ],
                    "titles": [
                        "PchBiosWriteProtect analysis"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x93aed084>",
                            "type": "UnknownWord",
                            "value": "pchbioswriteprotect"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x88613185>",
                    "type": "UnknownWord",
                    "value": "biosregionlock"
                },
                "references": {
                    "sentences": [
                        "The second driver, BiosRegionLock, is responsible for setting up Protected Range registers PR0-PR4. Similar to the PchBiosWriteProtect described above, it uses the BiosLock bit inside DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig (type PCH_LOCK_DOWN_CONFIG) to decide whether or not to set SPI flash protections in this case Protected Range registers.",
                        "PchBiosWriteProtect (B8B8B609-0B6C-4B8C-A731-DE03A6C3F3DC)<crlf>BiosRegionLock (77892615-7C7A-4AEF-A320-2A0C15C44B95)"
                    ],
                    "titles": [
                        "BiosRegionLock analysis"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4e3de86c>",
                    "type": "UnknownWord",
                    "value": "pch_lock_down_config"
                },
                "references": {
                    "sentences": [
                        "PchBiosWriteProtect is a SMM module. In Figure 6 we can see that it checks whether the BiosLock bit inside DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig (type PCH_LOCK_DOWN_CONFIG) is set, by performing a bitwise AND operation with value 0x08 (which is 0b1000 in binary representation).",
                        "The second driver, BiosRegionLock, is responsible for setting up Protected Range registers PR0-PR4. Similar to the PchBiosWriteProtect described above, it uses the BiosLock bit inside DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig (type PCH_LOCK_DOWN_CONFIG) to decide whether or not to set SPI flash protections in this case Protected Range registers."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4e3de86c>",
                            "type": "UnknownWord",
                            "value": "pch_lock_down_config"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x63598eb8>",
                    "type": "UnknownWord",
                    "value": "bitwise"
                },
                "references": {
                    "sentences": [
                        "PchBiosWriteProtect is a SMM module. In Figure 6 we can see that it checks whether the BiosLock bit inside DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig (type PCH_LOCK_DOWN_CONFIG) is set, by performing a bitwise AND operation with value 0x08 (which is 0b1000 in binary representation)."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x63598eb8>",
                            "type": "UnknownWord",
                            "value": "bitwise"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x818d4466>",
                    "type": "UnknownWord",
                    "value": "0b1000"
                },
                "references": {
                    "sentences": [
                        "PchBiosWriteProtect is a SMM module. In Figure 6 we can see that it checks whether the BiosLock bit inside DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig (type PCH_LOCK_DOWN_CONFIG) is set, by performing a bitwise AND operation with value 0x08 (which is 0b1000 in binary representation)."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x818d4466>",
                            "type": "UnknownWord",
                            "value": "0b1000"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xac98e2b7>",
                    "type": "UnknownWord",
                    "value": "pci_decode_from_addr"
                },
                "references": {
                    "sentences": [
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf71e7451>",
                    "type": "UnknownWord",
                    "value": "knowing"
                },
                "references": {
                    "sentences": [
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9de6fff2>",
                    "type": "UnknownWord",
                    "value": "n-series"
                },
                "references": {
                    "sentences": [
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4e1490dd>",
                    "type": "UnknownWord",
                    "value": "system-on-a-chip"
                },
                "references": {
                    "sentences": [
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x85c5167b>",
                    "type": "UnknownWord",
                    "value": "sbase"
                },
                "references": {
                    "sentences": [
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x22ccc9ab>",
                    "type": "UnknownWord",
                    "value": "spibar"
                },
                "references": {
                    "sentences": [
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x79b2924f>",
                    "type": "UnknownWord",
                    "value": "registering"
                },
                "references": {
                    "sentences": [
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register.",
                        "In the end, DispatchFunction is also responsible for registering SMI handler function (ClearBIOSWE in Figure 7) handling the SMI interrupt, which is triggered when someone tries to set the BIOSWE bit inside the BIOS Control Register from non-SMM code while the BIOS Control Register BLE bit is set. In that case, the installed handler will set BIOSWE (or WPD for our chipset) bit back to 0."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x682c589a>",
                    "type": "UnknownWord",
                    "value": "bcr"
                },
                "references": {
                    "sentences": [
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x41f68676>",
                    "type": "UnknownWord",
                    "value": "eiss"
                },
                "references": {
                    "sentences": [
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x67e273f2>",
                    "type": "UnknownWord",
                    "value": "clearbioswe"
                },
                "references": {
                    "sentences": [
                        "In the end, DispatchFunction is also responsible for registering SMI handler function (ClearBIOSWE in Figure 7) handling the SMI interrupt, which is triggered when someone tries to set the BIOSWE bit inside the BIOS Control Register from non-SMM code while the BIOS Control Register BLE bit is set. In that case, the installed handler will set BIOSWE (or WPD for our chipset) bit back to 0."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5b37ca12>",
                    "type": "UnknownWord",
                    "value": "handling"
                },
                "references": {
                    "sentences": [
                        "In the end, DispatchFunction is also responsible for registering SMI handler function (ClearBIOSWE in Figure 7) handling the SMI interrupt, which is triggered when someone tries to set the BIOSWE bit inside the BIOS Control Register from non-SMM code while the BIOS Control Register BLE bit is set. In that case, the installed handler will set BIOSWE (or WPD for our chipset) bit back to 0."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1598f49a>",
                    "type": "UnknownWord",
                    "value": "wpd"
                },
                "references": {
                    "sentences": [
                        "In the end, DispatchFunction is also responsible for registering SMI handler function (ClearBIOSWE in Figure 7) handling the SMI interrupt, which is triggered when someone tries to set the BIOSWE bit inside the BIOS Control Register from non-SMM code while the BIOS Control Register BLE bit is set. In that case, the installed handler will set BIOSWE (or WPD for our chipset) bit back to 0."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x880cc509>",
                    "type": "UnknownWord",
                    "value": "skipping"
                },
                "references": {
                    "sentences": [
                        "As a result, skipping this code will result in misconfiguration of the BIOS Control Registers, exposing the system to the risk of SPI flash modification."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfc34f082>",
                    "type": "UnknownWord",
                    "value": "restoring"
                },
                "references": {
                    "sentences": [
                        "Needless to say, such an action would have serious impact on system security. Disabling UEFI Secure Boot would mean that the firmware wont enforce integrity verification of the UEFI drivers and applications during the boot process and will thus allow loading of any untrusted or malicious ones. On the other hand, restoring factory settings would not directly disable UEFI Secure Boot, but could expose a system to the risk of deploying some UEFI applications, such as bootloaders, with known vulnerabilities (e.g. see BootHole), thus allowing a bypass of UEFI Secure Boot.",
                        "The next vulnerability we will take a look at is the CVE-2021-3972. This vulnerability allows an attacker with elevated privileges to change various UEFI firmware settings, including the UEFI Secure Boot state, or for example restoring the UEFI firmware factory settings, all by simply creating one UEFI variable."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfef6e6a>",
                    "type": "UnknownWord",
                    "value": "needless"
                },
                "references": {
                    "sentences": [
                        "Needless to say, such an action would have serious impact on system security. Disabling UEFI Secure Boot would mean that the firmware wont enforce integrity verification of the UEFI drivers and applications during the boot process and will thus allow loading of any untrusted or malicious ones. On the other hand, restoring factory settings would not directly disable UEFI Secure Boot, but could expose a system to the risk of deploying some UEFI applications, such as bootloaders, with known vulnerabilities (e.g. see BootHole), thus allowing a bypass of UEFI Secure Boot."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfaa35a05>",
                    "type": "UnknownWord",
                    "value": "bootloaders"
                },
                "references": {
                    "sentences": [
                        "Needless to say, such an action would have serious impact on system security. Disabling UEFI Secure Boot would mean that the firmware wont enforce integrity verification of the UEFI drivers and applications during the boot process and will thus allow loading of any untrusted or malicious ones. On the other hand, restoring factory settings would not directly disable UEFI Secure Boot, but could expose a system to the risk of deploying some UEFI applications, such as bootloaders, with known vulnerabilities (e.g. see BootHole), thus allowing a bypass of UEFI Secure Boot.",
                        "ChgBootSecureBootDisable and ChgBootChangeLegacy If created (any of them), ChgBootDxeHook disables the UEFI Secure Boot feature during the next boot.<crlf>ChgBootRestoreFactory If created, ChgBootDxeHook restores factory default values for UEFI Secure Boot variables PK, KEK, db, and dbx during the next boot. This might cause several problems, from corrupting the custom Secure Boot keys used by the victim and thus preventing booting the system, to loading the dbx, which might not contain the latest revocation information. The latter could expose the system to the risk of deploying some UEFI applications, such as bootloaders, with known vulnerabilities (e.g. BootHole) and thus allowing an attacker to bypass UEFI Secure Boot verification too."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc333f45b>",
                    "type": "UnknownWord",
                    "value": "boothole"
                },
                "references": {
                    "sentences": [
                        "Needless to say, such an action would have serious impact on system security. Disabling UEFI Secure Boot would mean that the firmware wont enforce integrity verification of the UEFI drivers and applications during the boot process and will thus allow loading of any untrusted or malicious ones. On the other hand, restoring factory settings would not directly disable UEFI Secure Boot, but could expose a system to the risk of deploying some UEFI applications, such as bootloaders, with known vulnerabilities (e.g. see BootHole), thus allowing a bypass of UEFI Secure Boot.",
                        "ChgBootSecureBootDisable and ChgBootChangeLegacy If created (any of them), ChgBootDxeHook disables the UEFI Secure Boot feature during the next boot.<crlf>ChgBootRestoreFactory If created, ChgBootDxeHook restores factory default values for UEFI Secure Boot variables PK, KEK, db, and dbx during the next boot. This might cause several problems, from corrupting the custom Secure Boot keys used by the victim and thus preventing booting the system, to loading the dbx, which might not contain the latest revocation information. The latter could expose the system to the risk of deploying some UEFI applications, such as bootloaders, with known vulnerabilities (e.g. BootHole) and thus allowing an attacker to bypass UEFI Secure Boot verification too."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1fb03c4a>",
                    "type": "UnknownWord",
                    "value": "7xcn41ww"
                },
                "references": {
                    "sentences": [
                        "In our analysis, we will work with the firmware image (version 7XCN41WW) of the Lenovo 330-15IGM, which is affected by the CVE-2021-3972 vulnerability.",
                        "In this analysis, we will work with the firmware image (version 7XCN41WW) of the Lenovo 330-15IGM, which is affected by the CVE-2021-3970 vulnerability."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x19c65c0b>",
                    "type": "UnknownWord",
                    "value": "chgbootsecurebootdisable"
                },
                "references": {
                    "sentences": [
                        "As we can see in Figure 14, after the ChgBootSecureBootDisable variable check, another condition is present it disables UEFI Secure Boot only if the value retrieved from the special LenovoVariable persistent storage, accessed using a protocol identified by the GUID C20E5755-1169-4C56-A48A-9824AB430D00 (LENOVO_VARIABLE_PROTOCOL_GUID in Figure 14), contains value Y (0x59).",
                        "ChgBootSecureBootDisable and ChgBootChangeLegacy If created (any of them), ChgBootDxeHook disables the UEFI Secure Boot feature during the next boot.<crlf>ChgBootRestoreFactory If created, ChgBootDxeHook restores factory default values for UEFI Secure Boot variables PK, KEK, db, and dbx during the next boot. This might cause several problems, from corrupting the custom Secure Boot keys used by the victim and thus preventing booting the system, to loading the dbx, which might not contain the latest revocation information. The latter could expose the system to the risk of deploying some UEFI applications, such as bootloaders, with known vulnerabilities (e.g. BootHole) and thus allowing an attacker to bypass UEFI Secure Boot verification too.",
                        "As we can see in Figure 12, the function checks for the existence of the ChgBootSecureBootDisable UEFI variable using runtime services GetVariable function and in case it exists whatever its value executes a function we named DisableSecureBoot.",
                        "But still, if there are some readers interested in how it can be done by invoking the SW SMI handler, here is the CHIPSEC command that can be used to create the ChgBootSecureBootDisable variable:",
                        "Figure 12. Hex-Rays-decompiled function from ChgBootDxeHook checking the existence of ChgBootSecureBootDisable NVRAM variable",
                        "Name: ChgBootSecureBootDisable or ChgBootChangeLegacy<crlf>Namespace GUID: LENOVO_BACKDOOR_NAMESPACE_GUID<crlf>Attributes: NV + BS + RT (0x00000007)<crlf>Value: Any non-null byte",
                        "Namespace: LENOVO_BACKDOOR_NAMESPACE_GUID ChgBootSecureBootDisable ChgBootSetPxeToFirst ChgBootSetEfiPxeOneTime ChgBootRestoreFactory ChgBootFullRese ChgBootSecureBootEnable ChgBootBootOrderSetDefault ChgBootChangeLegacy ChgBootLegacyLoadDefault ChgBootUefiLoadDefault @Rm OneTimeDisableFastBoot<crlf>ChgBootSecureBootDisable<crlf>ChgBootSetPxeToFirst<crlf>ChgBootSetEfiPxeOneTime<crlf>ChgBootRestoreFactory<crlf>ChgBootFullRese<crlf>ChgBootSecureBootEnable<crlf>ChgBootBootOrderSetDefault<crlf>ChgBootChangeLegacy<crlf>ChgBootLegacyLoadDefault<crlf>ChgBootUefiLoadDefault<crlf>@Rm<crlf>OneTimeDisableFastBoot<crlf>Namespace: A04A27F4-DF00-4D42-B552-39511302113D BootType Setup<crlf>BootType<crlf>Setup",
                        "However, on some affected models (for instance on the Lenovo V14-IIL), its not that simple and just creating a ChgBootSecureBootDisable UEFI variable wont disable UEFI Secure Boot. So, whats the catch?"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd5dc463a>",
                    "type": "UnknownWord",
                    "value": "chgbootchangelegacy"
                },
                "references": {
                    "sentences": [
                        "Namespace: LENOVO_BACKDOOR_NAMESPACE_GUID ChgBootSecureBootDisable ChgBootSetPxeToFirst ChgBootSetEfiPxeOneTime ChgBootRestoreFactory ChgBootFullRese ChgBootSecureBootEnable ChgBootBootOrderSetDefault ChgBootChangeLegacy ChgBootLegacyLoadDefault ChgBootUefiLoadDefault @Rm OneTimeDisableFastBoot<crlf>ChgBootSecureBootDisable<crlf>ChgBootSetPxeToFirst<crlf>ChgBootSetEfiPxeOneTime<crlf>ChgBootRestoreFactory<crlf>ChgBootFullRese<crlf>ChgBootSecureBootEnable<crlf>ChgBootBootOrderSetDefault<crlf>ChgBootChangeLegacy<crlf>ChgBootLegacyLoadDefault<crlf>ChgBootUefiLoadDefault<crlf>@Rm<crlf>OneTimeDisableFastBoot<crlf>Namespace: A04A27F4-DF00-4D42-B552-39511302113D BootType Setup<crlf>BootType<crlf>Setup",
                        "Name: ChgBootSecureBootDisable or ChgBootChangeLegacy<crlf>Namespace GUID: LENOVO_BACKDOOR_NAMESPACE_GUID<crlf>Attributes: NV + BS + RT (0x00000007)<crlf>Value: Any non-null byte",
                        "ChgBootSecureBootDisable and ChgBootChangeLegacy If created (any of them), ChgBootDxeHook disables the UEFI Secure Boot feature during the next boot.<crlf>ChgBootRestoreFactory If created, ChgBootDxeHook restores factory default values for UEFI Secure Boot variables PK, KEK, db, and dbx during the next boot. This might cause several problems, from corrupting the custom Secure Boot keys used by the victim and thus preventing booting the system, to loading the dbx, which might not contain the latest revocation information. The latter could expose the system to the risk of deploying some UEFI applications, such as bootloaders, with known vulnerabilities (e.g. BootHole) and thus allowing an attacker to bypass UEFI Secure Boot verification too."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfd8978d9>",
                    "type": "UnknownWord",
                    "value": "4ca0062a-66fe-4be7-ace6-fde992c1c5ec"
                },
                "references": {
                    "sentences": [
                        "ChgBootSmm (4CA0062A-66FE-4BE7-ACE6-FDE992C1C5EC)<crlf>ChgBootDxeHook (C9C3D147-9A92-4D00-B3AE-970E58B5C3AC)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xaad8b41d>",
                    "type": "UnknownWord",
                    "value": "chgbootdxehook c9c3d147-9a92-4d00-b3ae-970e58b5c3ac"
                },
                "references": {
                    "sentences": [
                        "ChgBootSmm (4CA0062A-66FE-4BE7-ACE6-FDE992C1C5EC)<crlf>ChgBootDxeHook (C9C3D147-9A92-4D00-B3AE-970E58B5C3AC)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8bb2c474>",
                    "type": "UnknownWord",
                    "value": "efi_smm_variable_protocol"
                },
                "references": {
                    "sentences": [
                        "By looking into this installed SMI handler in Figure 10, we can see that it uses EFI_SMM_VARIABLE_PROTOCOL functions SmmGetVariable and SmmSetVariable to read from and write into various UEFI variables and the decision of what variable will be created or modified is made based on the value from RBX register saved state."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf3c7cb1d>",
                    "type": "UnknownWord",
                    "value": "smmgetvariable"
                },
                "references": {
                    "sentences": [
                        "By looking into this installed SMI handler in Figure 10, we can see that it uses EFI_SMM_VARIABLE_PROTOCOL functions SmmGetVariable and SmmSetVariable to read from and write into various UEFI variables and the decision of what variable will be created or modified is made based on the value from RBX register saved state."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x429058ea>",
                    "type": "UnknownWord",
                    "value": "smmsetvariable"
                },
                "references": {
                    "sentences": [
                        "By looking into this installed SMI handler in Figure 10, we can see that it uses EFI_SMM_VARIABLE_PROTOCOL functions SmmGetVariable and SmmSetVariable to read from and write into various UEFI variables and the decision of what variable will be created or modified is made based on the value from RBX register saved state."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe757b67>",
                    "type": "UnknownWord",
                    "value": "rbx"
                },
                "references": {
                    "sentences": [
                        "By looking into this installed SMI handler in Figure 10, we can see that it uses EFI_SMM_VARIABLE_PROTOCOL functions SmmGetVariable and SmmSetVariable to read from and write into various UEFI variables and the decision of what variable will be created or modified is made based on the value from RBX register saved state."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x44870954>",
                    "type": "UnknownWord",
                    "value": "survive"
                },
                "references": {
                    "sentences": [
                        "Moreover, each written variable has the same attributes bitmask 0x00000007 (NV|BS|RT) meaning that all of the variables created will be stored in non-volatile storage and thus survive a power cycle."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x35b7b581>",
                    "type": "UnknownWord",
                    "value": "cycle"
                },
                "references": {
                    "sentences": [
                        "Moreover, each written variable has the same attributes bitmask 0x00000007 (NV|BS|RT) meaning that all of the variables created will be stored in non-volatile storage and thus survive a power cycle."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5a665d0a>",
                    "type": "UnknownWord",
                    "value": "chgbootsetpxetofirst"
                },
                "references": {
                    "sentences": [
                        "Namespace: LENOVO_BACKDOOR_NAMESPACE_GUID ChgBootSecureBootDisable ChgBootSetPxeToFirst ChgBootSetEfiPxeOneTime ChgBootRestoreFactory ChgBootFullRese ChgBootSecureBootEnable ChgBootBootOrderSetDefault ChgBootChangeLegacy ChgBootLegacyLoadDefault ChgBootUefiLoadDefault @Rm OneTimeDisableFastBoot<crlf>ChgBootSecureBootDisable<crlf>ChgBootSetPxeToFirst<crlf>ChgBootSetEfiPxeOneTime<crlf>ChgBootRestoreFactory<crlf>ChgBootFullRese<crlf>ChgBootSecureBootEnable<crlf>ChgBootBootOrderSetDefault<crlf>ChgBootChangeLegacy<crlf>ChgBootLegacyLoadDefault<crlf>ChgBootUefiLoadDefault<crlf>@Rm<crlf>OneTimeDisableFastBoot<crlf>Namespace: A04A27F4-DF00-4D42-B552-39511302113D BootType Setup<crlf>BootType<crlf>Setup"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2f8126a5>",
                    "type": "UnknownWord",
                    "value": "chgbootsetefipxeonetime"
                },
                "references": {
                    "sentences": [
                        "Namespace: LENOVO_BACKDOOR_NAMESPACE_GUID ChgBootSecureBootDisable ChgBootSetPxeToFirst ChgBootSetEfiPxeOneTime ChgBootRestoreFactory ChgBootFullRese ChgBootSecureBootEnable ChgBootBootOrderSetDefault ChgBootChangeLegacy ChgBootLegacyLoadDefault ChgBootUefiLoadDefault @Rm OneTimeDisableFastBoot<crlf>ChgBootSecureBootDisable<crlf>ChgBootSetPxeToFirst<crlf>ChgBootSetEfiPxeOneTime<crlf>ChgBootRestoreFactory<crlf>ChgBootFullRese<crlf>ChgBootSecureBootEnable<crlf>ChgBootBootOrderSetDefault<crlf>ChgBootChangeLegacy<crlf>ChgBootLegacyLoadDefault<crlf>ChgBootUefiLoadDefault<crlf>@Rm<crlf>OneTimeDisableFastBoot<crlf>Namespace: A04A27F4-DF00-4D42-B552-39511302113D BootType Setup<crlf>BootType<crlf>Setup"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe8249643>",
                    "type": "UnknownWord",
                    "value": "chgbootrestorefactory"
                },
                "references": {
                    "sentences": [
                        "Namespace: LENOVO_BACKDOOR_NAMESPACE_GUID ChgBootSecureBootDisable ChgBootSetPxeToFirst ChgBootSetEfiPxeOneTime ChgBootRestoreFactory ChgBootFullRese ChgBootSecureBootEnable ChgBootBootOrderSetDefault ChgBootChangeLegacy ChgBootLegacyLoadDefault ChgBootUefiLoadDefault @Rm OneTimeDisableFastBoot<crlf>ChgBootSecureBootDisable<crlf>ChgBootSetPxeToFirst<crlf>ChgBootSetEfiPxeOneTime<crlf>ChgBootRestoreFactory<crlf>ChgBootFullRese<crlf>ChgBootSecureBootEnable<crlf>ChgBootBootOrderSetDefault<crlf>ChgBootChangeLegacy<crlf>ChgBootLegacyLoadDefault<crlf>ChgBootUefiLoadDefault<crlf>@Rm<crlf>OneTimeDisableFastBoot<crlf>Namespace: A04A27F4-DF00-4D42-B552-39511302113D BootType Setup<crlf>BootType<crlf>Setup",
                        "ChgBootSecureBootDisable and ChgBootChangeLegacy If created (any of them), ChgBootDxeHook disables the UEFI Secure Boot feature during the next boot.<crlf>ChgBootRestoreFactory If created, ChgBootDxeHook restores factory default values for UEFI Secure Boot variables PK, KEK, db, and dbx during the next boot. This might cause several problems, from corrupting the custom Secure Boot keys used by the victim and thus preventing booting the system, to loading the dbx, which might not contain the latest revocation information. The latter could expose the system to the risk of deploying some UEFI applications, such as bootloaders, with known vulnerabilities (e.g. BootHole) and thus allowing an attacker to bypass UEFI Secure Boot verification too."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8a185a9f>",
                    "type": "UnknownWord",
                    "value": "chgbootfullrese"
                },
                "references": {
                    "sentences": [
                        "Namespace: LENOVO_BACKDOOR_NAMESPACE_GUID ChgBootSecureBootDisable ChgBootSetPxeToFirst ChgBootSetEfiPxeOneTime ChgBootRestoreFactory ChgBootFullRese ChgBootSecureBootEnable ChgBootBootOrderSetDefault ChgBootChangeLegacy ChgBootLegacyLoadDefault ChgBootUefiLoadDefault @Rm OneTimeDisableFastBoot<crlf>ChgBootSecureBootDisable<crlf>ChgBootSetPxeToFirst<crlf>ChgBootSetEfiPxeOneTime<crlf>ChgBootRestoreFactory<crlf>ChgBootFullRese<crlf>ChgBootSecureBootEnable<crlf>ChgBootBootOrderSetDefault<crlf>ChgBootChangeLegacy<crlf>ChgBootLegacyLoadDefault<crlf>ChgBootUefiLoadDefault<crlf>@Rm<crlf>OneTimeDisableFastBoot<crlf>Namespace: A04A27F4-DF00-4D42-B552-39511302113D BootType Setup<crlf>BootType<crlf>Setup"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5f2af9a8>",
                    "type": "UnknownWord",
                    "value": "chgbootsecurebootenable"
                },
                "references": {
                    "sentences": [
                        "Namespace: LENOVO_BACKDOOR_NAMESPACE_GUID ChgBootSecureBootDisable ChgBootSetPxeToFirst ChgBootSetEfiPxeOneTime ChgBootRestoreFactory ChgBootFullRese ChgBootSecureBootEnable ChgBootBootOrderSetDefault ChgBootChangeLegacy ChgBootLegacyLoadDefault ChgBootUefiLoadDefault @Rm OneTimeDisableFastBoot<crlf>ChgBootSecureBootDisable<crlf>ChgBootSetPxeToFirst<crlf>ChgBootSetEfiPxeOneTime<crlf>ChgBootRestoreFactory<crlf>ChgBootFullRese<crlf>ChgBootSecureBootEnable<crlf>ChgBootBootOrderSetDefault<crlf>ChgBootChangeLegacy<crlf>ChgBootLegacyLoadDefault<crlf>ChgBootUefiLoadDefault<crlf>@Rm<crlf>OneTimeDisableFastBoot<crlf>Namespace: A04A27F4-DF00-4D42-B552-39511302113D BootType Setup<crlf>BootType<crlf>Setup"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8aa796e>",
                    "type": "UnknownWord",
                    "value": "chgbootbootordersetdefault"
                },
                "references": {
                    "sentences": [
                        "Namespace: LENOVO_BACKDOOR_NAMESPACE_GUID ChgBootSecureBootDisable ChgBootSetPxeToFirst ChgBootSetEfiPxeOneTime ChgBootRestoreFactory ChgBootFullRese ChgBootSecureBootEnable ChgBootBootOrderSetDefault ChgBootChangeLegacy ChgBootLegacyLoadDefault ChgBootUefiLoadDefault @Rm OneTimeDisableFastBoot<crlf>ChgBootSecureBootDisable<crlf>ChgBootSetPxeToFirst<crlf>ChgBootSetEfiPxeOneTime<crlf>ChgBootRestoreFactory<crlf>ChgBootFullRese<crlf>ChgBootSecureBootEnable<crlf>ChgBootBootOrderSetDefault<crlf>ChgBootChangeLegacy<crlf>ChgBootLegacyLoadDefault<crlf>ChgBootUefiLoadDefault<crlf>@Rm<crlf>OneTimeDisableFastBoot<crlf>Namespace: A04A27F4-DF00-4D42-B552-39511302113D BootType Setup<crlf>BootType<crlf>Setup"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbdf6ccd>",
                    "type": "UnknownWord",
                    "value": "chgbootlegacyloaddefault"
                },
                "references": {
                    "sentences": [
                        "Namespace: LENOVO_BACKDOOR_NAMESPACE_GUID ChgBootSecureBootDisable ChgBootSetPxeToFirst ChgBootSetEfiPxeOneTime ChgBootRestoreFactory ChgBootFullRese ChgBootSecureBootEnable ChgBootBootOrderSetDefault ChgBootChangeLegacy ChgBootLegacyLoadDefault ChgBootUefiLoadDefault @Rm OneTimeDisableFastBoot<crlf>ChgBootSecureBootDisable<crlf>ChgBootSetPxeToFirst<crlf>ChgBootSetEfiPxeOneTime<crlf>ChgBootRestoreFactory<crlf>ChgBootFullRese<crlf>ChgBootSecureBootEnable<crlf>ChgBootBootOrderSetDefault<crlf>ChgBootChangeLegacy<crlf>ChgBootLegacyLoadDefault<crlf>ChgBootUefiLoadDefault<crlf>@Rm<crlf>OneTimeDisableFastBoot<crlf>Namespace: A04A27F4-DF00-4D42-B552-39511302113D BootType Setup<crlf>BootType<crlf>Setup"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x10f075e9>",
                    "type": "UnknownWord",
                    "value": "chgbootuefiloaddefault"
                },
                "references": {
                    "sentences": [
                        "Namespace: LENOVO_BACKDOOR_NAMESPACE_GUID ChgBootSecureBootDisable ChgBootSetPxeToFirst ChgBootSetEfiPxeOneTime ChgBootRestoreFactory ChgBootFullRese ChgBootSecureBootEnable ChgBootBootOrderSetDefault ChgBootChangeLegacy ChgBootLegacyLoadDefault ChgBootUefiLoadDefault @Rm OneTimeDisableFastBoot<crlf>ChgBootSecureBootDisable<crlf>ChgBootSetPxeToFirst<crlf>ChgBootSetEfiPxeOneTime<crlf>ChgBootRestoreFactory<crlf>ChgBootFullRese<crlf>ChgBootSecureBootEnable<crlf>ChgBootBootOrderSetDefault<crlf>ChgBootChangeLegacy<crlf>ChgBootLegacyLoadDefault<crlf>ChgBootUefiLoadDefault<crlf>@Rm<crlf>OneTimeDisableFastBoot<crlf>Namespace: A04A27F4-DF00-4D42-B552-39511302113D BootType Setup<crlf>BootType<crlf>Setup"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6d18d33>",
                    "type": "UnknownWord",
                    "value": "onetimedisablefastboot"
                },
                "references": {
                    "sentences": [
                        "Namespace: LENOVO_BACKDOOR_NAMESPACE_GUID ChgBootSecureBootDisable ChgBootSetPxeToFirst ChgBootSetEfiPxeOneTime ChgBootRestoreFactory ChgBootFullRese ChgBootSecureBootEnable ChgBootBootOrderSetDefault ChgBootChangeLegacy ChgBootLegacyLoadDefault ChgBootUefiLoadDefault @Rm OneTimeDisableFastBoot<crlf>ChgBootSecureBootDisable<crlf>ChgBootSetPxeToFirst<crlf>ChgBootSetEfiPxeOneTime<crlf>ChgBootRestoreFactory<crlf>ChgBootFullRese<crlf>ChgBootSecureBootEnable<crlf>ChgBootBootOrderSetDefault<crlf>ChgBootChangeLegacy<crlf>ChgBootLegacyLoadDefault<crlf>ChgBootUefiLoadDefault<crlf>@Rm<crlf>OneTimeDisableFastBoot<crlf>Namespace: A04A27F4-DF00-4D42-B552-39511302113D BootType Setup<crlf>BootType<crlf>Setup"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x57b47a44>",
                    "type": "UnknownWord",
                    "value": "boottype"
                },
                "references": {
                    "sentences": [
                        "Namespace: LENOVO_BACKDOOR_NAMESPACE_GUID ChgBootSecureBootDisable ChgBootSetPxeToFirst ChgBootSetEfiPxeOneTime ChgBootRestoreFactory ChgBootFullRese ChgBootSecureBootEnable ChgBootBootOrderSetDefault ChgBootChangeLegacy ChgBootLegacyLoadDefault ChgBootUefiLoadDefault @Rm OneTimeDisableFastBoot<crlf>ChgBootSecureBootDisable<crlf>ChgBootSetPxeToFirst<crlf>ChgBootSetEfiPxeOneTime<crlf>ChgBootRestoreFactory<crlf>ChgBootFullRese<crlf>ChgBootSecureBootEnable<crlf>ChgBootBootOrderSetDefault<crlf>ChgBootChangeLegacy<crlf>ChgBootLegacyLoadDefault<crlf>ChgBootUefiLoadDefault<crlf>@Rm<crlf>OneTimeDisableFastBoot<crlf>Namespace: A04A27F4-DF00-4D42-B552-39511302113D BootType Setup<crlf>BootType<crlf>Setup"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9c054f2d>",
                    "type": "UnknownWord",
                    "value": "self-explanatory"
                },
                "references": {
                    "sentences": [
                        "Notice the variables starting with the ChgBoot string: these variables are used as commands for the ChgBootDxeHook DXE driver, indicating whether to perform some action or not. In most cases their names are quite self-explanatory and from the security point of view, the following are the most interesting:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x16bc6fb7>",
                    "type": "UnknownWord",
                    "value": "restores"
                },
                "references": {
                    "sentences": [
                        "ChgBootSecureBootDisable and ChgBootChangeLegacy If created (any of them), ChgBootDxeHook disables the UEFI Secure Boot feature during the next boot.<crlf>ChgBootRestoreFactory If created, ChgBootDxeHook restores factory default values for UEFI Secure Boot variables PK, KEK, db, and dbx during the next boot. This might cause several problems, from corrupting the custom Secure Boot keys used by the victim and thus preventing booting the system, to loading the dbx, which might not contain the latest revocation information. The latter could expose the system to the risk of deploying some UEFI applications, such as bootloaders, with known vulnerabilities (e.g. BootHole) and thus allowing an attacker to bypass UEFI Secure Boot verification too."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xecaa356f>",
                    "type": "UnknownWord",
                    "value": "kek"
                },
                "references": {
                    "sentences": [
                        "ChgBootSecureBootDisable and ChgBootChangeLegacy If created (any of them), ChgBootDxeHook disables the UEFI Secure Boot feature during the next boot.<crlf>ChgBootRestoreFactory If created, ChgBootDxeHook restores factory default values for UEFI Secure Boot variables PK, KEK, db, and dbx during the next boot. This might cause several problems, from corrupting the custom Secure Boot keys used by the victim and thus preventing booting the system, to loading the dbx, which might not contain the latest revocation information. The latter could expose the system to the risk of deploying some UEFI applications, such as bootloaders, with known vulnerabilities (e.g. BootHole) and thus allowing an attacker to bypass UEFI Secure Boot verification too."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6c47913f>",
                    "type": "UnknownWord",
                    "value": "corrupting"
                },
                "references": {
                    "sentences": [
                        "ChgBootSecureBootDisable and ChgBootChangeLegacy If created (any of them), ChgBootDxeHook disables the UEFI Secure Boot feature during the next boot.<crlf>ChgBootRestoreFactory If created, ChgBootDxeHook restores factory default values for UEFI Secure Boot variables PK, KEK, db, and dbx during the next boot. This might cause several problems, from corrupting the custom Secure Boot keys used by the victim and thus preventing booting the system, to loading the dbx, which might not contain the latest revocation information. The latter could expose the system to the risk of deploying some UEFI applications, such as bootloaders, with known vulnerabilities (e.g. BootHole) and thus allowing an attacker to bypass UEFI Secure Boot verification too."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xff9ed82a>",
                    "type": "UnknownWord",
                    "value": "revocation"
                },
                "references": {
                    "sentences": [
                        "ChgBootSecureBootDisable and ChgBootChangeLegacy If created (any of them), ChgBootDxeHook disables the UEFI Secure Boot feature during the next boot.<crlf>ChgBootRestoreFactory If created, ChgBootDxeHook restores factory default values for UEFI Secure Boot variables PK, KEK, db, and dbx during the next boot. This might cause several problems, from corrupting the custom Secure Boot keys used by the victim and thus preventing booting the system, to loading the dbx, which might not contain the latest revocation information. The latter could expose the system to the risk of deploying some UEFI applications, such as bootloaders, with known vulnerabilities (e.g. BootHole) and thus allowing an attacker to bypass UEFI Secure Boot verification too."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa9129707>",
                    "type": "UnknownWord",
                    "value": "crucial"
                },
                "references": {
                    "sentences": [
                        "All of the above-mentioned ChgBoot* UEFI variables can be created even without the help of this SW SMI handler for example using Windows APIs because they are not protected against runtime access. This means that attackers can disable crucial security mechanisms from a user-mode process with administrator privileges."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x907bca0>",
                    "type": "UnknownWord",
                    "value": "interested"
                },
                "references": {
                    "sentences": [
                        "But still, if there are some readers interested in how it can be done by invoking the SW SMI handler, here is the CHIPSEC command that can be used to create the ChgBootSecureBootDisable variable:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x185a3476>",
                    "type": "UnknownWord",
                    "value": "invoking"
                },
                "references": {
                    "sentences": [
                        "And how does this function from LENOVO_SECURE_BOOT_SERVICES_PROTOCOL disable UEFI Secure Boot? It does so by invoking the SW SMI handler 0xEC registered by VariableRuntimeDxe combined SMM/DXE driver, which in turn sets the authenticated UEFI variable named SecureBootEnforce (namespace EFI_GENERIC_VARIABLE_GUID) to 0x00.",
                        "But still, if there are some readers interested in how it can be done by invoking the SW SMI handler, here is the CHIPSEC command that can be used to create the ChgBootSecureBootDisable variable:",
                        "For models including this check, higher privileges are required to disable secure boot from the OS, but its still possible by invoking the SW SMI handler registered by the LenovoVariableSmm SMM module.",
                        "It is important to note that LenovoVariableSmm not only installs this protocol to be accessible by other SMM modules, but it also registers the SW SMI handler function that allows accessing this storage from the OS by invoking SW SMI. The worst part is that it doesnt properly validate parameters passed to the SW SMI handler, which can result in arbitrary read/write from/to the SMRAM."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x35689fe7>",
                    "type": "UnknownWord",
                    "value": "chipsec"
                },
                "references": {
                    "sentences": [
                        "Figure 17. CHIPSEC example read 0x100 bytes from SMRAM by exploiting CVE-2021-3972",
                        "But still, if there are some readers interested in how it can be done by invoking the SW SMI handler, here is the CHIPSEC command that can be used to create the ChgBootSecureBootDisable variable:",
                        "Figure 18. CHIPSEC script output dumping the first 0x100 bytes of SMRAM",
                        "An example of the above-described steps using the CHIPSEC framework is shown in Figure 17; the output of the script containing the first 0x100 bytes of the SMRAM is shown in Figure 18."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbe58df53>",
                    "type": "UnknownWord",
                    "value": "restore"
                },
                "references": {
                    "sentences": [
                        "So far, we know that attackers would need to create the appropriate ChgBoot* UEFI variable to disable UEFI Secure Boot or restore factory UEFI Secure Boot keys during the boot. So how does it work under the hood? This functionality is handled by the ChgBootDxeHook DXE Driver and all of the ChgBoot* UEFI variables are being checked in its sub_3370 function shown in Figure 11."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcc511043>",
                    "type": "UnknownWord",
                    "value": "handled"
                },
                "references": {
                    "sentences": [
                        "So far, we know that attackers would need to create the appropriate ChgBoot* UEFI variable to disable UEFI Secure Boot or restore factory UEFI Secure Boot keys during the boot. So how does it work under the hood? This functionality is handled by the ChgBootDxeHook DXE Driver and all of the ChgBoot* UEFI variables are being checked in its sub_3370 function shown in Figure 11."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3909cf83>",
                    "type": "UnknownWord",
                    "value": "sub_3370"
                },
                "references": {
                    "sentences": [
                        "So far, we know that attackers would need to create the appropriate ChgBoot* UEFI variable to disable UEFI Secure Boot or restore factory UEFI Secure Boot keys during the boot. So how does it work under the hood? This functionality is handled by the ChgBootDxeHook DXE Driver and all of the ChgBoot* UEFI variables are being checked in its sub_3370 function shown in Figure 11."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x95b3cf01>",
                    "type": "UnknownWord",
                    "value": "chgbootsecurebootdisablecheck"
                },
                "references": {
                    "sentences": [
                        "To see how the UEFI Secure Boot is being disabled, we can look inside the ChgBootSecureBootDisableCheck function (exactly the same also happens in the ChgBootChangeLegacyCheck function, just with a different variable being checked)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6f2603ac>",
                    "type": "UnknownWord",
                    "value": "chgbootchangelegacycheck"
                },
                "references": {
                    "sentences": [
                        "To see how the UEFI Secure Boot is being disabled, we can look inside the ChgBootSecureBootDisableCheck function (exactly the same also happens in the ChgBootChangeLegacyCheck function, just with a different variable being checked)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8a605237>",
                    "type": "UnknownWord",
                    "value": "whatever"
                },
                "references": {
                    "sentences": [
                        "As we can see in Figure 12, the function checks for the existence of the ChgBootSecureBootDisable UEFI variable using runtime services GetVariable function and in case it exists whatever its value executes a function we named DisableSecureBoot."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5e611839>",
                    "type": "UnknownWord",
                    "value": "disablesecureboot"
                },
                "references": {
                    "sentences": [
                        "As we can see in Figure 12, the function checks for the existence of the ChgBootSecureBootDisable UEFI variable using runtime services GetVariable function and in case it exists whatever its value executes a function we named DisableSecureBoot."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9c87c51e>",
                    "type": "UnknownWord",
                    "value": "lenovo_secure_boot_services_protocol_guid"
                },
                "references": {
                    "sentences": [
                        "Sets byte value of the Setup UEFI variable at offset 0x4D9 to zero; this byte seems to be an indicator of the UEFI Secure Boot status inside the BIOS Setup utility.<crlf>Invokes protocol function (protocol GUID C706D63F-6CCE-48AD-A2B4-72A5EF9E220C or LENOVO_SECURE_BOOT_SERVICES_PROTOCOL_GUID in Figure 13) installed by the SecureBootService DXE driver with a parameter identifying an operation to be performed, in this case the operation identified by the value 0x02 which means the disabling of UEFI Secure Boot."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x22c9c5dc>",
                    "type": "UnknownWord",
                    "value": "securebootservice"
                },
                "references": {
                    "sentences": [
                        "Sets byte value of the Setup UEFI variable at offset 0x4D9 to zero; this byte seems to be an indicator of the UEFI Secure Boot status inside the BIOS Setup utility.<crlf>Invokes protocol function (protocol GUID C706D63F-6CCE-48AD-A2B4-72A5EF9E220C or LENOVO_SECURE_BOOT_SERVICES_PROTOCOL_GUID in Figure 13) installed by the SecureBootService DXE driver with a parameter identifying an operation to be performed, in this case the operation identified by the value 0x02 which means the disabling of UEFI Secure Boot."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xceacb021>",
                    "type": "UnknownWord",
                    "value": "lenovo_secure_boot_services_protocol"
                },
                "references": {
                    "sentences": [
                        "And how does this function from LENOVO_SECURE_BOOT_SERVICES_PROTOCOL disable UEFI Secure Boot? It does so by invoking the SW SMI handler 0xEC registered by VariableRuntimeDxe combined SMM/DXE driver, which in turn sets the authenticated UEFI variable named SecureBootEnforce (namespace EFI_GENERIC_VARIABLE_GUID) to 0x00."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcec1d5b5>",
                    "type": "UnknownWord",
                    "value": "variableruntimedxe"
                },
                "references": {
                    "sentences": [
                        "And how does this function from LENOVO_SECURE_BOOT_SERVICES_PROTOCOL disable UEFI Secure Boot? It does so by invoking the SW SMI handler 0xEC registered by VariableRuntimeDxe combined SMM/DXE driver, which in turn sets the authenticated UEFI variable named SecureBootEnforce (namespace EFI_GENERIC_VARIABLE_GUID) to 0x00."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd52c591a>",
                    "type": "UnknownWord",
                    "value": "securebootenforce"
                },
                "references": {
                    "sentences": [
                        "And how does this function from LENOVO_SECURE_BOOT_SERVICES_PROTOCOL disable UEFI Secure Boot? It does so by invoking the SW SMI handler 0xEC registered by VariableRuntimeDxe combined SMM/DXE driver, which in turn sets the authenticated UEFI variable named SecureBootEnforce (namespace EFI_GENERIC_VARIABLE_GUID) to 0x00."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1abad7fa>",
                    "type": "UnknownWord",
                    "value": "efi_generic_variable_guid"
                },
                "references": {
                    "sentences": [
                        "And how does this function from LENOVO_SECURE_BOOT_SERVICES_PROTOCOL disable UEFI Secure Boot? It does so by invoking the SW SMI handler 0xEC registered by VariableRuntimeDxe combined SMM/DXE driver, which in turn sets the authenticated UEFI variable named SecureBootEnforce (namespace EFI_GENERIC_VARIABLE_GUID) to 0x00."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf1adf10c>",
                    "type": "UnknownWord",
                    "value": "v14-iil"
                },
                "references": {
                    "sentences": [
                        "However, on some affected models (for instance on the Lenovo V14-IIL), its not that simple and just creating a ChgBootSecureBootDisable UEFI variable wont disable UEFI Secure Boot. So, whats the catch?"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x70f43d9e>",
                    "type": "UnknownWord",
                    "value": "lenovovariable"
                },
                "references": {
                    "sentences": [
                        "As we can see in Figure 14, after the ChgBootSecureBootDisable variable check, another condition is present it disables UEFI Secure Boot only if the value retrieved from the special LenovoVariable persistent storage, accessed using a protocol identified by the GUID C20E5755-1169-4C56-A48A-9824AB430D00 (LENOVO_VARIABLE_PROTOCOL_GUID in Figure 14), contains value Y (0x59).",
                        "The firmware on certain Lenovo consumer laptop models implements a special LenovoVariable persistent storage, allowing data storage of up to 4KB in SPI flash.",
                        "We have provided an example of how to read only the first 0x100 bytes of the SMRAM; however, with additional modifications, its possible to read/write the whole SMRAM range. This could allow threat actors to execute their own malicious code in SMM or even worse considering the LenovoVariable SW SMI handlers ability to modify the SPI flash write the attackers own malicious firmware implant directly to the SPI flash.",
                        "Figure 14. Hex-Rays-decompiled code Disable UEFI Secure Boot with additional LenovoVariable check",
                        "A description of this LenovoVariable persistent storage is offered in the next section."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf861fb9f>",
                    "type": "UnknownWord",
                    "value": "lenovo_variable_protocol_guid"
                },
                "references": {
                    "sentences": [
                        "In the firmware we analyzed, the SMM version of the Lenovo variables functionality is provided to other drivers by the protocol BFD02359-8DFE-459A-8B69-A73A6BAFADC0 (lets name it LENOVO_VARIABLE_PROTOCOL_GUID) and it is installed by the LenovoVariableSmm SMM module.",
                        "As we can see in Figure 14, after the ChgBootSecureBootDisable variable check, another condition is present it disables UEFI Secure Boot only if the value retrieved from the special LenovoVariable persistent storage, accessed using a protocol identified by the GUID C20E5755-1169-4C56-A48A-9824AB430D00 (LENOVO_VARIABLE_PROTOCOL_GUID in Figure 14), contains value Y (0x59)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6e8c46f7>",
                    "type": "UnknownWord",
                    "value": "offered"
                },
                "references": {
                    "sentences": [
                        "A description of this LenovoVariable persistent storage is offered in the next section."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1f23fcb2>",
                    "type": "UnknownWord",
                    "value": "validation"
                },
                "references": {
                    "sentences": [
                        "In this last section, we are going to look at the analysis of the CVE-2021-3970 vulnerability caused by an improper input validation in the SW SMI handler function, which can lead to the arbitrary read/write from/to the SMRAM and subsequent arbitrary code execution in SMM execution mode."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x22b88a80>",
                    "type": "UnknownWord",
                    "value": "4kb"
                },
                "references": {
                    "sentences": [
                        "The firmware on certain Lenovo consumer laptop models implements a special LenovoVariable persistent storage, allowing data storage of up to 4KB in SPI flash.",
                        "Find the SMRAM physical address.<crlf>Copy the LENV_HDR header to the physical address 32 bytes before the SMRAM the header should contain a variable identifier (it can be a random GUID) and the length of the data one would like to read from SMRAM (the maximum is something below 4KB).<crlf>Invoke SW SMI registered by the LenovoVariableSmm (SwSmiNumber 0x80), specifying the command with ID 0x02 in the BX register (meaning that you want to write into the Lenovo variable) and the address of previously created header in the ECX and EDI registers (to tell the SW SMI handler what you want to write into that variable).<crlf>Now, that variable contains a specified amount of SMRAM data so we only need to read it. We allocate a new buffer (equal to the size of the header plus the size of data to retrieve) and copy the same header into it, as used in step 2.<crlf>Invoke the SW SMI handler again, specifying the command with ID 0x01 in BX register (meaning that you want to read from the Lenovo variable) and the address of our newly allocated buffer from step 4 in the ECX and EDI registers (to tell the SW SMI handler where we want to copy the content of the Lenovo variable which at this moment contains data from the SMRAM)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd76d7ba7>",
                    "type": "UnknownWord",
                    "value": "license"
                },
                "references": {
                    "sentences": [
                        "Its used by the platform firmware to store various information, including the Lenovo product name, motherboard model name and version, OEM OS license, or as mentioned in the section above, in some cases it can be used to activate the ChgBootDxeHook driver in order to disable UEFI Secure Boot feature."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6bda5dca>",
                    "type": "UnknownWord",
                    "value": "lenovo_variable_protocols"
                },
                "references": {
                    "sentences": [
                        "The buffer starts with the 0x20-byte header (LENV_HDR), containing the unique GUID that identifies the Lenovo variable and a 32-bit value specifying the length of the data to be retrieved from the variable or written to it. The memory space located immediately after the header is used as a source or destination location for LENOVO_VARIABLE_PROTOCOLs Read and Write functions.",
                        "This LENOVO_VARIABLE_PROTOCOLs interface provides four functions:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x186f6659>",
                    "type": "UnknownWord",
                    "value": "worst"
                },
                "references": {
                    "sentences": [
                        "It is important to note that LenovoVariableSmm not only installs this protocol to be accessible by other SMM modules, but it also registers the SW SMI handler function that allows accessing this storage from the OS by invoking SW SMI. The worst part is that it doesnt properly validate parameters passed to the SW SMI handler, which can result in arbitrary read/write from/to the SMRAM."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcaa89357>",
                    "type": "UnknownWord",
                    "value": "moment"
                },
                "references": {
                    "sentences": [
                        "Looking closely at the SW SMI handler function in Figure 15, we see that it begins with reading the user parameters from the CPU saved state registers which are registers saved at the moment of SMI invocation.",
                        "Find the SMRAM physical address.<crlf>Copy the LENV_HDR header to the physical address 32 bytes before the SMRAM the header should contain a variable identifier (it can be a random GUID) and the length of the data one would like to read from SMRAM (the maximum is something below 4KB).<crlf>Invoke SW SMI registered by the LenovoVariableSmm (SwSmiNumber 0x80), specifying the command with ID 0x02 in the BX register (meaning that you want to write into the Lenovo variable) and the address of previously created header in the ECX and EDI registers (to tell the SW SMI handler what you want to write into that variable).<crlf>Now, that variable contains a specified amount of SMRAM data so we only need to read it. We allocate a new buffer (equal to the size of the header plus the size of data to retrieve) and copy the same header into it, as used in step 2.<crlf>Invoke the SW SMI handler again, specifying the command with ID 0x01 in BX register (meaning that you want to read from the Lenovo variable) and the address of our newly allocated buffer from step 4 in the ECX and EDI registers (to tell the SW SMI handler where we want to copy the content of the Lenovo variable which at this moment contains data from the SMRAM)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3a6023d6>",
                    "type": "UnknownWord",
                    "value": "ecx"
                },
                "references": {
                    "sentences": [
                        "64-bit physical address built from the values stored in the ECX and EDI registers.<crlf>The command, indicating the action to be executed (read, write, delete, etc.), from the BX register.",
                        "Find the SMRAM physical address.<crlf>Copy the LENV_HDR header to the physical address 32 bytes before the SMRAM the header should contain a variable identifier (it can be a random GUID) and the length of the data one would like to read from SMRAM (the maximum is something below 4KB).<crlf>Invoke SW SMI registered by the LenovoVariableSmm (SwSmiNumber 0x80), specifying the command with ID 0x02 in the BX register (meaning that you want to write into the Lenovo variable) and the address of previously created header in the ECX and EDI registers (to tell the SW SMI handler what you want to write into that variable).<crlf>Now, that variable contains a specified amount of SMRAM data so we only need to read it. We allocate a new buffer (equal to the size of the header plus the size of data to retrieve) and copy the same header into it, as used in step 2.<crlf>Invoke the SW SMI handler again, specifying the command with ID 0x01 in BX register (meaning that you want to read from the Lenovo variable) and the address of our newly allocated buffer from step 4 in the ECX and EDI registers (to tell the SW SMI handler where we want to copy the content of the Lenovo variable which at this moment contains data from the SMRAM)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd779444f>",
                    "type": "UnknownWord",
                    "value": "edi"
                },
                "references": {
                    "sentences": [
                        "64-bit physical address built from the values stored in the ECX and EDI registers.<crlf>The command, indicating the action to be executed (read, write, delete, etc.), from the BX register.",
                        "Find the SMRAM physical address.<crlf>Copy the LENV_HDR header to the physical address 32 bytes before the SMRAM the header should contain a variable identifier (it can be a random GUID) and the length of the data one would like to read from SMRAM (the maximum is something below 4KB).<crlf>Invoke SW SMI registered by the LenovoVariableSmm (SwSmiNumber 0x80), specifying the command with ID 0x02 in the BX register (meaning that you want to write into the Lenovo variable) and the address of previously created header in the ECX and EDI registers (to tell the SW SMI handler what you want to write into that variable).<crlf>Now, that variable contains a specified amount of SMRAM data so we only need to read it. We allocate a new buffer (equal to the size of the header plus the size of data to retrieve) and copy the same header into it, as used in step 2.<crlf>Invoke the SW SMI handler again, specifying the command with ID 0x01 in BX register (meaning that you want to read from the Lenovo variable) and the address of our newly allocated buffer from step 4 in the ECX and EDI registers (to tell the SW SMI handler where we want to copy the content of the Lenovo variable which at this moment contains data from the SMRAM)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x99239422>",
                    "type": "UnknownWord",
                    "value": "0x20-byte"
                },
                "references": {
                    "sentences": [
                        "The buffer starts with the 0x20-byte header (LENV_HDR), containing the unique GUID that identifies the Lenovo variable and a 32-bit value specifying the length of the data to be retrieved from the variable or written to it. The memory space located immediately after the header is used as a source or destination location for LENOVO_VARIABLE_PROTOCOLs Read and Write functions."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb82c224e>",
                    "type": "UnknownWord",
                    "value": "lenv_hdr"
                },
                "references": {
                    "sentences": [
                        "The buffer starts with the 0x20-byte header (LENV_HDR), containing the unique GUID that identifies the Lenovo variable and a 32-bit value specifying the length of the data to be retrieved from the variable or written to it. The memory space located immediately after the header is used as a source or destination location for LENOVO_VARIABLE_PROTOCOLs Read and Write functions.",
                        "Find the SMRAM physical address.<crlf>Copy the LENV_HDR header to the physical address 32 bytes before the SMRAM the header should contain a variable identifier (it can be a random GUID) and the length of the data one would like to read from SMRAM (the maximum is something below 4KB).<crlf>Invoke SW SMI registered by the LenovoVariableSmm (SwSmiNumber 0x80), specifying the command with ID 0x02 in the BX register (meaning that you want to write into the Lenovo variable) and the address of previously created header in the ECX and EDI registers (to tell the SW SMI handler what you want to write into that variable).<crlf>Now, that variable contains a specified amount of SMRAM data so we only need to read it. We allocate a new buffer (equal to the size of the header plus the size of data to retrieve) and copy the same header into it, as used in step 2.<crlf>Invoke the SW SMI handler again, specifying the command with ID 0x01 in BX register (meaning that you want to read from the Lenovo variable) and the address of our newly allocated buffer from step 4 in the ECX and EDI registers (to tell the SW SMI handler where we want to copy the content of the Lenovo variable which at this moment contains data from the SMRAM)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc87c9b23>",
                    "type": "UnknownWord",
                    "value": "specifying"
                },
                "references": {
                    "sentences": [
                        "The buffer starts with the 0x20-byte header (LENV_HDR), containing the unique GUID that identifies the Lenovo variable and a 32-bit value specifying the length of the data to be retrieved from the variable or written to it. The memory space located immediately after the header is used as a source or destination location for LENOVO_VARIABLE_PROTOCOLs Read and Write functions.",
                        "Find the SMRAM physical address.<crlf>Copy the LENV_HDR header to the physical address 32 bytes before the SMRAM the header should contain a variable identifier (it can be a random GUID) and the length of the data one would like to read from SMRAM (the maximum is something below 4KB).<crlf>Invoke SW SMI registered by the LenovoVariableSmm (SwSmiNumber 0x80), specifying the command with ID 0x02 in the BX register (meaning that you want to write into the Lenovo variable) and the address of previously created header in the ECX and EDI registers (to tell the SW SMI handler what you want to write into that variable).<crlf>Now, that variable contains a specified amount of SMRAM data so we only need to read it. We allocate a new buffer (equal to the size of the header plus the size of data to retrieve) and copy the same header into it, as used in step 2.<crlf>Invoke the SW SMI handler again, specifying the command with ID 0x01 in BX register (meaning that you want to read from the Lenovo variable) and the address of our newly allocated buffer from step 4 in the ECX and EDI registers (to tell the SW SMI handler where we want to copy the content of the Lenovo variable which at this moment contains data from the SMRAM)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x301d400d>",
                    "type": "UnknownWord",
                    "value": "caller"
                },
                "references": {
                    "sentences": [
                        "The problem is, the physical address provided by the caller is not validated or checked in any way and its directly passed as an argument to the LENOVO_VARIABLE_PROTOCOL functions (see line 41 in Figure 15). This allows an attacker to pass any physical address including an address from the SMRAM range."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5399f583>",
                    "type": "UnknownWord",
                    "value": "validated"
                },
                "references": {
                    "sentences": [
                        "The problem is, the physical address provided by the caller is not validated or checked in any way and its directly passed as an argument to the LENOVO_VARIABLE_PROTOCOL functions (see line 41 in Figure 15). This allows an attacker to pass any physical address including an address from the SMRAM range."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x66490e08>",
                    "type": "UnknownWord",
                    "value": "lenovo_variable_protocol"
                },
                "references": {
                    "sentences": [
                        "The problem is, the physical address provided by the caller is not validated or checked in any way and its directly passed as an argument to the LENOVO_VARIABLE_PROTOCOL functions (see line 41 in Figure 15). This allows an attacker to pass any physical address including an address from the SMRAM range."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x69211ea9>",
                    "type": "UnknownWord",
                    "value": "swsminumber"
                },
                "references": {
                    "sentences": [
                        "Find the SMRAM physical address.<crlf>Copy the LENV_HDR header to the physical address 32 bytes before the SMRAM the header should contain a variable identifier (it can be a random GUID) and the length of the data one would like to read from SMRAM (the maximum is something below 4KB).<crlf>Invoke SW SMI registered by the LenovoVariableSmm (SwSmiNumber 0x80), specifying the command with ID 0x02 in the BX register (meaning that you want to write into the Lenovo variable) and the address of previously created header in the ECX and EDI registers (to tell the SW SMI handler what you want to write into that variable).<crlf>Now, that variable contains a specified amount of SMRAM data so we only need to read it. We allocate a new buffer (equal to the size of the header plus the size of data to retrieve) and copy the same header into it, as used in step 2.<crlf>Invoke the SW SMI handler again, specifying the command with ID 0x01 in BX register (meaning that you want to read from the Lenovo variable) and the address of our newly allocated buffer from step 4 in the ECX and EDI registers (to tell the SW SMI handler where we want to copy the content of the Lenovo variable which at this moment contains data from the SMRAM)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8d24d1d>",
                    "type": "UnknownWord",
                    "value": "tell"
                },
                "references": {
                    "sentences": [
                        "Find the SMRAM physical address.<crlf>Copy the LENV_HDR header to the physical address 32 bytes before the SMRAM the header should contain a variable identifier (it can be a random GUID) and the length of the data one would like to read from SMRAM (the maximum is something below 4KB).<crlf>Invoke SW SMI registered by the LenovoVariableSmm (SwSmiNumber 0x80), specifying the command with ID 0x02 in the BX register (meaning that you want to write into the Lenovo variable) and the address of previously created header in the ECX and EDI registers (to tell the SW SMI handler what you want to write into that variable).<crlf>Now, that variable contains a specified amount of SMRAM data so we only need to read it. We allocate a new buffer (equal to the size of the header plus the size of data to retrieve) and copy the same header into it, as used in step 2.<crlf>Invoke the SW SMI handler again, specifying the command with ID 0x01 in BX register (meaning that you want to read from the Lenovo variable) and the address of our newly allocated buffer from step 4 in the ECX and EDI registers (to tell the SW SMI handler where we want to copy the content of the Lenovo variable which at this moment contains data from the SMRAM)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf60948a4>",
                    "type": "UnknownWord",
                    "value": "allocate"
                },
                "references": {
                    "sentences": [
                        "Find the SMRAM physical address.<crlf>Copy the LENV_HDR header to the physical address 32 bytes before the SMRAM the header should contain a variable identifier (it can be a random GUID) and the length of the data one would like to read from SMRAM (the maximum is something below 4KB).<crlf>Invoke SW SMI registered by the LenovoVariableSmm (SwSmiNumber 0x80), specifying the command with ID 0x02 in the BX register (meaning that you want to write into the Lenovo variable) and the address of previously created header in the ECX and EDI registers (to tell the SW SMI handler what you want to write into that variable).<crlf>Now, that variable contains a specified amount of SMRAM data so we only need to read it. We allocate a new buffer (equal to the size of the header plus the size of data to retrieve) and copy the same header into it, as used in step 2.<crlf>Invoke the SW SMI handler again, specifying the command with ID 0x01 in BX register (meaning that you want to read from the Lenovo variable) and the address of our newly allocated buffer from step 4 in the ECX and EDI registers (to tell the SW SMI handler where we want to copy the content of the Lenovo variable which at this moment contains data from the SMRAM)."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf60948a4>",
                            "type": "UnknownWord",
                            "value": "allocate"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf60948a4>",
                            "type": "UnknownWord",
                            "value": "allocate"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf60948a4>",
                            "type": "UnknownWord",
                            "value": "allocate"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf60948a4>",
                            "type": "UnknownWord",
                            "value": "allocate"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf60948a4>",
                            "type": "UnknownWord",
                            "value": "allocate"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf60948a4>",
                            "type": "UnknownWord",
                            "value": "allocate"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x77da1dcb>",
                    "type": "UnknownWord",
                    "value": "equal"
                },
                "references": {
                    "sentences": [
                        "Find the SMRAM physical address.<crlf>Copy the LENV_HDR header to the physical address 32 bytes before the SMRAM the header should contain a variable identifier (it can be a random GUID) and the length of the data one would like to read from SMRAM (the maximum is something below 4KB).<crlf>Invoke SW SMI registered by the LenovoVariableSmm (SwSmiNumber 0x80), specifying the command with ID 0x02 in the BX register (meaning that you want to write into the Lenovo variable) and the address of previously created header in the ECX and EDI registers (to tell the SW SMI handler what you want to write into that variable).<crlf>Now, that variable contains a specified amount of SMRAM data so we only need to read it. We allocate a new buffer (equal to the size of the header plus the size of data to retrieve) and copy the same header into it, as used in step 2.<crlf>Invoke the SW SMI handler again, specifying the command with ID 0x01 in BX register (meaning that you want to read from the Lenovo variable) and the address of our newly allocated buffer from step 4 in the ECX and EDI registers (to tell the SW SMI handler where we want to copy the content of the Lenovo variable which at this moment contains data from the SMRAM)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3131d19a>",
                    "type": "UnknownWord",
                    "value": "allocated"
                },
                "references": {
                    "sentences": [
                        "Find the SMRAM physical address.<crlf>Copy the LENV_HDR header to the physical address 32 bytes before the SMRAM the header should contain a variable identifier (it can be a random GUID) and the length of the data one would like to read from SMRAM (the maximum is something below 4KB).<crlf>Invoke SW SMI registered by the LenovoVariableSmm (SwSmiNumber 0x80), specifying the command with ID 0x02 in the BX register (meaning that you want to write into the Lenovo variable) and the address of previously created header in the ECX and EDI registers (to tell the SW SMI handler what you want to write into that variable).<crlf>Now, that variable contains a specified amount of SMRAM data so we only need to read it. We allocate a new buffer (equal to the size of the header plus the size of data to retrieve) and copy the same header into it, as used in step 2.<crlf>Invoke the SW SMI handler again, specifying the command with ID 0x01 in BX register (meaning that you want to read from the Lenovo variable) and the address of our newly allocated buffer from step 4 in the ECX and EDI registers (to tell the SW SMI handler where we want to copy the content of the Lenovo variable which at this moment contains data from the SMRAM)."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3131d19a>",
                            "type": "UnknownWord",
                            "value": "allocated"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3131d19a>",
                            "type": "UnknownWord",
                            "value": "allocated"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3131d19a>",
                            "type": "UnknownWord",
                            "value": "allocated"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3131d19a>",
                            "type": "UnknownWord",
                            "value": "allocated"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3131d19a>",
                            "type": "UnknownWord",
                            "value": "allocated"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3131d19a>",
                            "type": "UnknownWord",
                            "value": "allocated"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc1b1a5f9>",
                    "type": "UnknownWord",
                    "value": "above-described"
                },
                "references": {
                    "sentences": [
                        "An example of the above-described steps using the CHIPSEC framework is shown in Figure 17; the output of the script containing the first 0x100 bytes of the SMRAM is shown in Figure 18."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xac629237>",
                    "type": "UnknownWord",
                    "value": "binasciiimport"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac629237>",
                            "type": "UnknownWord",
                            "value": "binasciiimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac629237>",
                            "type": "UnknownWord",
                            "value": "binasciiimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac629237>",
                            "type": "UnknownWord",
                            "value": "binasciiimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac629237>",
                            "type": "UnknownWord",
                            "value": "binasciiimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac629237>",
                            "type": "UnknownWord",
                            "value": "binasciiimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac629237>",
                            "type": "UnknownWord",
                            "value": "binasciiimport"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xca336029>",
                    "type": "UnknownWord",
                    "value": "structimport"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xca336029>",
                            "type": "UnknownWord",
                            "value": "structimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xca336029>",
                            "type": "UnknownWord",
                            "value": "structimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xca336029>",
                            "type": "UnknownWord",
                            "value": "structimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xca336029>",
                            "type": "UnknownWord",
                            "value": "structimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xca336029>",
                            "type": "UnknownWord",
                            "value": "structimport"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xca336029>",
                            "type": "UnknownWord",
                            "value": "structimport"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xae3d31e>",
                    "type": "UnknownWord",
                    "value": "interruptsfrom"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xae3d31e>",
                            "type": "UnknownWord",
                            "value": "interruptsfrom"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xae3d31e>",
                            "type": "UnknownWord",
                            "value": "interruptsfrom"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xae3d31e>",
                            "type": "UnknownWord",
                            "value": "interruptsfrom"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xae3d31e>",
                            "type": "UnknownWord",
                            "value": "interruptsfrom"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xae3d31e>",
                            "type": "UnknownWord",
                            "value": "interruptsfrom"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xae3d31e>",
                            "type": "UnknownWord",
                            "value": "interruptsfrom"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7f4e9d84>",
                    "type": "UnknownWord",
                    "value": "hexdump"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f4e9d84>",
                            "type": "UnknownWord",
                            "value": "hexdump"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f4e9d84>",
                            "type": "UnknownWord",
                            "value": "hexdump"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f4e9d84>",
                            "type": "UnknownWord",
                            "value": "hexdump"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f4e9d84>",
                            "type": "UnknownWord",
                            "value": "hexdump"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f4e9d84>",
                            "type": "UnknownWord",
                            "value": "hexdump"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7f4e9d84>",
                            "type": "UnknownWord",
                            "value": "hexdump"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2bd42a89>",
                    "type": "UnknownWord",
                    "value": "intr"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2bd42a89>",
                            "type": "UnknownWord",
                            "value": "intr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2bd42a89>",
                            "type": "UnknownWord",
                            "value": "intr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2bd42a89>",
                            "type": "UnknownWord",
                            "value": "intr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2bd42a89>",
                            "type": "UnknownWord",
                            "value": "intr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2bd42a89>",
                            "type": "UnknownWord",
                            "value": "intr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2bd42a89>",
                            "type": "UnknownWord",
                            "value": "intr"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9471467e>",
                    "type": "UnknownWord",
                    "value": "mem_read"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9471467e>",
                            "type": "UnknownWord",
                            "value": "mem_read"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9471467e>",
                            "type": "UnknownWord",
                            "value": "mem_read"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9471467e>",
                            "type": "UnknownWord",
                            "value": "mem_read"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9471467e>",
                            "type": "UnknownWord",
                            "value": "mem_read"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9471467e>",
                            "type": "UnknownWord",
                            "value": "mem_read"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9471467e>",
                            "type": "UnknownWord",
                            "value": "mem_read"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4a114121>",
                    "type": "UnknownWord",
                    "value": "read_physical_memmem_write"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4a114121>",
                            "type": "UnknownWord",
                            "value": "read_physical_memmem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4a114121>",
                            "type": "UnknownWord",
                            "value": "read_physical_memmem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4a114121>",
                            "type": "UnknownWord",
                            "value": "read_physical_memmem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4a114121>",
                            "type": "UnknownWord",
                            "value": "read_physical_memmem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4a114121>",
                            "type": "UnknownWord",
                            "value": "read_physical_memmem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4a114121>",
                            "type": "UnknownWord",
                            "value": "read_physical_memmem_write"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa0644f88>",
                    "type": "UnknownWord",
                    "value": "write_physical_memmem_alloc"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa0644f88>",
                            "type": "UnknownWord",
                            "value": "write_physical_memmem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa0644f88>",
                            "type": "UnknownWord",
                            "value": "write_physical_memmem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa0644f88>",
                            "type": "UnknownWord",
                            "value": "write_physical_memmem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa0644f88>",
                            "type": "UnknownWord",
                            "value": "write_physical_memmem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa0644f88>",
                            "type": "UnknownWord",
                            "value": "write_physical_memmem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa0644f88>",
                            "type": "UnknownWord",
                            "value": "write_physical_memmem_alloc"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4bb7ce50>",
                    "type": "UnknownWord",
                    "value": "alloc_physical_mem"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4bb7ce50>",
                            "type": "UnknownWord",
                            "value": "alloc_physical_mem"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4bb7ce50>",
                            "type": "UnknownWord",
                            "value": "alloc_physical_mem"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4bb7ce50>",
                            "type": "UnknownWord",
                            "value": "alloc_physical_mem"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4bb7ce50>",
                            "type": "UnknownWord",
                            "value": "alloc_physical_mem"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4bb7ce50>",
                            "type": "UnknownWord",
                            "value": "alloc_physical_mem"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4bb7ce50>",
                            "type": "UnknownWord",
                            "value": "alloc_physical_mem"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1a6eaccf>",
                    "type": "UnknownWord",
                    "value": "addresssmram_addr"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1a6eaccf>",
                            "type": "UnknownWord",
                            "value": "addresssmram_addr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1a6eaccf>",
                            "type": "UnknownWord",
                            "value": "addresssmram_addr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1a6eaccf>",
                            "type": "UnknownWord",
                            "value": "addresssmram_addr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1a6eaccf>",
                            "type": "UnknownWord",
                            "value": "addresssmram_addr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1a6eaccf>",
                            "type": "UnknownWord",
                            "value": "addresssmram_addr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1a6eaccf>",
                            "type": "UnknownWord",
                            "value": "addresssmram_addr"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe4787692>",
                    "type": "UnknownWord",
                    "value": "get_smram"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe4787692>",
                            "type": "UnknownWord",
                            "value": "get_smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe4787692>",
                            "type": "UnknownWord",
                            "value": "get_smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe4787692>",
                            "type": "UnknownWord",
                            "value": "get_smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe4787692>",
                            "type": "UnknownWord",
                            "value": "get_smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe4787692>",
                            "type": "UnknownWord",
                            "value": "get_smram"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe4787692>",
                            "type": "UnknownWord",
                            "value": "get_smram"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf83b6301>",
                    "type": "UnknownWord",
                    "value": "hdr_sz"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf83b6301>",
                            "type": "UnknownWord",
                            "value": "hdr_sz"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf83b6301>",
                            "type": "UnknownWord",
                            "value": "hdr_sz"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf83b6301>",
                            "type": "UnknownWord",
                            "value": "hdr_sz"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf83b6301>",
                            "type": "UnknownWord",
                            "value": "hdr_sz"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf83b6301>",
                            "type": "UnknownWord",
                            "value": "hdr_sz"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf83b6301>",
                            "type": "UnknownWord",
                            "value": "hdr_sz"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb629a9e5>",
                    "type": "UnknownWord",
                    "value": "0x20var_size"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb629a9e5>",
                            "type": "UnknownWord",
                            "value": "0x20var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb629a9e5>",
                            "type": "UnknownWord",
                            "value": "0x20var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb629a9e5>",
                            "type": "UnknownWord",
                            "value": "0x20var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb629a9e5>",
                            "type": "UnknownWord",
                            "value": "0x20var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb629a9e5>",
                            "type": "UnknownWord",
                            "value": "0x20var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb629a9e5>",
                            "type": "UnknownWord",
                            "value": "0x20var_size"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa263693a>",
                    "type": "UnknownWord",
                    "value": "0x100var_guid"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa263693a>",
                            "type": "UnknownWord",
                            "value": "0x100var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa263693a>",
                            "type": "UnknownWord",
                            "value": "0x100var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa263693a>",
                            "type": "UnknownWord",
                            "value": "0x100var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa263693a>",
                            "type": "UnknownWord",
                            "value": "0x100var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa263693a>",
                            "type": "UnknownWord",
                            "value": "0x100var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa263693a>",
                            "type": "UnknownWord",
                            "value": "0x100var_guid"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x33d5b2>",
                    "type": "UnknownWord",
                    "value": "smi_num"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x33d5b2>",
                            "type": "UnknownWord",
                            "value": "smi_num"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x33d5b2>",
                            "type": "UnknownWord",
                            "value": "smi_num"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x33d5b2>",
                            "type": "UnknownWord",
                            "value": "smi_num"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x33d5b2>",
                            "type": "UnknownWord",
                            "value": "smi_num"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x33d5b2>",
                            "type": "UnknownWord",
                            "value": "smi_num"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x33d5b2>",
                            "type": "UnknownWord",
                            "value": "smi_num"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1ecbb2a6>",
                    "type": "UnknownWord",
                    "value": "smramphys_buff"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1ecbb2a6>",
                            "type": "UnknownWord",
                            "value": "smramphys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1ecbb2a6>",
                            "type": "UnknownWord",
                            "value": "smramphys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1ecbb2a6>",
                            "type": "UnknownWord",
                            "value": "smramphys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1ecbb2a6>",
                            "type": "UnknownWord",
                            "value": "smramphys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1ecbb2a6>",
                            "type": "UnknownWord",
                            "value": "smramphys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1ecbb2a6>",
                            "type": "UnknownWord",
                            "value": "smramphys_buff"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x41b23ff4>",
                    "type": "UnknownWord",
                    "value": "smram_addr-hdr_szhdr"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x41b23ff4>",
                            "type": "UnknownWord",
                            "value": "smram_addr-hdr_szhdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x41b23ff4>",
                            "type": "UnknownWord",
                            "value": "smram_addr-hdr_szhdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x41b23ff4>",
                            "type": "UnknownWord",
                            "value": "smram_addr-hdr_szhdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x41b23ff4>",
                            "type": "UnknownWord",
                            "value": "smram_addr-hdr_szhdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x41b23ff4>",
                            "type": "UnknownWord",
                            "value": "smram_addr-hdr_szhdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x41b23ff4>",
                            "type": "UnknownWord",
                            "value": "smram_addr-hdr_szhdr"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbac8d6cc>",
                    "type": "UnknownWord",
                    "value": "x00"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbac8d6cc>",
                            "type": "UnknownWord",
                            "value": "x00"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbac8d6cc>",
                            "type": "UnknownWord",
                            "value": "x00"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbac8d6cc>",
                            "type": "UnknownWord",
                            "value": "x00"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbac8d6cc>",
                            "type": "UnknownWord",
                            "value": "x00"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbac8d6cc>",
                            "type": "UnknownWord",
                            "value": "x00"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbac8d6cc>",
                            "type": "UnknownWord",
                            "value": "x00"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4c299b67>",
                    "type": "UnknownWord",
                    "value": "var_guid"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4c299b67>",
                            "type": "UnknownWord",
                            "value": "var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4c299b67>",
                            "type": "UnknownWord",
                            "value": "var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4c299b67>",
                            "type": "UnknownWord",
                            "value": "var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4c299b67>",
                            "type": "UnknownWord",
                            "value": "var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4c299b67>",
                            "type": "UnknownWord",
                            "value": "var_guid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4c299b67>",
                            "type": "UnknownWord",
                            "value": "var_guid"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x20780444>",
                    "type": "UnknownWord",
                    "value": "<i"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x20780444>",
                            "type": "UnknownWord",
                            "value": "<i"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x20780444>",
                            "type": "UnknownWord",
                            "value": "<i"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x20780444>",
                            "type": "UnknownWord",
                            "value": "<i"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x20780444>",
                            "type": "UnknownWord",
                            "value": "<i"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x20780444>",
                            "type": "UnknownWord",
                            "value": "<i"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x20780444>",
                            "type": "UnknownWord",
                            "value": "<i"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4252f11e>",
                    "type": "UnknownWord",
                    "value": "var_size"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4252f11e>",
                            "type": "UnknownWord",
                            "value": "var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4252f11e>",
                            "type": "UnknownWord",
                            "value": "var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4252f11e>",
                            "type": "UnknownWord",
                            "value": "var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4252f11e>",
                            "type": "UnknownWord",
                            "value": "var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4252f11e>",
                            "type": "UnknownWord",
                            "value": "var_size"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4252f11e>",
                            "type": "UnknownWord",
                            "value": "var_size"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9866b1f7>",
                    "type": "UnknownWord",
                    "value": "mem_write"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9866b1f7>",
                            "type": "UnknownWord",
                            "value": "mem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9866b1f7>",
                            "type": "UnknownWord",
                            "value": "mem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9866b1f7>",
                            "type": "UnknownWord",
                            "value": "mem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9866b1f7>",
                            "type": "UnknownWord",
                            "value": "mem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9866b1f7>",
                            "type": "UnknownWord",
                            "value": "mem_write"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9866b1f7>",
                            "type": "UnknownWord",
                            "value": "mem_write"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4b81bccc>",
                    "type": "UnknownWord",
                    "value": "phys_buff"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4b81bccc>",
                            "type": "UnknownWord",
                            "value": "phys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4b81bccc>",
                            "type": "UnknownWord",
                            "value": "phys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4b81bccc>",
                            "type": "UnknownWord",
                            "value": "phys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4b81bccc>",
                            "type": "UnknownWord",
                            "value": "phys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4b81bccc>",
                            "type": "UnknownWord",
                            "value": "phys_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4b81bccc>",
                            "type": "UnknownWord",
                            "value": "phys_buff"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc4344a4d>",
                    "type": "UnknownWord",
                    "value": "hdr"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc4344a4d>",
                            "type": "UnknownWord",
                            "value": "hdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc4344a4d>",
                            "type": "UnknownWord",
                            "value": "hdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc4344a4d>",
                            "type": "UnknownWord",
                            "value": "hdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc4344a4d>",
                            "type": "UnknownWord",
                            "value": "hdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc4344a4d>",
                            "type": "UnknownWord",
                            "value": "hdr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc4344a4d>",
                            "type": "UnknownWord",
                            "value": "hdr"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xac287262>",
                    "type": "UnknownWord",
                    "value": ">>"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac287262>",
                            "type": "UnknownWord",
                            "value": ">>"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac287262>",
                            "type": "UnknownWord",
                            "value": ">>"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac287262>",
                            "type": "UnknownWord",
                            "value": ">>"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac287262>",
                            "type": "UnknownWord",
                            "value": ">>"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac287262>",
                            "type": "UnknownWord",
                            "value": ">>"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xac287262>",
                            "type": "UnknownWord",
                            "value": ">>"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8bbf54a1>",
                    "type": "UnknownWord",
                    "value": "0xfffffffflow"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8bbf54a1>",
                            "type": "UnknownWord",
                            "value": "0xfffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8bbf54a1>",
                            "type": "UnknownWord",
                            "value": "0xfffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8bbf54a1>",
                            "type": "UnknownWord",
                            "value": "0xfffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8bbf54a1>",
                            "type": "UnknownWord",
                            "value": "0xfffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8bbf54a1>",
                            "type": "UnknownWord",
                            "value": "0xfffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8bbf54a1>",
                            "type": "UnknownWord",
                            "value": "0xfffffffflow"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbbe4007d>",
                    "type": "UnknownWord",
                    "value": "0xffffffff_rcx"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbbe4007d>",
                            "type": "UnknownWord",
                            "value": "0xffffffff_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbbe4007d>",
                            "type": "UnknownWord",
                            "value": "0xffffffff_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbbe4007d>",
                            "type": "UnknownWord",
                            "value": "0xffffffff_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbbe4007d>",
                            "type": "UnknownWord",
                            "value": "0xffffffff_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbbe4007d>",
                            "type": "UnknownWord",
                            "value": "0xffffffff_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbbe4007d>",
                            "type": "UnknownWord",
                            "value": "0xffffffff_rcx"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6e4743bd>",
                    "type": "UnknownWord",
                    "value": "low_rbx"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x6e4743bd>",
                            "type": "UnknownWord",
                            "value": "low_rbx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x6e4743bd>",
                            "type": "UnknownWord",
                            "value": "low_rbx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x6e4743bd>",
                            "type": "UnknownWord",
                            "value": "low_rbx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x6e4743bd>",
                            "type": "UnknownWord",
                            "value": "low_rbx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x6e4743bd>",
                            "type": "UnknownWord",
                            "value": "low_rbx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x6e4743bd>",
                            "type": "UnknownWord",
                            "value": "low_rbx"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbf833fdc>",
                    "type": "UnknownWord",
                    "value": "variable_rdx"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbf833fdc>",
                            "type": "UnknownWord",
                            "value": "variable_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbf833fdc>",
                            "type": "UnknownWord",
                            "value": "variable_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbf833fdc>",
                            "type": "UnknownWord",
                            "value": "variable_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbf833fdc>",
                            "type": "UnknownWord",
                            "value": "variable_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbf833fdc>",
                            "type": "UnknownWord",
                            "value": "variable_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbf833fdc>",
                            "type": "UnknownWord",
                            "value": "variable_rdx"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x93ce8f1b>",
                    "type": "UnknownWord",
                    "value": "0xb2_rax"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x93ce8f1b>",
                            "type": "UnknownWord",
                            "value": "0xb2_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x93ce8f1b>",
                            "type": "UnknownWord",
                            "value": "0xb2_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x93ce8f1b>",
                            "type": "UnknownWord",
                            "value": "0xb2_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x93ce8f1b>",
                            "type": "UnknownWord",
                            "value": "0xb2_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x93ce8f1b>",
                            "type": "UnknownWord",
                            "value": "0xb2_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x93ce8f1b>",
                            "type": "UnknownWord",
                            "value": "0xb2_rax"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x99e01676>",
                    "type": "UnknownWord",
                    "value": "0x5380_rdi"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x99e01676>",
                            "type": "UnknownWord",
                            "value": "0x5380_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x99e01676>",
                            "type": "UnknownWord",
                            "value": "0x5380_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x99e01676>",
                            "type": "UnknownWord",
                            "value": "0x5380_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x99e01676>",
                            "type": "UnknownWord",
                            "value": "0x5380_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x99e01676>",
                            "type": "UnknownWord",
                            "value": "0x5380_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x99e01676>",
                            "type": "UnknownWord",
                            "value": "0x5380_rdi"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb0535127>",
                    "type": "UnknownWord",
                    "value": "highintr"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb0535127>",
                            "type": "UnknownWord",
                            "value": "highintr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb0535127>",
                            "type": "UnknownWord",
                            "value": "highintr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb0535127>",
                            "type": "UnknownWord",
                            "value": "highintr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb0535127>",
                            "type": "UnknownWord",
                            "value": "highintr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb0535127>",
                            "type": "UnknownWord",
                            "value": "highintr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb0535127>",
                            "type": "UnknownWord",
                            "value": "highintr"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x12bc107d>",
                    "type": "UnknownWord",
                    "value": "send_sw_smi"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x12bc107d>",
                            "type": "UnknownWord",
                            "value": "send_sw_smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x12bc107d>",
                            "type": "UnknownWord",
                            "value": "send_sw_smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x12bc107d>",
                            "type": "UnknownWord",
                            "value": "send_sw_smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x12bc107d>",
                            "type": "UnknownWord",
                            "value": "send_sw_smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x12bc107d>",
                            "type": "UnknownWord",
                            "value": "send_sw_smi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x12bc107d>",
                            "type": "UnknownWord",
                            "value": "send_sw_smi"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x94f3253e>",
                    "type": "UnknownWord",
                    "value": "_rax"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x94f3253e>",
                            "type": "UnknownWord",
                            "value": "_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x94f3253e>",
                            "type": "UnknownWord",
                            "value": "_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x94f3253e>",
                            "type": "UnknownWord",
                            "value": "_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x94f3253e>",
                            "type": "UnknownWord",
                            "value": "_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x94f3253e>",
                            "type": "UnknownWord",
                            "value": "_rax"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x94f3253e>",
                            "type": "UnknownWord",
                            "value": "_rax"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb3b2cd6a>",
                    "type": "UnknownWord",
                    "value": "_rbx"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb3b2cd6a>",
                            "type": "UnknownWord",
                            "value": "_rbx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb3b2cd6a>",
                            "type": "UnknownWord",
                            "value": "_rbx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb3b2cd6a>",
                            "type": "UnknownWord",
                            "value": "_rbx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb3b2cd6a>",
                            "type": "UnknownWord",
                            "value": "_rbx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb3b2cd6a>",
                            "type": "UnknownWord",
                            "value": "_rbx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb3b2cd6a>",
                            "type": "UnknownWord",
                            "value": "_rbx"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa198a1de>",
                    "type": "UnknownWord",
                    "value": "_rcx"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa198a1de>",
                            "type": "UnknownWord",
                            "value": "_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa198a1de>",
                            "type": "UnknownWord",
                            "value": "_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa198a1de>",
                            "type": "UnknownWord",
                            "value": "_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa198a1de>",
                            "type": "UnknownWord",
                            "value": "_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa198a1de>",
                            "type": "UnknownWord",
                            "value": "_rcx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa198a1de>",
                            "type": "UnknownWord",
                            "value": "_rcx"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcb3c6be8>",
                    "type": "UnknownWord",
                    "value": "_rdx"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcb3c6be8>",
                            "type": "UnknownWord",
                            "value": "_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcb3c6be8>",
                            "type": "UnknownWord",
                            "value": "_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcb3c6be8>",
                            "type": "UnknownWord",
                            "value": "_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcb3c6be8>",
                            "type": "UnknownWord",
                            "value": "_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcb3c6be8>",
                            "type": "UnknownWord",
                            "value": "_rdx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcb3c6be8>",
                            "type": "UnknownWord",
                            "value": "_rdx"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2e75d5fb>",
                    "type": "UnknownWord",
                    "value": "_rdi"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2e75d5fb>",
                            "type": "UnknownWord",
                            "value": "_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2e75d5fb>",
                            "type": "UnknownWord",
                            "value": "_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2e75d5fb>",
                            "type": "UnknownWord",
                            "value": "_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2e75d5fb>",
                            "type": "UnknownWord",
                            "value": "_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2e75d5fb>",
                            "type": "UnknownWord",
                            "value": "_rdi"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2e75d5fb>",
                            "type": "UnknownWord",
                            "value": "_rdi"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc3f0b985>",
                    "type": "UnknownWord",
                    "value": "zeroe"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc3f0b985>",
                            "type": "UnknownWord",
                            "value": "zeroe"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc3f0b985>",
                            "type": "UnknownWord",
                            "value": "zeroe"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc3f0b985>",
                            "type": "UnknownWord",
                            "value": "zeroe"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc3f0b985>",
                            "type": "UnknownWord",
                            "value": "zeroe"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc3f0b985>",
                            "type": "UnknownWord",
                            "value": "zeroe"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc3f0b985>",
                            "type": "UnknownWord",
                            "value": "zeroe"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5c9bd643>",
                    "type": "UnknownWord",
                    "value": "buffersz_to_alloc"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c9bd643>",
                            "type": "UnknownWord",
                            "value": "buffersz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c9bd643>",
                            "type": "UnknownWord",
                            "value": "buffersz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c9bd643>",
                            "type": "UnknownWord",
                            "value": "buffersz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c9bd643>",
                            "type": "UnknownWord",
                            "value": "buffersz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c9bd643>",
                            "type": "UnknownWord",
                            "value": "buffersz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5c9bd643>",
                            "type": "UnknownWord",
                            "value": "buffersz_to_alloc"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd08a1abb>",
                    "type": "UnknownWord",
                    "value": "hdr_sz_va"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd08a1abb>",
                            "type": "UnknownWord",
                            "value": "hdr_sz_va"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd08a1abb>",
                            "type": "UnknownWord",
                            "value": "hdr_sz_va"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd08a1abb>",
                            "type": "UnknownWord",
                            "value": "hdr_sz_va"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd08a1abb>",
                            "type": "UnknownWord",
                            "value": "hdr_sz_va"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd08a1abb>",
                            "type": "UnknownWord",
                            "value": "hdr_sz_va"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd08a1abb>",
                            "type": "UnknownWord",
                            "value": "hdr_sz_va"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb70921eb>",
                    "type": "UnknownWord",
                    "value": "out_buff"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb70921eb>",
                            "type": "UnknownWord",
                            "value": "out_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb70921eb>",
                            "type": "UnknownWord",
                            "value": "out_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb70921eb>",
                            "type": "UnknownWord",
                            "value": "out_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb70921eb>",
                            "type": "UnknownWord",
                            "value": "out_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb70921eb>",
                            "type": "UnknownWord",
                            "value": "out_buff"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xb70921eb>",
                            "type": "UnknownWord",
                            "value": "out_buff"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x331ef1db>",
                    "type": "UnknownWord",
                    "value": "mem_alloc"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x331ef1db>",
                            "type": "UnknownWord",
                            "value": "mem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x331ef1db>",
                            "type": "UnknownWord",
                            "value": "mem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x331ef1db>",
                            "type": "UnknownWord",
                            "value": "mem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x331ef1db>",
                            "type": "UnknownWord",
                            "value": "mem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x331ef1db>",
                            "type": "UnknownWord",
                            "value": "mem_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x331ef1db>",
                            "type": "UnknownWord",
                            "value": "mem_alloc"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcdebf4e6>",
                    "type": "UnknownWord",
                    "value": "sz_to_alloc"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcdebf4e6>",
                            "type": "UnknownWord",
                            "value": "sz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcdebf4e6>",
                            "type": "UnknownWord",
                            "value": "sz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcdebf4e6>",
                            "type": "UnknownWord",
                            "value": "sz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcdebf4e6>",
                            "type": "UnknownWord",
                            "value": "sz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcdebf4e6>",
                            "type": "UnknownWord",
                            "value": "sz_to_alloc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcdebf4e6>",
                            "type": "UnknownWord",
                            "value": "sz_to_alloc"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa71c0661>",
                    "type": "UnknownWord",
                    "value": "bufferhigh"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa71c0661>",
                            "type": "UnknownWord",
                            "value": "bufferhigh"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa71c0661>",
                            "type": "UnknownWord",
                            "value": "bufferhigh"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa71c0661>",
                            "type": "UnknownWord",
                            "value": "bufferhigh"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa71c0661>",
                            "type": "UnknownWord",
                            "value": "bufferhigh"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa71c0661>",
                            "type": "UnknownWord",
                            "value": "bufferhigh"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa71c0661>",
                            "type": "UnknownWord",
                            "value": "bufferhigh"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa3fc3ad5>",
                    "type": "UnknownWord",
                    "value": "0xfffffffffffffffflow"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa3fc3ad5>",
                            "type": "UnknownWord",
                            "value": "0xfffffffffffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa3fc3ad5>",
                            "type": "UnknownWord",
                            "value": "0xfffffffffffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa3fc3ad5>",
                            "type": "UnknownWord",
                            "value": "0xfffffffffffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa3fc3ad5>",
                            "type": "UnknownWord",
                            "value": "0xfffffffffffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa3fc3ad5>",
                            "type": "UnknownWord",
                            "value": "0xfffffffffffffffflow"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa3fc3ad5>",
                            "type": "UnknownWord",
                            "value": "0xfffffffffffffffflow"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc7d9530d>",
                    "type": "UnknownWord",
                    "value": "highresult"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc7d9530d>",
                            "type": "UnknownWord",
                            "value": "highresult"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc7d9530d>",
                            "type": "UnknownWord",
                            "value": "highresult"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc7d9530d>",
                            "type": "UnknownWord",
                            "value": "highresult"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc7d9530d>",
                            "type": "UnknownWord",
                            "value": "highresult"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc7d9530d>",
                            "type": "UnknownWord",
                            "value": "highresult"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc7d9530d>",
                            "type": "UnknownWord",
                            "value": "highresult"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x306ff259>",
                    "type": "UnknownWord",
                    "value": "smramsmram_data"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x306ff259>",
                            "type": "UnknownWord",
                            "value": "smramsmram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x306ff259>",
                            "type": "UnknownWord",
                            "value": "smramsmram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x306ff259>",
                            "type": "UnknownWord",
                            "value": "smramsmram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x306ff259>",
                            "type": "UnknownWord",
                            "value": "smramsmram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x306ff259>",
                            "type": "UnknownWord",
                            "value": "smramsmram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x306ff259>",
                            "type": "UnknownWord",
                            "value": "smramsmram_data"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe0baaadc>",
                    "type": "UnknownWord",
                    "value": "smram_data"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe0baaadc>",
                            "type": "UnknownWord",
                            "value": "smram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe0baaadc>",
                            "type": "UnknownWord",
                            "value": "smram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe0baaadc>",
                            "type": "UnknownWord",
                            "value": "smram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe0baaadc>",
                            "type": "UnknownWord",
                            "value": "smram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe0baaadc>",
                            "type": "UnknownWord",
                            "value": "smram_data"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe0baaadc>",
                            "type": "UnknownWord",
                            "value": "smram_data"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8a2c480>",
                    "type": "UnknownWord",
                    "value": "worse"
                },
                "references": {
                    "sentences": [
                        "We have provided an example of how to read only the first 0x100 bytes of the SMRAM; however, with additional modifications, its possible to read/write the whole SMRAM range. This could allow threat actors to execute their own malicious code in SMM or even worse considering the LenovoVariable SW SMI handlers ability to modify the SPI flash write the attackers own malicious firmware implant directly to the SPI flash."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1525fafe>",
                    "type": "UnknownWord",
                    "value": "stack"
                },
                "references": {
                    "sentences": [
                        "UEFI threats can be extremely stealthy and dangerous. They are executed early in the boot process, before transferring control to the operating system, which means that they can bypass almost all security measures and mitigations higher in the stack that could prevent their OS payloads from being executed. So, how do UEFI threats overcome all the security protections that have been created to prevent deployment or execution of UEFI threats themselves?"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x890d0333>",
                    "type": "UnknownWord",
                    "value": "overcome"
                },
                "references": {
                    "sentences": [
                        "UEFI threats can be extremely stealthy and dangerous. They are executed early in the boot process, before transferring control to the operating system, which means that they can bypass almost all security measures and mitigations higher in the stack that could prevent their OS payloads from being executed. So, how do UEFI threats overcome all the security protections that have been created to prevent deployment or execution of UEFI threats themselves?"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8f003833>",
                    "type": "UnknownWord",
                    "value": "in-the-wild"
                },
                "references": {
                    "sentences": [
                        "All of the real-world UEFI threats discovered in recent years (LoJax, MosaicRegressor, MoonBounce, ESPecter, FinSpy) needed to bypass or disable the security mechanisms in some way in order to be deployed and executed. However, only in the case of LoJax, the first in-the-wild UEFI rootkit (discovered by ESET Research in 2018), do we have a clue how it was done by using the ReWriter_binary capable of exploiting the Speed Racer vulnerability."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x314b184>",
                    "type": "UnknownWord",
                    "value": "clue"
                },
                "references": {
                    "sentences": [
                        "All of the real-world UEFI threats discovered in recent years (LoJax, MosaicRegressor, MoonBounce, ESPecter, FinSpy) needed to bypass or disable the security mechanisms in some way in order to be deployed and executed. However, only in the case of LoJax, the first in-the-wild UEFI rootkit (discovered by ESET Research in 2018), do we have a clue how it was done by using the ReWriter_binary capable of exploiting the Speed Racer vulnerability."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd3ff2770>",
                    "type": "UnknownWord",
                    "value": "arent"
                },
                "references": {
                    "sentences": [
                        "Even though vulnerabilities arent the only option for turning off or bypassing firmware security mitigations, there are many such vulnerabilities and due to the number of different firmware implementations and their complexity, many more are likely just waiting to be discovered."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1b0f6350>",
                    "type": "UnknownWord",
                    "value": "waiting"
                },
                "references": {
                    "sentences": [
                        "Even though vulnerabilities arent the only option for turning off or bypassing firmware security mitigations, there are many such vulnerabilities and due to the number of different firmware implementations and their complexity, many more are likely just waiting to be discovered."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x888eba35>",
                    "type": "UnknownWord",
                    "value": "binarly"
                },
                "references": {
                    "sentences": [
                        "Only in the last year, we have seen numerous high-impact UEFI firmware vulnerabilities being publicly disclosed. Most notable are those by the researchers from Binarly, in their An In-Depth Look At The 23 High-Impact Vulnerabilities and 16 High Impact Vulnerabilities Discovered In HP Devices blogposts, and by researchers from SentinelOne in their Another Brick in the Wall: Uncovering SMM Vulnerabilities in HP Firmware blogpost."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb05ec6e>",
                    "type": "UnknownWord",
                    "value": "brick"
                },
                "references": {
                    "sentences": [
                        "Only in the last year, we have seen numerous high-impact UEFI firmware vulnerabilities being publicly disclosed. Most notable are those by the researchers from Binarly, in their An In-Depth Look At The 23 High-Impact Vulnerabilities and 16 High Impact Vulnerabilities Discovered In HP Devices blogposts, and by researchers from SentinelOne in their Another Brick in the Wall: Uncovering SMM Vulnerabilities in HP Firmware blogpost."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbbe77c32>",
                    "type": "UnknownWord",
                    "value": "wall"
                },
                "references": {
                    "sentences": [
                        "Only in the last year, we have seen numerous high-impact UEFI firmware vulnerabilities being publicly disclosed. Most notable are those by the researchers from Binarly, in their An In-Depth Look At The 23 High-Impact Vulnerabilities and 16 High Impact Vulnerabilities Discovered In HP Devices blogposts, and by researchers from SentinelOne in their Another Brick in the Wall: Uncovering SMM Vulnerabilities in HP Firmware blogpost."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x51580b83>",
                    "type": "UnknownWord",
                    "value": "larger"
                },
                "references": {
                    "sentences": [
                        "Our discovery, together with the above-mentioned ones, demonstrates that in some cases, deployment of UEFI threats might not be as difficult as expected, and the larger number of real-world UEFI threats discovered in the last years suggests that adversaries are aware of this."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd98dcedc>",
                    "type": "UnknownWord",
                    "value": "strongly"
                },
                "references": {
                    "sentences": [
                        "Regarding the vulnerabilities described in this blogpost, we strongly advise all owners of Lenovo laptops to go through the list of affected devices and update their firmware, ideally by following the manufacturers instructions."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7db6dc9f>",
                    "type": "UnknownWord",
                    "value": "advise"
                },
                "references": {
                    "sentences": [
                        "Regarding the vulnerabilities described in this blogpost, we strongly advise all owners of Lenovo laptops to go through the list of affected devices and update their firmware, ideally by following the manufacturers instructions."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb9d02358>",
                    "type": "UnknownWord",
                    "value": "ideally"
                },
                "references": {
                    "sentences": [
                        "Regarding the vulnerabilities described in this blogpost, we strongly advise all owners of Lenovo laptops to go through the list of affected devices and update their firmware, ideally by following the manufacturers instructions."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x58848ede>",
                    "type": "UnknownWord",
                    "value": "fixes"
                },
                "references": {
                    "sentences": [
                        "For those using End Of Development Support (EODS) devices affected by the CVE-2021-3972, without any fixes available: one thing that can help you protect against unwanted modification of the UEFI Secure Boot state is using a TPM-aware full-disk encryption solution capable of making disk data inaccessible if the UEFI Secure Boot configuration changes."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x48220193>",
                    "type": "UnknownWord",
                    "value": "tpm-aware"
                },
                "references": {
                    "sentences": [
                        "For those using End Of Development Support (EODS) devices affected by the CVE-2021-3972, without any fixes available: one thing that can help you protect against unwanted modification of the UEFI Secure Boot state is using a TPM-aware full-disk encryption solution capable of making disk data inaccessible if the UEFI Secure Boot configuration changes."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa717558c>",
                    "type": "UnknownWord",
                    "value": "full-disk"
                },
                "references": {
                    "sentences": [
                        "For those using End Of Development Support (EODS) devices affected by the CVE-2021-3972, without any fixes available: one thing that can help you protect against unwanted modification of the UEFI Secure Boot state is using a TPM-aware full-disk encryption solution capable of making disk data inaccessible if the UEFI Secure Boot configuration changes."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb23b5ef2>",
                    "type": "UnknownWord",
                    "value": "martin"
                },
                "references": {
                    "sentences": [
                        "Martin Smolr"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x805ba6fc>",
                    "type": "UnknownWord",
                    "value": "smolr"
                },
                "references": {
                    "sentences": [
                        "Martin Smolr"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x789d7c76>",
                    "type": "UnknownWord",
                    "value": "30am"
                },
                "references": {
                    "sentences": [
                        "19 Apr 2022 - 11:30AM"
                    ],
                    "titles": []
                }
            }
        ]
    },
    "other_links": [],
    "info": {
        "potential_threats": {
            "<UNKNOWNWORD_0x63dc41ff>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x63dc41ff>",
                    "type": "UnknownWord",
                    "value": "lenovo"
                },
                "references": {
                    "sentences": [
                        "Its used by the platform firmware to store various information, including the Lenovo product name, motherboard model name and version, OEM OS license, or as mentioned in the section above, in some cases it can be used to activate the ChgBootDxeHook driver in order to disable UEFI Secure Boot feature.",
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register.",
                        "Regarding the vulnerabilities described in this blogpost, we strongly advise all owners of Lenovo laptops to go through the list of affected devices and update their firmware, ideally by following the manufacturers instructions.",
                        "We reported all discovered vulnerabilities to Lenovo on October 11th, 2021. Altogether, the list of affected devices contains more than one hundred different consumer laptop models with millions of users worldwide, from affordable models like Ideapad-3 to more advanced ones like Legion 5 Pro-16ACH6 H or Yoga Slim 9-14ITL05. The full list of affected models with active development support is published in the Lenovo Advisory.",
                        "The firmware on certain Lenovo consumer laptop models implements a special LenovoVariable persistent storage, allowing data storage of up to 4KB in SPI flash.",
                        "In our analysis, we will work with the firmware image (version 1GCN25WW) of the Lenovo 110-15IBR, which is one of the devices affected by the CVE-2021-3971 vulnerability.",
                        "Read Read data from a Lenovo variable<crlf>Write Write data into a Lenovo variable<crlf>Lock Lock a Lenovo variable for write<crlf>Unlock Unlock a Lenovo variable for write",
                        "In the firmware we analyzed, the SMM version of the Lenovo variables functionality is provided to other drivers by the protocol BFD02359-8DFE-459A-8B69-A73A6BAFADC0 (lets name it LENOVO_VARIABLE_PROTOCOL_GUID) and it is installed by the LenovoVariableSmm SMM module.",
                        "In addition to the models listed in the advisory, several other devices we reported to Lenovo are also affected, but wont be fixed due to them reaching End Of Development Support (EODS). This includes devices where we spotted reported vulnerabilities for the first time: Ideapad 330-15IGM and Ideapad 110-15IGR. The list of such EODS devices that we have been able to identify will be available in ESETs vulnerability disclosures repository.",
                        "2021-10-11: Vulnerabilities reported to Lenovo<crlf>2021-10-12: Lenovo responded and confirmed it was investigating the issues<crlf>2021-11-17: Lenovo confirmed the vulnerabilities and informed us of the planned advisory publication date February 8th, 2022<crlf>2022-01-20: Lenovo asked to postpone public disclosure to the new date April 18th due to encountering development issues<crlf>2022-04-18: Lenovo security advisory published<crlf>2022-04-19: ESET Research blogpost published",
                        "ESET researchers have discovered and analyzed three vulnerabilities affecting various Lenovo consumer laptop models. The first two of these vulnerabilities CVE-2021-3971, CVE-2021-3972 affect UEFI firmware drivers originally meant to be used only during the manufacturing process of Lenovo consumer notebooks. Unfortunately, they were mistakenly included also in the production BIOS images without being properly deactivated. These affected firmware drivers can be activated by attacker to directly disable SPI flash protections (BIOS Control Register bits and Protected Range registers) or the UEFI Secure Boot feature from a privileged user-mode process during OS runtime. It means that exploitation of these vulnerabilities would allow attackers to deploy and successfully execute SPI flash or ESP implants, like LoJax or our latest UEFI malware discovery ESPecter, on the affected devices.",
                        "However, on some affected models (for instance on the Lenovo V14-IIL), its not that simple and just creating a ChgBootSecureBootDisable UEFI variable wont disable UEFI Secure Boot. So, whats the catch?",
                        "Find the SMRAM physical address.<crlf>Copy the LENV_HDR header to the physical address 32 bytes before the SMRAM the header should contain a variable identifier (it can be a random GUID) and the length of the data one would like to read from SMRAM (the maximum is something below 4KB).<crlf>Invoke SW SMI registered by the LenovoVariableSmm (SwSmiNumber 0x80), specifying the command with ID 0x02 in the BX register (meaning that you want to write into the Lenovo variable) and the address of previously created header in the ECX and EDI registers (to tell the SW SMI handler what you want to write into that variable).<crlf>Now, that variable contains a specified amount of SMRAM data so we only need to read it. We allocate a new buffer (equal to the size of the header plus the size of data to retrieve) and copy the same header into it, as used in step 2.<crlf>Invoke the SW SMI handler again, specifying the command with ID 0x01 in BX register (meaning that you want to read from the Lenovo variable) and the address of our newly allocated buffer from step 4 in the ECX and EDI registers (to tell the SW SMI handler where we want to copy the content of the Lenovo variable which at this moment contains data from the SMRAM).",
                        "As an example, to disable UEFI Secure Boot on Lenovo 330-15IGM, the user need only create a UEFI variable with:",
                        "Lenovo confirmed the vulnerabilities on November 17th, 2021, and assigned them the following CVEs:",
                        "This physical address passed as an argument to the SMI handler should contain data identifying the Lenovo variable to be read or written; the structure of this buffer is shown in Figure 16.",
                        "In our analysis, we will work with the firmware image (version 7XCN41WW) of the Lenovo 330-15IGM, which is affected by the CVE-2021-3972 vulnerability.",
                        "In this analysis, we will work with the firmware image (version 7XCN41WW) of the Lenovo 330-15IGM, which is affected by the CVE-2021-3970 vulnerability.",
                        "The buffer starts with the 0x20-byte header (LENV_HDR), containing the unique GUID that identifies the Lenovo variable and a 32-bit value specifying the length of the data to be retrieved from the variable or written to it. The memory space located immediately after the header is used as a source or destination location for LENOVO_VARIABLE_PROTOCOLs Read and Write functions.",
                        "To understand how we were able to find these vulnerabilities, consider the firmware drivers affected by CVE2021-3971. These drivers immediately caught our attention by their very unfortunate (but surprisingly honest) names: SecureBackDoor and SecureBackDoorPeim. After some initial analysis, we discovered other Lenovo drivers sharing a few common characteristics with the SecureBackDoor* drivers: ChgBootDxeHook and ChgBootSmm. As it turned out, their functionality was even more interesting and could be abused to disable UEFI Secure Boot (CVE-2021-3972).",
                        "ESET researchers discover multiple vulnerabilities in various Lenovo laptop models that allow an attacker with admin privileges to expose the user to firmware-level malware",
                        "We start with our analysis of the Lenovo drivers affected by CVE-2021-3971 and CVE-2021-3972, and then continue with the SMM vulnerability CVE-2021-3970.",
                        "To be able to write into SMRAM, the principle is almost the same first, the attackers need to write their own data into the Lenovo variable, and then read the data from the variable directly to the SMRAM."
                    ],
                    "titles": [
                        "When secure isnt secure at all: Highimpact UEFI vulnerabilities discovered in Lenovo consumer laptops",
                        "Lenovo variable storage and a vulnerable SW SMI handler"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x78cb3a4e>",
                            "type": "File",
                            "value": "chipsec.hal.interrupts"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x63dc41ff>",
                            "type": "UnknownWord",
                            "value": "lenovo"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x86c9cc4b>",
                            "type": "File",
                            "value": "cs.init"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x63dc41ff>",
                            "type": "UnknownWord",
                            "value": "lenovo"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x44f247c8>",
                            "type": "File",
                            "value": "binascii.unhexlify"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x63dc41ff>",
                            "type": "UnknownWord",
                            "value": "lenovo"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x31ee2c05>",
                            "type": "File",
                            "value": "chipsec.chipsetfrom"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x63dc41ff>",
                            "type": "UnknownWord",
                            "value": "lenovo"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf6b778c2>",
                            "type": "File",
                            "value": "chipsec.chipset.cs"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x63dc41ff>",
                            "type": "UnknownWord",
                            "value": "lenovo"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x32ed10af>",
                            "type": "File",
                            "value": "struct.pack"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x63dc41ff>",
                            "type": "UnknownWord",
                            "value": "lenovo"
                        }
                    }
                ]
            },
            "<UNKNOWNWORD_0x2becac96>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x2becac96>",
                    "type": "UnknownWord",
                    "value": "spi"
                },
                "references": {
                    "sentences": [
                        "Each register specifies independent read/write permissions for a specific range of SPI Flash BIOS region memory. They can be set only if the Flash Configuration Lock-Down (FLOCKDN) bit in Hardware Sequencing Flash Status (HSFS) register is not set.",
                        "We will start with the analysis of the CVE-2021-3971 vulnerability, which allows an attacker to disable SPI flash write-protections mechanisms by simply creating the NVRAM variable. When platform firmware detects this NVRAM variable during bootup, it skips execution of the code responsible for the setting up BIOS Control Register and Protected Range register-based SPI flash protections.",
                        "Performing MMIO read operation (line 15 in Figure 6) by reading a 32-bit value from the address 0xE00F8054. If we pass this address as an argument to the Python function pci_decode_from_addr, which we introduced in the Figure 3: that function will print the address, decoded as Bus: 0, Device: 0x1F, Function: 0, Offset: 0x54. Based on these values and knowing that the affected laptop (in our case Lenovo 110-15IBR) uses the N-series Intel System-on-a-Chip (SoC), we can find in its datasheet (section 33.14.13, page 2258) that its accessing the SPI Base address (SBASE), 32-bit PCI configuration register containing the address of the SPI configuration space (we will call it SPIBAR), and saves it into the global variable.<crlf>Registering the SW SMI handler function DispatchFunction (line 22 in Figure 6) This registered SW SMI handler DispatchFunction is invoked during platform initialization and if we look into the code of this function in Figure 7 below, we see that its responsible for setting bit 5 inside the register located at SPIBAR offset 0xFC. If we look into the documentation (section 10.48 BCR), we can see that this corresponds to SMM_BWP (or EISS for our chipset) bit of the BIOS Control Register.",
                        "As shown in Figure 8, if it finds out that the BiosLock bit is not set, it will simply skip code responsible for setting these registers and thus leave SPI flash unprotected.",
                        "To disable or deactivate the above-mentioned SPI flash protections by exploiting this vulnerability, the user only needs to create an NVRAM variable with:",
                        "To understand how it actually disables SPI flash protections, we need to look into two different firmware drivers:",
                        "The BIOS Control Register, Protection Range registers, and many other configuration registers can be read or written by accessing the PCI(e) configuration space. The location (or address) of the PCI(e) configuration space for the specific PCI-compatible devices (e.g., SPI flash) is specified by the three values:",
                        "This Disable SPI flash protections feature is implemented by the following drivers in the firmware of affected laptops:",
                        "The firmware on certain Lenovo consumer laptop models implements a special LenovoVariable persistent storage, allowing data storage of up to 4KB in SPI flash.",
                        "In addition, while investigating above mentioned vulnerable drivers, we discovered the third vulnerability: SMM memory corruption inside the SW SMI handler function (CVE-2021-3970). This vulnerability allows arbitrary read/write from/into SMRAM, which can lead to the execution of malicious code with SMM privileges and potentially lead to the deployment of an SPI flash implant.",
                        "As a result, the exploited system will allow modification of the SPI flash even when done from non-SMM code and thus allow an attacker to deploy malicious code directly to the firmware storage.",
                        "In this register, three specific bits are used for SPI flash access control. Note that although they may be named differently on other chipsets, the principle is the same.",
                        "UEFI Secure Boot is defined in the UEFI specification, and its main purpose is to verify the integrity of the boot components to ensure that only components trusted by the platform are allowed to be executed. What components will be included in this verification process depends on the UEFI Secure Boot policy implementation in the specific platform in most cases, only third-party UEFI drivers, applications and OPROMs are being verified, and the drivers on the SPI flash are implicitly considered trusted.",
                        "Modern systems nowadays usually come with solutions providing hardware-based boot integrity (such as Intel Boot Guard) which, if configured properly and without additional vulnerabilities, protects from booting untrusted firmware code even if the above-mentioned chipset-provided protections fail to protect the SPI flash due to misconfiguration or vulnerability.",
                        "Before we start with the analysis of the reported vulnerabilities, we would like to provide an introduction to the basic theory of UEFI protocols, System Management Mode, UEFI NVRAM variables, UEFI Secure Boot, and basic SPI flash write protection.",
                        "ESET researchers have discovered and analyzed three vulnerabilities affecting various Lenovo consumer laptop models. The first two of these vulnerabilities CVE-2021-3971, CVE-2021-3972 affect UEFI firmware drivers originally meant to be used only during the manufacturing process of Lenovo consumer notebooks. Unfortunately, they were mistakenly included also in the production BIOS images without being properly deactivated. These affected firmware drivers can be activated by attacker to directly disable SPI flash protections (BIOS Control Register bits and Protected Range registers) or the UEFI Secure Boot feature from a privileged user-mode process during OS runtime. It means that exploitation of these vulnerabilities would allow attackers to deploy and successfully execute SPI flash or ESP implants, like LoJax or our latest UEFI malware discovery ESPecter, on the affected devices.",
                        "Several security mechanisms are available for the prevention of unwanted modifications of the SPI flash and the primary line of defense is provided by the special memory-mapped configuration registers exposed by the chipset itself the BIOS Control Register and five Protected Range registers.",
                        "UEFI firmware usually resides in the embedded flash memory chip located on the computers motherboard (SPI flash chip). Its non-volatile memory and it is connected to the processor via the Serial Peripheral Interface (SPI).",
                        "We have provided an example of how to read only the first 0x100 bytes of the SMRAM; however, with additional modifications, its possible to read/write the whole SMRAM range. This could allow threat actors to execute their own malicious code in SMM or even worse considering the LenovoVariable SW SMI handlers ability to modify the SPI flash write the attackers own malicious firmware implant directly to the SPI flash.",
                        "CVE-2021-3970 LenovoVariableSmm SMM arbitrary read/write<crlf>CVE-2021-3971 SecureBackDoor disable SPI flash protections<crlf>CVE-2021-3972 ChgBootDxeHook disable UEFI Secure Boot",
                        "As a result, skipping this code will result in misconfiguration of the BIOS Control Registers, exposing the system to the risk of SPI flash modification.",
                        "Figure 6. Hex-Rays-decompiled code from PchBiosWriteProtect responsible for initialization of BIOS Control Register related SPI flash protections",
                        "SecureBackDoor is a DXE driver responsible for deactivating SPI flash protections if it finds a HOB identified by SECURE_BACKDOOR_HOB_GUID in the HOB list. In Figure 5 we can see that to find this HOB, it walks through the list of HOBs, and looks for the one created previously by the SecureBackDoorPeim module by matching it with the SECURE_BACKDOOR_HOB_GUID.",
                        "The second driver, BiosRegionLock, is responsible for setting up Protected Range registers PR0-PR4. Similar to the PchBiosWriteProtect described above, it uses the BiosLock bit inside DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig (type PCH_LOCK_DOWN_CONFIG) to decide whether or not to set SPI flash protections in this case Protected Range registers."
                    ],
                    "titles": [
                        "CVE-2021-3971 SecureBackDoor driver disable SPI flash protections",
                        "Primary SPI flash protection mechanisms"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xdcca3434>",
                            "type": "File",
                            "value": "dxe_pch_platform_policy_protocol.lockdownconfig"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2becac96>",
                            "type": "UnknownWord",
                            "value": "spi"
                        }
                    }
                ]
            },
            "<UNKNOWNWORD_0xd07192c5>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xd07192c5>",
                    "type": "UnknownWord",
                    "value": "smm"
                },
                "references": {
                    "sentences": [
                        "ChgBootSmm is an SMM module responsible for registration of the SW SMI handler function. As shown in Figure 9, it registers this SMI handler using the EFI_SMM_SW_DISPATCH2_PROTOCOL.Register function and sets the SwSmiInputValue to 0xCA. This means that one can trigger execution of this function by writing the value 0xCA to I/O port 0xB2.",
                        "As written in the specification, this protocol can be used by SMM modules to install handler functions that will respond to specific software interrupts.",
                        "SMM code is written within the context of the system firmware and is usually used for various tasks including advanced power management, execution of OEM proprietary code, and secure firmware updates. It provides an independent execution environment completely invisible to the running operating system, and the code and data used in SMM are stored in hardware-protected memory accessible only from SMM called SMRAM.",
                        "SMM is a highly privileged execution mode of x86 processors, often referred to as ring 2.",
                        "Only in the last year, we have seen numerous high-impact UEFI firmware vulnerabilities being publicly disclosed. Most notable are those by the researchers from Binarly, in their An In-Depth Look At The 23 High-Impact Vulnerabilities and 16 High Impact Vulnerabilities Discovered In HP Devices blogposts, and by researchers from SentinelOne in their Another Brick in the Wall: Uncovering SMM Vulnerabilities in HP Firmware blogpost.",
                        "PchBiosWriteProtect is a SMM module. In Figure 6 we can see that it checks whether the BiosLock bit inside DXE_PCH_PLATFORM_POLICY_PROTOCOL.LockDownConfig (type PCH_LOCK_DOWN_CONFIG) is set, by performing a bitwise AND operation with value 0x08 (which is 0b1000 in binary representation).",
                        "It is important to note that LenovoVariableSmm not only installs this protocol to be accessible by other SMM modules, but it also registers the SW SMI handler function that allows accessing this storage from the OS by invoking SW SMI. The worst part is that it doesnt properly validate parameters passed to the SW SMI handler, which can result in arbitrary read/write from/to the SMRAM.",
                        "In addition, while investigating above mentioned vulnerable drivers, we discovered the third vulnerability: SMM memory corruption inside the SW SMI handler function (CVE-2021-3970). This vulnerability allows arbitrary read/write from/into SMRAM, which can lead to the execution of malicious code with SMM privileges and potentially lead to the deployment of an SPI flash implant.",
                        "And how does this function from LENOVO_SECURE_BOOT_SERVICES_PROTOCOL disable UEFI Secure Boot? It does so by invoking the SW SMI handler 0xEC registered by VariableRuntimeDxe combined SMM/DXE driver, which in turn sets the authenticated UEFI variable named SecureBootEnforce (namespace EFI_GENERIC_VARIABLE_GUID) to 0x00.",
                        "To enter SMM, a special processor interrupt called SMI (System Management Interrupt) needs to be triggered. SMIs can be triggered via software means or by the platform hardware. For the purposes of this blogpost, its sufficient to understand that one of the ways to generate an SMI (specifically a software SMI SW SMI) and enter SMM on Intel architecture systems is to write to I/O port 0xB2 (using the OUT instruction). This is often used by software to invoke firmware services during system runtime.",
                        "In this last section, we are going to look at the analysis of the CVE-2021-3970 vulnerability caused by an improper input validation in the SW SMI handler function, which can lead to the arbitrary read/write from/to the SMRAM and subsequent arbitrary code execution in SMM execution mode.",
                        "In the firmware we analyzed, the SMM version of the Lenovo variables functionality is provided to other drivers by the protocol BFD02359-8DFE-459A-8B69-A73A6BAFADC0 (lets name it LENOVO_VARIABLE_PROTOCOL_GUID) and it is installed by the LenovoVariableSmm SMM module.",
                        "For models including this check, higher privileges are required to disable secure boot from the OS, but its still possible by invoking the SW SMI handler registered by the LenovoVariableSmm SMM module.",
                        "We have provided an example of how to read only the first 0x100 bytes of the SMRAM; however, with additional modifications, its possible to read/write the whole SMRAM range. This could allow threat actors to execute their own malicious code in SMM or even worse considering the LenovoVariable SW SMI handlers ability to modify the SPI flash write the attackers own malicious firmware implant directly to the SPI flash.",
                        "When set, the BIOS region is not writable unless all processors are in SMM and BIOSWE is 1. Setting this bit resolves the Speed Racer race condition vulnerability (an exploit for this vulnerability was present in the ReWriter_binary tool, which was used by the Sednit group to deploy LoJax).",
                        "CVE-2021-3970 LenovoVariableSmm SMM arbitrary read/write<crlf>CVE-2021-3971 SecureBackDoor disable SPI flash protections<crlf>CVE-2021-3972 ChgBootDxeHook disable UEFI Secure Boot",
                        "When set, BIOSWE could be set from 0 to 1 only by SMM code. Any attempt to set BIOSWE from non-SMM code will trigger SMI. This provides an opportunity for the OEM to implement an SMI handler to protect the BIOSWE bit by setting it back to 0.",
                        "This FLOCKDN bit should be set by the platform firmware during platform initialization right after setting the Protected Range (PR) registers. Once FLOCKDN is set, it is cleared only after the next hardware reset. It means that memory ranges protected by Protected Range registers cant be modified by any runtime code (including SMM code) after they are locked. Even legitimate firmware updates must be performed before PR registers are locked.",
                        "We start with our analysis of the Lenovo drivers affected by CVE-2021-3971 and CVE-2021-3972, and then continue with the SMM vulnerability CVE-2021-3970."
                    ],
                    "titles": [
                        "CVE-2021-3970 Arbitrary SMM read/write",
                        "System Management Mode (SMM)"
                    ]
                }
            }
        },
        "sigma": false,
        "yara": false
    },
    "keywords": {
        "classified": [],
        "dubbed": [],
        "associated": [],
        "targets": [
            "All of the above-mentioned ChgBoot* UEFI variables can be created even without the help of this SW SMI handler for example using Windows APIs because they are not protected against runtime access",
            "For those using End Of Development Support (EODS) devices affected by the CVE-2021-3972, without any fixes available: one thing that can help you protect against unwanted modification of the UEFI Secure Boot state is using a TPM-aware full-disk encryption solution capable of making disk data inaccessible if the UEFI Secure Boot configuration changes."
        ],
        "attributed": [
            "When creating a UEFI variable, attributes are used to indicate how the variable should be stored and maintained by the system this way one can make variables persistent (surviving power cycles), temporary, or even authenticated",
            "Examples of some of these attributes follow; here we list only the most important ones:",
            "VARIABLE_ATTRIBUTE_NON_VOLATILE (NV)(0x00000001) Variables using this attribute persist across the power cycles and are stored in fixed hardware storage (NVRAM) with limited capacity (typically around 64MB)",
            "VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS (BS)(0x00000002) If the BS attribute is set, variables without the RT attribute set will not be visible to the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices",
            "VARIABLE_ATTRIBUTE_RUNTIME_ACCESS (RT)0x00000004) To access a variable via the GetVariable function after the execution of EFI_BOOT_SERVICES.ExitBootServices, the RT attribute must be set",
            "VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS (AW)(0x00000010)<crlf>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS (AWT)(0x00000020)",
            "A full list of attributes and their usage rules can be found in the UEFI specification.",
            "Name: cE!<crlf>Namespace GUID: LENOVO_BACKDOOR_NAMESPACE_GUID<crlf>Attributes: NV + BS + RT (0x00000007)<crlf>Value: Any non-null byte",
            "Name: ChgBootSecureBootDisable or ChgBootChangeLegacy<crlf>Namespace GUID: LENOVO_BACKDOOR_NAMESPACE_GUID<crlf>Attributes: NV + BS + RT (0x00000007)<crlf>Value: Any non-null byte",
            "Moreover, each written variable has the same attributes bitmask 0x00000007 (NV|BS|RT) meaning that all of the variables created will be stored in non-volatile storage and thus survive a power cycle."
        ]
    },
    "resources": {
        "links": {
            "github": [
                "https://github.com/eset/vulnerability-disclosures/",
                "https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Library/PciLib.h#L34",
                "https://github.com/tianocore/edk2-platforms/blob/master/Silicon/Intel/Vlv2DeviceRefCodePkg/ValleyView2Soc/SouthCluster/Include/Protocol/PchPlatformPolicy.h",
                "https://github.com/tianocore/edk2-platforms/blob/60d6b7c751bbad5ccc15d276a170d6dd638bd88e/Silicon/Intel/Vlv2DeviceRefCodePkg/ValleyView2Soc/SouthCluster/Include/Protocol/PchPlatformPolicy.h#L453",
                "https://github.com/tianocore/edk2-platforms/blob/60d6b7c751bbad5ccc15d276a170d6dd638bd88e/Silicon/Intel/Vlv2DeviceRefCodePkg/ValleyView2Soc/SouthCluster/Include/Protocol/PchPlatformPolicy.h#L453",
                "https://github.com/chipsec/chipsec"
            ],
            "pastebin": [],
            "text_files": [],
            "other": [
                "https://www.welivesecurity.com/author/msmolar/",
                "https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.welivesecurity.com%2F2022%2F04%2F19%2Fwhen-secure-isnt-secure-uefi-vulnerabilities-lenovo-consumer-laptops%2F",
                "https://twitter.com/intent/tweet?&url=https%3A%2F%2Fwww.welivesecurity.com%2F2022%2F04%2F19%2Fwhen-secure-isnt-secure-uefi-vulnerabilities-lenovo-consumer-laptops%2F&text=When%20%E2%80%9Csecure%E2%80%9D%20isn%E2%80%99t%20secure%20at%20all:%20High%E2%80%91impact%20UEFI%20vulnerabilities%20discovered%20in%20Lenovo%20consumer%20laptops%0A&via=welivesecurity",
                "https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fwww.welivesecurity.com%2F2022%2F04%2F19%2Fwhen-secure-isnt-secure-uefi-vulnerabilities-lenovo-consumer-laptops%2F",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-3971",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-3972",
                "https://www.welivesecurity.com/wp-content/uploads/2018/09/ESET-LoJax.pdf",
                "https://www.welivesecurity.com/2021/10/05/uefi-threats-moving-esp-introducing-especter-bootkit/",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-3971",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-3972",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-3970",
                "https://support.lenovo.com/us/en/product_security/LEN-73440",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-3970",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-3971",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-3972",
                "https://www.sentinelone.com/labs/moving-from-common-sense-knowledge-about-uefi-to-actually-dumping-uefi-firmware/",
                "https://uefi.org/specifications",
                "https://uefi.org/sites/default/files/resources/UEFI_Spec_2_9_2021_03_18.pdf",
                "https://docs.microsoft.com/en-us/windows/desktop/SecAuthZ/privilege-constants",
                "https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setfirmwareenvironmentvariablea",
                "https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getfirmwareenvironmentvariablea",
                "https://www.felixcloutier.com/x86/out",
                "http://www.uefi.org/sites/default/files/resources/PI_1_4.zip",
                "https://en.wikipedia.org/wiki/Serial_Peripheral_Interface",
                "https://www.welivesecurity.com/wp-content/uploads/2018/09/ESET-LoJax.pdf",
                "https://securelist.com/mosaicregressor/98849/",
                "https://securelist.com/moonbounce-the-dark-side-of-uefi-firmware/105468/",
                "https://bromiumlabs.files.wordpress.com/2015/01/speed_racer_whitepaper.pdf",
                "https://www.welivesecurity.com/wp-content/uploads/2018/09/ESET-LoJax.pdf",
                "https://c9x.me/x86/html/file_module_x86_id_139.html",
                "https://c9x.me/x86/html/file_module_x86_id_222.html",
                "https://wiki.osdev.org/PCI_Express",
                "https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/uefi-validation-option-rom-validation-guidance",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-3971",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-3972",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-3970",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-3971",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-3971",
                "https://docs.microsoft.com/en-us/windows/desktop/SecAuthZ/privilege-constants",
                "https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setfirmwareenvironmentvariableexa",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-3971",
                "https://web.archive.org/web/20170507185355/http:/www.intel.com/content/dam/www/public/us/en/documents/datasheets/pentium-celeron-n-series-datasheet-vol-3-2015.pdf",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-3972",
                "https://eclypsium.com/2020/07/29/theres-a-hole-in-the-boot/",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-3972",
                "https://docs.microsoft.com/en-us/windows/desktop/SecAuthZ/privilege-constants",
                "https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setfirmwareenvironmentvariableexa",
                "https://uefi.org/revocationlistfile",
                "https://eclypsium.com/2020/07/29/theres-a-hole-in-the-boot/",
                "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-3970",
                "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-3970",
                "https://www.welivesecurity.com/wp-content/uploads/2018/09/ESET-LoJax.pdf",
                "https://securelist.com/mosaicregressor/98849/",
                "https://securelist.com/moonbounce-the-dark-side-of-uefi-firmware/105468/",
                "https://www.welivesecurity.com/2021/10/05/uefi-threats-moving-esp-introducing-especter-bootkit/",
                "https://securelist.com/finspy-unseen-findings/104322/",
                "https://bromiumlabs.files.wordpress.com/2015/01/speed_racer_whitepaper.pdf",
                "https://www.binarly.io/",
                "https://www.binarly.io/posts/An_In_Depth_Look_at_the_23_High_Impact_Vulnerabilities/index.html",
                "https://www.binarly.io/posts/Repeatable_Firmware_Security_Failures_16_High_Impact_Vulnerabilities_Discovered_in_HP_Devices",
                "https://www.sentinelone.com/",
                "https://www.sentinelone.com/labs/another-brick-in-the-wall-uncovering-smm-vulnerabilities-in-hp-firmware/",
                "https://support.lenovo.com/us/en/product_security/LEN-73440",
                "https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-3972",
                "https://www.eset.com/int/business/services/threat-intelligence/?utm_source=welivesecurity.com&utm_medium=referral&utm_campaign=wls-research&utm_content=when-secure-isnt-secure-uefi-vulnerabilities-lenovo-consumer-laptops",
                "https://www.welivesecurity.com/author/msmolar/"
            ]
        },
        "images": [
            "https://www.welivesecurity.com/wp-content/uploads/2020/05/martin.smolar-1-222x179.jpg",
            "https://www.welivesecurity.com/wp-content/uploads/2022/04/Figure-1.-EFI_SMM_SW_DISPATCH2_PROTOCOL-definition.jpg",
            "https://www.welivesecurity.com/wp-content/uploads/2022/04/Figure-2.-EFI_SMM_SW_DISPATCH2_PROTOCOL.Register-function-definition-300x85.png",
            "https://www.welivesecurity.com/wp-content/uploads/2022/04/Figure-4.-Hex-Rays-decompiled-code-of-SecureBackDoorPeim-module-300x135.png",
            "https://www.welivesecurity.com/wp-content/uploads/2022/04/Figure-5.-Hex-Rays-decompiled-SecureBackDoor-code-responsible-for-finding-HOB-created-by-SecureBackdoorPeim.png",
            "https://www.welivesecurity.com/wp-content/uploads/2022/04/Figure-6.-Hex-Rays-decompiled-code-from-PchBiosWriteProtect-responsible-for-initialization-of-BIOS-Control-Register-related-SPI-flash-protections.png",
            "https://www.welivesecurity.com/wp-content/uploads/2022/04/Figure-7.-Hex-Rays-decompiled-code-of-DispatchFunction-from-PchBiosWriteProtect.png",
            "https://www.welivesecurity.com/wp-content/uploads/2022/04/Figure-8.-Hex-Rays-decompiled-code-responsible-for-setting-the-Protected-Range-registers.png",
            "https://www.welivesecurity.com/wp-content/uploads/2022/04/Figure-9.-Hex-Rays-decompiled-code-%E2%80%93-ChgBootSmm-registers-SW-SMI-handler-number-0xCA.png",
            "https://www.welivesecurity.com/wp-content/uploads/2022/04/Figure-10.-Hex-Rays-decompiled-code-of-SW-SMI-handler-installed-by-the-ChgBootSmm-driver.png",
            "https://www.welivesecurity.com/wp-content/uploads/2022/04/Figure-11.-Hex-Rays-decompiled-function-from-ChgBootDxeHook-checking-ChgBoot-variables..png",
            "https://www.welivesecurity.com/wp-content/uploads/2022/04/Figure-12.-Hex-Rays-decompiled-function-from-ChgBootDxeHook-checking-the-existence-of-ChgBootSecureBootDisable-NVRAM-variable.png",
            "https://www.welivesecurity.com/wp-content/uploads/2022/04/Figure-13.-Hex-Rays-decompiled-code-from-ChgBootDxeHook-responsible-for-disabling-UEFI-Secure-Boot.png",
            "https://www.welivesecurity.com/wp-content/uploads/2022/04/Figure-14.-Hex-Rays-decompiled-code-%E2%80%93-Disable-UEFI-Secure-Boot-with-additional-LenovoVariable-check.png",
            "https://www.welivesecurity.com/wp-content/uploads/2022/04/Figure-15.-Hex-Rays-decompiled-code-of-SW-SMI-handler-function-registered-by-the-LenovoVariableSmm-module.png",
            "https://www.welivesecurity.com/wp-content/uploads/2022/04/Figure-16.-Structure-of-the-buffer-passed-to-the-LenovoVariableSmm-SW-SMI-handler-300x144.png",
            "https://www.welivesecurity.com/wp-content/uploads/2022/04/Figure-18.-CHIPSEC-script-output-dumping-the-first-0x100-bytes-of-SMRAM.png",
            "https://www.welivesecurity.com/wp-content/uploads/2021/07/bandook-bandidos-eti-cta.png"
        ]
    }
}