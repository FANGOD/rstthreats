{
    "title": "BAZARLOADER: Unpacking an ISO File Infection. Step 1: Mounting ISO File & Extracting Stage 1 Executable",
    "url": "https://www.0ffset.net/reverse-engineering/bazarloader-iso-file-infection/?utm_source=rss&utm_medium=rss&utm_campaign=bazarloader-iso-file-infection",
    "threats": {
        "Threat": [
            {
                "token": {
                    "id": "<THREAT_0xf4f1f185>",
                    "type": "Threat",
                    "value": "bazarbackdoor"
                },
                "references": {
                    "sentences": [
                        "In this initial post, we will unpack the different stages of a BAZARLOADER infection that comes in the form of an optical disk image (ISO) file. We will also dive into the obfuscation methods used by the main BAZARLOADER payload.",
                        "BAZARLOADER obfuscates most of its API calls through a few structures that it constructs in the DllEntryPoint function.",
                        "To begin populating each LIBRARY_STRUCT structure, BAZARLOADER decodes the library name from a stack string and populates it with the corresponding set of functions and the library handle retrieved from calling LoadLibraryA.",
                        "Next, for each library to be imported, BAZARLOADER populates the following LIBRARY_STRUCT structure that contains a set of functions to interact with the library and the library handle.",
                        "Finally, we can dump this memory region into a file to extract the BAZARLOADER payload.",
                        "At this point, we have fully unpacked BAZARLOADER and understood how the malware obfuscates its strings and APIs to make analysis harder.",
                        "Recent BAZARLOADER samples arrive in emails containing OneDrive links to download an ISO file to avoid detection since most AVs tend to ignore this particular file type. With Windows 7 and above integrating the mounting functionality into Windows Explorer, we can mount any ISO file as a virtual drive by double-clicking on it.",
                        "BAZARLOADER (aka BAZARBACKDOOR) is a Windows-based loader that spreads through attachments in phishing emails. During an infection, the final loader payload typically downloads and executes a Cobalt Strike beacon to provide remote access for the threat actors, which, in a lot of cases, leads to ransomware being deployed to the victims machine.",
                        "As we begin performing static analysis on BAZARLOADER, it is crucial that we identify obfuscation methods that the malware uses.",
                        "Using the structures GetProcAddress API field, BAZARLOADER retrieves the rest of the required APIs to populate other fields in the structure. This API_IMPORT_STRUCT structure will later be used to import other libraries APIs."
                    ],
                    "titles": [
                        "Step 4: BAZARLOADERs String Obfuscation",
                        "BAZARLOADER: Unpacking an ISO File Infection. Step 1: Mounting ISO File & Extracting Stage 1 Executable",
                        "Step 1: Mounting ISO File & Extracting Stage 1 Executable",
                        "Step 3: Extracting The Final BAZARLOADER Payload",
                        "BAZARLOADER: Unpacking an ISO File Infection",
                        "Step 5: BAZARLOADERs API Obfuscation"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x321ae5d>",
                            "type": "File",
                            "value": "attachments.lnk"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xf4622dc5>",
                            "type": "File",
                            "value": "rundll32.exe"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x2705e00c>",
                            "type": "File",
                            "value": "documents.log"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x2ff279a6>",
                            "type": "Category",
                            "value": "phishing"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xa179f90c>",
                            "type": "Category",
                            "value": "ransomware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0xff6ba3c2>",
                            "type": "Threat",
                            "value": "cobalt_strike"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x78473138>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "0900b4eb02bdcaefd21df169d21794c8c70bfbc68b2f0612861fcabc82f28149"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x2f270c4>",
                            "type": "Threat",
                            "value": "metasploit_tool"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x5ed983fd>",
                            "type": "File",
                            "value": "kernel32.dll"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<THREAT_0x2f270c4>",
                    "type": "Threat",
                    "value": "metasploit_tool"
                },
                "references": {
                    "sentences": [
                        "When we examine the shellcode in IDA, we can quickly use the same trick with HashDB above to see that the shellcode also performs API hashing with Metasploits ROR13.",
                        "Instead, Ill just use OALabss HashDB IDA plugin to quickly reverse-lookup the hashing algorithm used from the hash. The result shows that the hash corresponds to an API name hashed with Metasploits hashing algorithm ROR13."
                    ],
                    "titles": [
                        "Step 2: Extracting Second Stage Shellcode",
                        "Step 3: Extracting The Final BAZARLOADER Payload"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<THREAT_0x2f270c4>",
                            "type": "Threat",
                            "value": "metasploit_tool"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x2f270c4>",
                            "type": "Threat",
                            "value": "metasploit_tool"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<THREAT_0xff6ba3c2>",
                    "type": "Threat",
                    "value": "cobalt_strike"
                },
                "references": {
                    "sentences": [
                        "In the next blog post, we will fully analyze how the loader downloads and launches a Cobalt Strike beacon from its C2 servers!",
                        "BAZARLOADER (aka BAZARBACKDOOR) is a Windows-based loader that spreads through attachments in phishing emails. During an infection, the final loader payload typically downloads and executes a Cobalt Strike beacon to provide remote access for the threat actors, which, in a lot of cases, leads to ransomware being deployed to the victims machine."
                    ],
                    "titles": [
                        "BAZARLOADER: Unpacking an ISO File Infection",
                        "Step 5: BAZARLOADERs API Obfuscation"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<THREAT_0xff6ba3c2>",
                            "type": "Threat",
                            "value": "cobalt_strike"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    }
                ]
            }
        ]
    },
    "ttps": {},
    "meanings": {
        "Category": [
            {
                "token": {
                    "id": "<CATEGORY_0xf1a480bb>",
                    "type": "Category",
                    "value": "malware"
                },
                "references": {
                    "sentences": [
                        "Below is the list of all libraries used by the malware.",
                        "When we mount the malicious ISO file, we see that a drive is mounted on the system that contains a shortcut file named Attachments.lnk and a hidden file named documents.log.",
                        "First, the malware populates the following structure that contains a handle to Kernel32.dll and addresses to API required to load libraries and get their API addresses.",
                        "One of those methods is string obfuscation, where the malware uses encoded stack strings to hide them from static analysis.",
                        "At this point, we have fully unpacked BAZARLOADER and understood how the malware obfuscates its strings and APIs to make analysis harder.",
                        "As we begin performing static analysis on BAZARLOADER, it is crucial that we identify obfuscation methods that the malware uses."
                    ],
                    "titles": [
                        "Step 4: BAZARLOADERs String Obfuscation",
                        "Step 1: Mounting ISO File & Extracting Stage 1 Executable",
                        "Step 5: BAZARLOADERs API Obfuscation"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x5ed983fd>",
                            "type": "File",
                            "value": "kernel32.dll"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x321ae5d>",
                            "type": "File",
                            "value": "attachments.lnk"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x2705e00c>",
                            "type": "File",
                            "value": "documents.log"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0xb68aa214>",
                    "type": "Category",
                    "value": "rat"
                },
                "references": {
                    "sentences": [
                        "When we examine the shellcode in IDA, we can quickly use the same trick with HashDB above to see that the shellcode also performs API hashing with Metasploits ROR13.",
                        "We can now dump this virtual memory buffer to retrieve the second stage shellcode for the next unpacking step.",
                        "With this in mind, our next step should be debugging the shellcode and setting breakpoints at these two API calls. We can pick up where we are after dumping in x64dbg during Step 2, or we can launch the shellcode directly in our debugger using OALabss BlobRunner or similar shellcode launcher.",
                        "At the entry point above, the shellcode resolves a set of functions that it will call, most notably VirtualAlloc and VirtualProtect. These two functions are typically used by packers to allocate virtual memory to decode and write the next stage executable in before launching it.",
                        "This tells us two things. First, our guess that the v19 variable will contain the address to executable code is correct. Second, we know that the executable code is shellcode since the data is mapped and executed directly at offset 0 from where it is written.",
                        "From here, we can set up x64dbg, execute the DLL file at the vspa export, and break at the call instruction. After stepping into the function, we will be at the head of the shellcode."
                    ],
                    "titles": [
                        "Step 2: Extracting Second Stage Shellcode",
                        "Step 3: Extracting The Final BAZARLOADER Payload"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<THREAT_0x2f270c4>",
                            "type": "Threat",
                            "value": "metasploit_tool"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0xc8ecca29>",
                    "type": "Category",
                    "value": "c2"
                },
                "references": {
                    "sentences": [
                        "In the next blog post, we will fully analyze how the loader downloads and launches a Cobalt Strike beacon from its C2 servers!"
                    ],
                    "titles": [
                        "Step 5: BAZARLOADERs API Obfuscation"
                    ]
                }
            },
            {
                "token": {
                    "id": "<CATEGORY_0x2ff279a6>",
                    "type": "Category",
                    "value": "phishing"
                },
                "references": {
                    "sentences": [
                        "BAZARLOADER (aka BAZARBACKDOOR) is a Windows-based loader that spreads through attachments in phishing emails. During an infection, the final loader payload typically downloads and executes a Cobalt Strike beacon to provide remote access for the threat actors, which, in a lot of cases, leads to ransomware being deployed to the victims machine."
                    ],
                    "titles": [
                        "BAZARLOADER: Unpacking an ISO File Infection"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0x2ff279a6>",
                            "type": "Category",
                            "value": "phishing"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0xa179f90c>",
                    "type": "Category",
                    "value": "ransomware"
                },
                "references": {
                    "sentences": [
                        "BAZARLOADER (aka BAZARBACKDOOR) is a Windows-based loader that spreads through attachments in phishing emails. During an infection, the final loader payload typically downloads and executes a Cobalt Strike beacon to provide remote access for the threat actors, which, in a lot of cases, leads to ransomware being deployed to the victims machine."
                    ],
                    "titles": [
                        "BAZARLOADER: Unpacking an ISO File Infection"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0xa179f90c>",
                            "type": "Category",
                            "value": "ransomware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    }
                ]
            }
        ]
    },
    "iocs": {
        "File": [
            {
                "token": {
                    "id": "<FILE_0x321ae5d>",
                    "type": "File",
                    "value": "attachments.lnk"
                },
                "references": {
                    "sentences": [
                        "When we mount the malicious ISO file, we see that a drive is mounted on the system that contains a shortcut file named Attachments.lnk and a hidden file named documents.log."
                    ],
                    "titles": [
                        "Step 1: Mounting ISO File & Extracting Stage 1 Executable"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x321ae5d>",
                            "type": "File",
                            "value": "attachments.lnk"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x321ae5d>",
                            "type": "File",
                            "value": "attachments.lnk"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0x2705e00c>",
                    "type": "File",
                    "value": "documents.log"
                },
                "references": {
                    "sentences": [
                        "Once the victim double-clicks on the shortcut file, the command executes the Windows rundll32.exe program to launch the documents.log file. This lets us know that the file being launched is a DLL file, and the entry point is its export function vspa.",
                        "When we mount the malicious ISO file, we see that a drive is mounted on the system that contains a shortcut file named Attachments.lnk and a hidden file named documents.log."
                    ],
                    "titles": [
                        "Step 1: Mounting ISO File & Extracting Stage 1 Executable"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x2705e00c>",
                            "type": "File",
                            "value": "documents.log"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x2705e00c>",
                            "type": "File",
                            "value": "documents.log"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0xf4622dc5>",
                    "type": "File",
                    "value": "rundll32.exe"
                },
                "references": {
                    "sentences": [
                        "Once the victim double-clicks on the shortcut file, the command executes the Windows rundll32.exe program to launch the documents.log file. This lets us know that the file being launched is a DLL file, and the entry point is its export function vspa."
                    ],
                    "titles": [
                        "Step 1: Mounting ISO File & Extracting Stage 1 Executable"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xf4622dc5>",
                            "type": "File",
                            "value": "rundll32.exe"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0x5ed983fd>",
                    "type": "File",
                    "value": "kernel32.dll"
                },
                "references": {
                    "sentences": [
                        "It calls GetModuleHandle to retrieve the handle to Kernel32.dll, calls GetProcAddress to retrieve the address of the GetProcAddress API, and writes those in the structure.",
                        "First, the malware populates the following structure that contains a handle to Kernel32.dll and addresses to API required to load libraries and get their API addresses."
                    ],
                    "titles": [
                        "Step 5: BAZARLOADERs API Obfuscation"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x5ed983fd>",
                            "type": "File",
                            "value": "kernel32.dll"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1705d2ec>",
                            "type": "UnknownWord",
                            "value": "populates"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x5ed983fd>",
                            "type": "File",
                            "value": "kernel32.dll"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x28e329e4>",
                            "type": "UnknownWord",
                            "value": "getprocaddress"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x5ed983fd>",
                            "type": "File",
                            "value": "kernel32.dll"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbfcb53c2>",
                            "type": "UnknownWord",
                            "value": "getmodulehandle"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x5ed983fd>",
                            "type": "File",
                            "value": "kernel32.dll"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x5ed983fd>",
                            "type": "File",
                            "value": "kernel32.dll"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x5ed983fd>",
                            "type": "File",
                            "value": "kernel32.dll"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x533ce732>",
                            "type": "UnknownWord",
                            "value": "handle"
                        }
                    }
                ]
            }
        ],
        "Hash": [
            {
                "token": {
                    "id": "<SHA256_0x78473138>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "0900b4eb02bdcaefd21df169d21794c8c70bfbc68b2f0612861fcabc82f28149"
                },
                "references": {
                    "sentences": [
                        "SHA256: 0900b4eb02bdcaefd21df169d21794c8c70bfbc68b2f0612861fcabc82f28149"
                    ],
                    "titles": [
                        "BAZARLOADER: Unpacking an ISO File Infection"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x78473138>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "0900b4eb02bdcaefd21df169d21794c8c70bfbc68b2f0612861fcabc82f28149"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xf4f1f185>",
                            "type": "Threat",
                            "value": "bazarbackdoor"
                        }
                    }
                ]
            }
        ]
    },
    "unknownwords": {
        "UnknownWord": [
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x72524b90>",
                    "type": "UnknownWord",
                    "value": "unpacking"
                },
                "references": {
                    "sentences": [
                        "At this point, we can safely guess that sub_1800045D6 is an API resolving function, and the parameter it takes is the hash of the APIs name. Because this is still the unpacking phase, we wont dive too deep into analyzing this function.",
                        "We can now dump this virtual memory buffer to retrieve the second stage shellcode for the next unpacking step."
                    ],
                    "titles": [
                        "BAZARLOADER: Unpacking an ISO File Infection",
                        "BAZARLOADER: Unpacking an ISO File Infection. Step 1: Mounting ISO File & Extracting Stage 1 Executable"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe5ed129e>",
                    "type": "UnknownWord",
                    "value": "avs"
                },
                "references": {
                    "sentences": [
                        "Recent BAZARLOADER samples arrive in emails containing OneDrive links to download an ISO file to avoid detection since most AVs tend to ignore this particular file type. With Windows 7 and above integrating the mounting functionality into Windows Explorer, we can mount any ISO file as a virtual drive by double-clicking on it."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x51236b87>",
                    "type": "UnknownWord",
                    "value": "double-clicking"
                },
                "references": {
                    "sentences": [
                        "Recent BAZARLOADER samples arrive in emails containing OneDrive links to download an ISO file to avoid detection since most AVs tend to ignore this particular file type. With Windows 7 and above integrating the mounting functionality into Windows Explorer, we can mount any ISO file as a virtual drive by double-clicking on it."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2c4e7a92>",
                    "type": "UnknownWord",
                    "value": "vspa"
                },
                "references": {
                    "sentences": [
                        "Once the victim double-clicks on the shortcut file, the command executes the Windows rundll32.exe program to launch the documents.log file. This lets us know that the file being launched is a DLL file, and the entry point is its export function vspa.",
                        "From this point onward, we can guess that the packer will decode this buffer and launch it somewhere later in the code. If we skip toward the end of the vspa export, we see a call instruction on a variable that is not returned from the API resolving function, so it can potentially be our tail jump.",
                        "In the first function of the vspa export, we see sub_1800045D6 takes a DWORD in as the parameter. This function returns a variable that contains an address to a function that is later called in the code.",
                        "From here, we can set up x64dbg, execute the DLL file at the vspa export, and break at the call instruction. After stepping into the function, we will be at the head of the shellcode."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbfa11c9d>",
                    "type": "UnknownWord",
                    "value": "ida"
                },
                "references": {
                    "sentences": [
                        "When we examine the shellcode in IDA, we can quickly use the same trick with HashDB above to see that the shellcode also performs API hashing with Metasploits ROR13.",
                        "Taking a quick look in IDA, we can somewhat tell that the extracted DLL is packed since it has only a few functions and a really suspicious looking buffer of ASCII characters in its custom .odata section.",
                        "Instead, Ill just use OALabss HashDB IDA plugin to quickly reverse-lookup the hashing algorithm used from the hash. The result shows that the hash corresponds to an API name hashed with Metasploits hashing algorithm ROR13."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9c6a38db>",
                    "type": "UnknownWord",
                    "value": "somewhat"
                },
                "references": {
                    "sentences": [
                        "Taking a quick look in IDA, we can somewhat tell that the extracted DLL is packed since it has only a few functions and a really suspicious looking buffer of ASCII characters in its custom .odata section."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8d24d1d>",
                    "type": "UnknownWord",
                    "value": "tell"
                },
                "references": {
                    "sentences": [
                        "Taking a quick look in IDA, we can somewhat tell that the extracted DLL is packed since it has only a few functions and a really suspicious looking buffer of ASCII characters in its custom .odata section."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xea1f5834>",
                    "type": "UnknownWord",
                    "value": "packed"
                },
                "references": {
                    "sentences": [
                        "Taking a quick look in IDA, we can somewhat tell that the extracted DLL is packed since it has only a few functions and a really suspicious looking buffer of ASCII characters in its custom .odata section."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbbded9b2>",
                    "type": "UnknownWord",
                    "value": "odata"
                },
                "references": {
                    "sentences": [
                        "Taking a quick look in IDA, we can somewhat tell that the extracted DLL is packed since it has only a few functions and a really suspicious looking buffer of ASCII characters in its custom .odata section."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8456eca8>",
                    "type": "UnknownWord",
                    "value": "sub_1800045d6"
                },
                "references": {
                    "sentences": [
                        "At this point, we can safely guess that sub_1800045D6 is an API resolving function, and the parameter it takes is the hash of the APIs name. Because this is still the unpacking phase, we wont dive too deep into analyzing this function.",
                        "In the first function of the vspa export, we see sub_1800045D6 takes a DWORD in as the parameter. This function returns a variable that contains an address to a function that is later called in the code."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x378fe873>",
                    "type": "UnknownWord",
                    "value": "safely"
                },
                "references": {
                    "sentences": [
                        "At this point, we can safely guess that sub_1800045D6 is an API resolving function, and the parameter it takes is the hash of the APIs name. Because this is still the unpacking phase, we wont dive too deep into analyzing this function."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdd4e91c8>",
                    "type": "UnknownWord",
                    "value": "guess"
                },
                "references": {
                    "sentences": [
                        "At this point, we can safely guess that sub_1800045D6 is an API resolving function, and the parameter it takes is the hash of the APIs name. Because this is still the unpacking phase, we wont dive too deep into analyzing this function.",
                        "From this point onward, we can guess that the packer will decode this buffer and launch it somewhere later in the code. If we skip toward the end of the vspa export, we see a call instruction on a variable that is not returned from the API resolving function, so it can potentially be our tail jump.",
                        "This tells us two things. First, our guess that the v19 variable will contain the address to executable code is correct. Second, we know that the executable code is shellcode since the data is mapped and executed directly at offset 0 from where it is written."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5c9f9e46>",
                    "type": "UnknownWord",
                    "value": "resolving"
                },
                "references": {
                    "sentences": [
                        "At this point, we can safely guess that sub_1800045D6 is an API resolving function, and the parameter it takes is the hash of the APIs name. Because this is still the unpacking phase, we wont dive too deep into analyzing this function.",
                        "From this point onward, we can guess that the packer will decode this buffer and launch it somewhere later in the code. If we skip toward the end of the vspa export, we see a call instruction on a variable that is not returned from the API resolving function, so it can potentially be our tail jump."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4a212f48>",
                    "type": "UnknownWord",
                    "value": "ill"
                },
                "references": {
                    "sentences": [
                        "Instead, Ill just use OALabss HashDB IDA plugin to quickly reverse-lookup the hashing algorithm used from the hash. The result shows that the hash corresponds to an API name hashed with Metasploits hashing algorithm ROR13."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf08f6bb5>",
                    "type": "UnknownWord",
                    "value": "oalabss"
                },
                "references": {
                    "sentences": [
                        "With this in mind, our next step should be debugging the shellcode and setting breakpoints at these two API calls. We can pick up where we are after dumping in x64dbg during Step 2, or we can launch the shellcode directly in our debugger using OALabss BlobRunner or similar shellcode launcher.",
                        "Instead, Ill just use OALabss HashDB IDA plugin to quickly reverse-lookup the hashing algorithm used from the hash. The result shows that the hash corresponds to an API name hashed with Metasploits hashing algorithm ROR13."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x401138ba>",
                    "type": "UnknownWord",
                    "value": "hashdb"
                },
                "references": {
                    "sentences": [
                        "When we examine the shellcode in IDA, we can quickly use the same trick with HashDB above to see that the shellcode also performs API hashing with Metasploits ROR13.",
                        "Instead, Ill just use OALabss HashDB IDA plugin to quickly reverse-lookup the hashing algorithm used from the hash. The result shows that the hash corresponds to an API name hashed with Metasploits hashing algorithm ROR13.",
                        "After determining the hashing algorithm, we can use HashDB to quickly look up the APIs being resolved by this function. It becomes clear that this function resolves the RtlAllocateHeap API, calls that to allocate a heap buffer and writes the encoded ASCII data to it."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa90f3285>",
                    "type": "UnknownWord",
                    "value": "reverse-lookup"
                },
                "references": {
                    "sentences": [
                        "Instead, Ill just use OALabss HashDB IDA plugin to quickly reverse-lookup the hashing algorithm used from the hash. The result shows that the hash corresponds to an API name hashed with Metasploits hashing algorithm ROR13."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x99c29cfc>",
                    "type": "UnknownWord",
                    "value": "ror13"
                },
                "references": {
                    "sentences": [
                        "When we examine the shellcode in IDA, we can quickly use the same trick with HashDB above to see that the shellcode also performs API hashing with Metasploits ROR13.",
                        "Instead, Ill just use OALabss HashDB IDA plugin to quickly reverse-lookup the hashing algorithm used from the hash. The result shows that the hash corresponds to an API name hashed with Metasploits hashing algorithm ROR13."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9879afd7>",
                    "type": "UnknownWord",
                    "value": "resolved"
                },
                "references": {
                    "sentences": [
                        "After determining the hashing algorithm, we can use HashDB to quickly look up the APIs being resolved by this function. It becomes clear that this function resolves the RtlAllocateHeap API, calls that to allocate a heap buffer and writes the encoded ASCII data to it.",
                        "There are different ways to resolve these stack strings, such as writing IDAPython scripts, emulation, or just running the program in a debugger and dumping the stack strings when they are resolved."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xde5404e2>",
                    "type": "UnknownWord",
                    "value": "rtlallocateheap"
                },
                "references": {
                    "sentences": [
                        "After determining the hashing algorithm, we can use HashDB to quickly look up the APIs being resolved by this function. It becomes clear that this function resolves the RtlAllocateHeap API, calls that to allocate a heap buffer and writes the encoded ASCII data to it."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf60948a4>",
                    "type": "UnknownWord",
                    "value": "allocate"
                },
                "references": {
                    "sentences": [
                        "Our first hit with VirtualAlloc is a call to allocate a virtual memory buffer at virtual address 0x204140000 with the size of 0x2A000 bytes.",
                        "At the entry point above, the shellcode resolves a set of functions that it will call, most notably VirtualAlloc and VirtualProtect. These two functions are typically used by packers to allocate virtual memory to decode and write the next stage executable in before launching it.",
                        "After determining the hashing algorithm, we can use HashDB to quickly look up the APIs being resolved by this function. It becomes clear that this function resolves the RtlAllocateHeap API, calls that to allocate a heap buffer and writes the encoded ASCII data to it."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb7f54ea4>",
                    "type": "UnknownWord",
                    "value": "onward"
                },
                "references": {
                    "sentences": [
                        "From this point onward, we can guess that the packer will decode this buffer and launch it somewhere later in the code. If we skip toward the end of the vspa export, we see a call instruction on a variable that is not returned from the API resolving function, so it can potentially be our tail jump."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x693d03f7>",
                    "type": "UnknownWord",
                    "value": "somewhere"
                },
                "references": {
                    "sentences": [
                        "From this point onward, we can guess that the packer will decode this buffer and launch it somewhere later in the code. If we skip toward the end of the vspa export, we see a call instruction on a variable that is not returned from the API resolving function, so it can potentially be our tail jump."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x57b23fa4>",
                    "type": "UnknownWord",
                    "value": "toward"
                },
                "references": {
                    "sentences": [
                        "From this point onward, we can guess that the packer will decode this buffer and launch it somewhere later in the code. If we skip toward the end of the vspa export, we see a call instruction on a variable that is not returned from the API resolving function, so it can potentially be our tail jump."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe19018ce>",
                    "type": "UnknownWord",
                    "value": "tail"
                },
                "references": {
                    "sentences": [
                        "From this point onward, we can guess that the packer will decode this buffer and launch it somewhere later in the code. If we skip toward the end of the vspa export, we see a call instruction on a variable that is not returned from the API resolving function, so it can potentially be our tail jump."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa8dd6445>",
                    "type": "UnknownWord",
                    "value": "sub_180003fe6"
                },
                "references": {
                    "sentences": [
                        "The last function to modify that v19 variable is sub_180003FE6, so we can quickly take a look at that.",
                        "It turns out the sub_180003FE6 function just resolves and calls NtMapViewOfSection to map a view of a section into the virtual address space and writes the base address of the view into the v19 variable. Then, it just executes qmemcpy to copy the data in the second variable to the returned virtual base address."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4809eae>",
                    "type": "UnknownWord",
                    "value": "ntmapviewofsection"
                },
                "references": {
                    "sentences": [
                        "It turns out the sub_180003FE6 function just resolves and calls NtMapViewOfSection to map a view of a section into the virtual address space and writes the base address of the view into the v19 variable. Then, it just executes qmemcpy to copy the data in the second variable to the returned virtual base address."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5b9444c6>",
                    "type": "UnknownWord",
                    "value": "qmemcpy"
                },
                "references": {
                    "sentences": [
                        "It turns out the sub_180003FE6 function just resolves and calls NtMapViewOfSection to map a view of a section into the virtual address space and writes the base address of the view into the v19 variable. Then, it just executes qmemcpy to copy the data in the second variable to the returned virtual base address."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7bf80a4>",
                    "type": "UnknownWord",
                    "value": "offset"
                },
                "references": {
                    "sentences": [
                        "This tells us two things. First, our guess that the v19 variable will contain the address to executable code is correct. Second, we know that the executable code is shellcode since the data is mapped and executed directly at offset 0 from where it is written."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd1e5c8b9>",
                    "type": "UnknownWord",
                    "value": "x64dbg"
                },
                "references": {
                    "sentences": [
                        "With this in mind, our next step should be debugging the shellcode and setting breakpoints at these two API calls. We can pick up where we are after dumping in x64dbg during Step 2, or we can launch the shellcode directly in our debugger using OALabss BlobRunner or similar shellcode launcher.",
                        "From here, we can set up x64dbg, execute the DLL file at the vspa export, and break at the call instruction. After stepping into the function, we will be at the head of the shellcode."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x42935e66>",
                    "type": "UnknownWord",
                    "value": "break"
                },
                "references": {
                    "sentences": [
                        "From here, we can set up x64dbg, execute the DLL file at the vspa export, and break at the call instruction. After stepping into the function, we will be at the head of the shellcode."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa8145cfc>",
                    "type": "UnknownWord",
                    "value": "notably"
                },
                "references": {
                    "sentences": [
                        "At the entry point above, the shellcode resolves a set of functions that it will call, most notably VirtualAlloc and VirtualProtect. These two functions are typically used by packers to allocate virtual memory to decode and write the next stage executable in before launching it."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbb51c097>",
                    "type": "UnknownWord",
                    "value": "virtualalloc"
                },
                "references": {
                    "sentences": [
                        "We can run until VirtualAlloc returns and start monitoring the memory at address 0x204140000. After running until the next VirtualProtect call, we see that a valid PE executable has been written to this memory region.",
                        "Our first hit with VirtualAlloc is a call to allocate a virtual memory buffer at virtual address 0x204140000 with the size of 0x2A000 bytes.",
                        "At the entry point above, the shellcode resolves a set of functions that it will call, most notably VirtualAlloc and VirtualProtect. These two functions are typically used by packers to allocate virtual memory to decode and write the next stage executable in before launching it."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3f8e388d>",
                    "type": "UnknownWord",
                    "value": "virtualprotect"
                },
                "references": {
                    "sentences": [
                        "We can run until VirtualAlloc returns and start monitoring the memory at address 0x204140000. After running until the next VirtualProtect call, we see that a valid PE executable has been written to this memory region.",
                        "At the entry point above, the shellcode resolves a set of functions that it will call, most notably VirtualAlloc and VirtualProtect. These two functions are typically used by packers to allocate virtual memory to decode and write the next stage executable in before launching it."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf5adf08>",
                    "type": "UnknownWord",
                    "value": "breakpoints"
                },
                "references": {
                    "sentences": [
                        "With this in mind, our next step should be debugging the shellcode and setting breakpoints at these two API calls. We can pick up where we are after dumping in x64dbg during Step 2, or we can launch the shellcode directly in our debugger using OALabss BlobRunner or similar shellcode launcher."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xff0d899f>",
                    "type": "UnknownWord",
                    "value": "blobrunner"
                },
                "references": {
                    "sentences": [
                        "With this in mind, our next step should be debugging the shellcode and setting breakpoints at these two API calls. We can pick up where we are after dumping in x64dbg during Step 2, or we can launch the shellcode directly in our debugger using OALabss BlobRunner or similar shellcode launcher."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x82742471>",
                    "type": "UnknownWord",
                    "value": "bazarloaders"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Step 4: BAZARLOADERs String Obfuscation",
                        "Step 5: BAZARLOADERs API Obfuscation"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa9129707>",
                    "type": "UnknownWord",
                    "value": "crucial"
                },
                "references": {
                    "sentences": [
                        "As we begin performing static analysis on BAZARLOADER, it is crucial that we identify obfuscation methods that the malware uses."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1525fafe>",
                    "type": "UnknownWord",
                    "value": "stack"
                },
                "references": {
                    "sentences": [
                        "There are different ways to resolve these stack strings, such as writing IDAPython scripts, emulation, or just running the program in a debugger and dumping the stack strings when they are resolved.",
                        "For my analysis, I just manually decode the stack strings in my debugger and rename the wrapper function accordingly.",
                        "One of those methods is string obfuscation, where the malware uses encoded stack strings to hide them from static analysis.",
                        "To begin populating each LIBRARY_STRUCT structure, BAZARLOADER decodes the library name from a stack string and populates it with the corresponding set of functions and the library handle retrieved from calling LoadLibraryA.",
                        "This function resolves the API name from a stack string, retrieves the APIs address using the get_API_addr function from the library structure, and calls the API with its parameters.",
                        "As shown, a typical encoded string is pushed on the stack and decoded dynamically using some multiplication, subtraction, and modulus operations."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbb5d1923>",
                    "type": "UnknownWord",
                    "value": "multiplication"
                },
                "references": {
                    "sentences": [
                        "As shown, a typical encoded string is pushed on the stack and decoded dynamically using some multiplication, subtraction, and modulus operations."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x458c2555>",
                    "type": "UnknownWord",
                    "value": "subtraction"
                },
                "references": {
                    "sentences": [
                        "As shown, a typical encoded string is pushed on the stack and decoded dynamically using some multiplication, subtraction, and modulus operations."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8a8d3c36>",
                    "type": "UnknownWord",
                    "value": "modulus"
                },
                "references": {
                    "sentences": [
                        "As shown, a typical encoded string is pushed on the stack and decoded dynamically using some multiplication, subtraction, and modulus operations."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbd360262>",
                    "type": "UnknownWord",
                    "value": "idapython"
                },
                "references": {
                    "sentences": [
                        "There are different ways to resolve these stack strings, such as writing IDAPython scripts, emulation, or just running the program in a debugger and dumping the stack strings when they are resolved."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc4188aa3>",
                    "type": "UnknownWord",
                    "value": "constructs"
                },
                "references": {
                    "sentences": [
                        "BAZARLOADER obfuscates most of its API calls through a few structures that it constructs in the DllEntryPoint function."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x87928df0>",
                    "type": "UnknownWord",
                    "value": "dllentrypoint"
                },
                "references": {
                    "sentences": [
                        "BAZARLOADER obfuscates most of its API calls through a few structures that it constructs in the DllEntryPoint function."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1705d2ec>",
                    "type": "UnknownWord",
                    "value": "populates"
                },
                "references": {
                    "sentences": [
                        "Next, for each library to be imported, BAZARLOADER populates the following LIBRARY_STRUCT structure that contains a set of functions to interact with the library and the library handle.",
                        "First, the malware populates the following structure that contains a handle to Kernel32.dll and addresses to API required to load libraries and get their API addresses."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x5ed983fd>",
                            "type": "File",
                            "value": "kernel32.dll"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1705d2ec>",
                            "type": "UnknownWord",
                            "value": "populates"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x533ce732>",
                    "type": "UnknownWord",
                    "value": "handle"
                },
                "references": {
                    "sentences": [
                        "To begin populating each LIBRARY_STRUCT structure, BAZARLOADER decodes the library name from a stack string and populates it with the corresponding set of functions and the library handle retrieved from calling LoadLibraryA.",
                        "Next, for each library to be imported, BAZARLOADER populates the following LIBRARY_STRUCT structure that contains a set of functions to interact with the library and the library handle.",
                        "It calls GetModuleHandle to retrieve the handle to Kernel32.dll, calls GetProcAddress to retrieve the address of the GetProcAddress API, and writes those in the structure.",
                        "First, the malware populates the following structure that contains a handle to Kernel32.dll and addresses to API required to load libraries and get their API addresses."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x5ed983fd>",
                            "type": "File",
                            "value": "kernel32.dll"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x533ce732>",
                            "type": "UnknownWord",
                            "value": "handle"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbfcb53c2>",
                    "type": "UnknownWord",
                    "value": "getmodulehandle"
                },
                "references": {
                    "sentences": [
                        "It calls GetModuleHandle to retrieve the handle to Kernel32.dll, calls GetProcAddress to retrieve the address of the GetProcAddress API, and writes those in the structure."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x5ed983fd>",
                            "type": "File",
                            "value": "kernel32.dll"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbfcb53c2>",
                            "type": "UnknownWord",
                            "value": "getmodulehandle"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x28e329e4>",
                    "type": "UnknownWord",
                    "value": "getprocaddress"
                },
                "references": {
                    "sentences": [
                        "Using the structures GetProcAddress API field, BAZARLOADER retrieves the rest of the required APIs to populate other fields in the structure. This API_IMPORT_STRUCT structure will later be used to import other libraries APIs.",
                        "The third function calls the GetProcAddress from the API_IMPORT_STRUCTs field to retrieve the address of an API exported from that specific library.",
                        "It calls GetModuleHandle to retrieve the handle to Kernel32.dll, calls GetProcAddress to retrieve the address of the GetProcAddress API, and writes those in the structure."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x5ed983fd>",
                            "type": "File",
                            "value": "kernel32.dll"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x28e329e4>",
                            "type": "UnknownWord",
                            "value": "getprocaddress"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd673e668>",
                    "type": "UnknownWord",
                    "value": "populate"
                },
                "references": {
                    "sentences": [
                        "Using the structures GetProcAddress API field, BAZARLOADER retrieves the rest of the required APIs to populate other fields in the structure. This API_IMPORT_STRUCT structure will later be used to import other libraries APIs."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x49215a36>",
                    "type": "UnknownWord",
                    "value": "api_import_struct"
                },
                "references": {
                    "sentences": [
                        "The first 2 functions in the LIB_FUNCS structure just call the FreeLibrary API from the global API_IMPORT_STRUCT to free the library module.",
                        "Using the structures GetProcAddress API field, BAZARLOADER retrieves the rest of the required APIs to populate other fields in the structure. This API_IMPORT_STRUCT structure will later be used to import other libraries APIs."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x41cfb030>",
                    "type": "UnknownWord",
                    "value": "imported"
                },
                "references": {
                    "sentences": [
                        "Next, for each library to be imported, BAZARLOADER populates the following LIBRARY_STRUCT structure that contains a set of functions to interact with the library and the library handle."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc80b6b9a>",
                    "type": "UnknownWord",
                    "value": "library_struct"
                },
                "references": {
                    "sentences": [
                        "To begin populating each LIBRARY_STRUCT structure, BAZARLOADER decodes the library name from a stack string and populates it with the corresponding set of functions and the library handle retrieved from calling LoadLibraryA.",
                        "The LIBRARY_STRUCT structures corresponding to these are pushed into a global list in the order below.",
                        "Next, for each library to be imported, BAZARLOADER populates the following LIBRARY_STRUCT structure that contains a set of functions to interact with the library and the library handle.",
                        "After this global list of LIBRARY_STRUCT is populated, an API can be called from a function taking in its corresponding librarys LIBRARY_STRUCT structure and its parameters."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdb09e06>",
                    "type": "UnknownWord",
                    "value": "lib_funcs"
                },
                "references": {
                    "sentences": [
                        "The first 2 functions in the LIB_FUNCS structure just call the FreeLibrary API from the global API_IMPORT_STRUCT to free the library module."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x131134ac>",
                    "type": "UnknownWord",
                    "value": "freelibrary"
                },
                "references": {
                    "sentences": [
                        "The first 2 functions in the LIB_FUNCS structure just call the FreeLibrary API from the global API_IMPORT_STRUCT to free the library module."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x16e6b75e>",
                    "type": "UnknownWord",
                    "value": "api_import_structs"
                },
                "references": {
                    "sentences": [
                        "The third function calls the GetProcAddress from the API_IMPORT_STRUCTs field to retrieve the address of an API exported from that specific library."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfe395d0d>",
                    "type": "UnknownWord",
                    "value": "populating"
                },
                "references": {
                    "sentences": [
                        "To begin populating each LIBRARY_STRUCT structure, BAZARLOADER decodes the library name from a stack string and populates it with the corresponding set of functions and the library handle retrieved from calling LoadLibraryA."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa24ea783>",
                    "type": "UnknownWord",
                    "value": "loadlibrarya"
                },
                "references": {
                    "sentences": [
                        "To begin populating each LIBRARY_STRUCT structure, BAZARLOADER decodes the library name from a stack string and populates it with the corresponding set of functions and the library handle retrieved from calling LoadLibraryA."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6f48a72d>",
                    "type": "UnknownWord",
                    "value": "get_api_addr"
                },
                "references": {
                    "sentences": [
                        "This function resolves the API name from a stack string, retrieves the APIs address using the get_API_addr function from the library structure, and calls the API with its parameters."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3eb3aef9>",
                    "type": "UnknownWord",
                    "value": "wrapper"
                },
                "references": {
                    "sentences": [
                        "The way the wrapper function is setup to call the actual API is really intuitive, making the code simple to understand through static analysis. However, its a bit more difficult to automate the process since there is no API hashing involved.",
                        "For my analysis, I just manually decode the stack strings in my debugger and rename the wrapper function accordingly."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbfcaf5c0>",
                    "type": "UnknownWord",
                    "value": "intuitive"
                },
                "references": {
                    "sentences": [
                        "The way the wrapper function is setup to call the actual API is really intuitive, making the code simple to understand through static analysis. However, its a bit more difficult to automate the process since there is no API hashing involved."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9b8a6287>",
                    "type": "UnknownWord",
                    "value": "manually"
                },
                "references": {
                    "sentences": [
                        "For my analysis, I just manually decode the stack strings in my debugger and rename the wrapper function accordingly."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7e560d97>",
                    "type": "UnknownWord",
                    "value": "accordingly"
                },
                "references": {
                    "sentences": [
                        "For my analysis, I just manually decode the stack strings in my debugger and rename the wrapper function accordingly."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfe4a4d24>",
                    "type": "UnknownWord",
                    "value": "beacon"
                },
                "references": {
                    "sentences": [
                        "In the next blog post, we will fully analyze how the loader downloads and launches a Cobalt Strike beacon from its C2 servers!",
                        "BAZARLOADER (aka BAZARBACKDOOR) is a Windows-based loader that spreads through attachments in phishing emails. During an infection, the final loader payload typically downloads and executes a Cobalt Strike beacon to provide remote access for the threat actors, which, in a lot of cases, leads to ransomware being deployed to the victims machine."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x46858288>",
                    "type": "UnknownWord",
                    "value": "chuong dong"
                },
                "references": {
                    "sentences": [
                        "Chuong Dong<crlf>19th April 2022<crlf>No Comments"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xde4badf1>",
                    "type": "UnknownWord",
                    "value": "19th"
                },
                "references": {
                    "sentences": [
                        "Chuong Dong<crlf>19th April 2022<crlf>No Comments"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc2e1cb5c>",
                    "type": "UnknownWord",
                    "value": "windows-based"
                },
                "references": {
                    "sentences": [
                        "BAZARLOADER (aka BAZARBACKDOOR) is a Windows-based loader that spreads through attachments in phishing emails. During an infection, the final loader payload typically downloads and executes a Cobalt Strike beacon to provide remote access for the threat actors, which, in a lot of cases, leads to ransomware being deployed to the victims machine."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc832e23c>",
                    "type": "UnknownWord",
                    "value": "unpack"
                },
                "references": {
                    "sentences": [
                        "In this initial post, we will unpack the different stages of a BAZARLOADER infection that comes in the form of an optical disk image (ISO) file. We will also dive into the obfuscation methods used by the main BAZARLOADER payload."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8beb3fb7>",
                    "type": "UnknownWord",
                    "value": "optical"
                },
                "references": {
                    "sentences": [
                        "In this initial post, we will unpack the different stages of a BAZARLOADER infection that comes in the form of an optical disk image (ISO) file. We will also dive into the obfuscation methods used by the main BAZARLOADER payload."
                    ],
                    "titles": []
                }
            }
        ]
    },
    "other_links": [],
    "info": {
        "potential_threats": {},
        "sigma": false,
        "yara": false
    },
    "keywords": {
        "classified": [],
        "dubbed": [],
        "associated": [],
        "targets": [],
        "attributed": []
    },
    "resources": {
        "links": {
            "github": [
                "https://github.com/OALabs/hashdb-ida",
                "https://github.com/OALabs/hashdb/blob/b3cc544fad41c749d04616663ac13f02bf1aaf37/algorithms/metasploit.py",
                "https://github.com/OALabs/BlobRunner",
                "https://github.com/mandiant/flare-emu"
            ],
            "pastebin": [],
            "text_files": [],
            "other": [
                "https://www.0ffset.net/author/chuong-dong/",
                "https://www.malware-traffic-analysis.net/2022/02/07/index.html"
            ]
        },
        "images": [
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_01.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_02.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_03-1024x623.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_04.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_05.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_06-1.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_07.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_08.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_09.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_10-1024x520.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_11.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_12-1024x452.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_13.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_14.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_15.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_16.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_17.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_18.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_19-1024x81.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_20.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_21.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_22.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_23.png",
            "https://www.0ffset.net/wp-content/uploads/2022/04/bazarloader_16.png"
        ]
    }
}