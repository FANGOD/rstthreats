{
    "title": "Reversing a NSIS dropper using quick and dirty shellcode emulation. The Excel document",
    "url": "https://malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation",
    "threats": {
        "Threat": [
            {
                "token": {
                    "id": "<THREAT_0xb673273e>",
                    "type": "Threat",
                    "value": "nsis_dropper"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Reversing a NSIS dropper using quick and dirty shellcode emulation",
                        "Reversing a NSIS dropper using quick and dirty shellcode emulation. The Excel document"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<THREAT_0xed169ce1>",
                            "type": "Threat",
                            "value": "lokibot_stealer"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xe86379a>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "02dee91a81652e5234414e452622307fd61e7988e82bec43665f699f805c3151"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xde6c2b3>",
                            "type": "File",
                            "value": "csrss.exe"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x2a4baf7b>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "be00a655cdf4e4706bf1bbf3659d698f967cad66acdf7cda0d12f16dc0cfda3e"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xa6e9a9d0>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "e850f3849ea82980cf23844ad3caadf73856b2d5b0c4179847d82ce4016e80ee"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x32239007>",
                            "type": "Category",
                            "value": "stealer"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    },
                    {
                        "src": {
                            "id": "<URL_0x92a1279a>",
                            "type": "Url",
                            "value": "http://103.153.79.104/windows10/csrss.exe"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x759666e0>",
                            "type": "Threat",
                            "value": "dbat_loader"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x88a1f8ba>",
                            "type": "File",
                            "value": "dwksh.dll"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xf49383ae>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "291df8186e62df74b8fcf2c361c6913b9b73e3e864dde58eb63d5c3159a4c32d"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    },
                    {
                        "src": {
                            "id": "<CVE_0x394b0f55>",
                            "type": "CVE",
                            "value": "cve-2018-0798"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<THREAT_0x759666e0>",
                    "type": "Threat",
                    "value": "dbat_loader"
                },
                "references": {
                    "sentences": [
                        "At the time of the analysis, the file is still online. But this time, we don't get a DBatLoader instance, but a NSIS installer instead. So let us fetch the file and have a look at the installer."
                    ],
                    "titles": [
                        "The Excel document"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<THREAT_0x759666e0>",
                            "type": "Threat",
                            "value": "dbat_loader"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<THREAT_0xed169ce1>",
                    "type": "Threat",
                    "value": "lokibot_stealer"
                },
                "references": {
                    "sentences": [
                        "If we want to be more precise, we can use Malcat's online intelligence view (Ctrl+I, only for paid versions). Normally I would avoid using Virustotal to identify a malware family (because of packer reuse among threat actors). But here we are dealing with the plain text final malware, so we should get at least some valid labels. In our case, it seems to be Lokibot, a simple password stealer:",
                        ")<crlf>Infection chain:<crlf>Excel stylesheet -> Office equation -> Shellcode (downloader) -> NSIS installer -> Shellcode (stage 1) -> Shellcode (stage 2) -> Lokibot<crlf>Tools used:",
                        "NSIS installers have been abused by malware authors for some years now. While the NSIS VM instruction set is relatively limited, DLL plugins allow malicious actors to extend installer capabilities and obfuscate malware. In this example, two layers of shellcodes were used by the NSIS installer in order to deliver its final payload: a LokiBot password stealer."
                    ],
                    "titles": [
                        "Reversing a NSIS dropper using quick and dirty shellcode emulation",
                        "Conclusion",
                        "Stage 3: Lokibot and config extraction"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<THREAT_0xed169ce1>",
                            "type": "Threat",
                            "value": "lokibot_stealer"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0xed169ce1>",
                            "type": "Threat",
                            "value": "lokibot_stealer"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x32239007>",
                            "type": "Category",
                            "value": "stealer"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0xed169ce1>",
                            "type": "Threat",
                            "value": "lokibot_stealer"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0xed169ce1>",
                            "type": "Threat",
                            "value": "lokibot_stealer"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xe86379a>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "02dee91a81652e5234414e452622307fd61e7988e82bec43665f699f805c3151"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xed169ce1>",
                            "type": "Threat",
                            "value": "lokibot_stealer"
                        }
                    }
                ]
            }
        ]
    },
    "ttps": {},
    "meanings": {
        "Category": [
            {
                "token": {
                    "id": "<CATEGORY_0xb68aa214>",
                    "type": "Category",
                    "value": "rat"
                },
                "references": {
                    "sentences": [
                        "After this, Malcat is smart enough to recover most of the shellcode's CFG using its usual set of analyses. Following the control flow, we quickly arrive in the function sub_7dd which contains interesting patterns:",
                        "Before emulating anything, we need to solve a problem: the data to decrypt (d54hdan9c9ebsx) is not embedded in the lognp shellcode, it is read from the filesystem using CreateFileA. So emulation is likely to fail. How are we going to solve this issue?",
                        "Figure 6: decrypting the shellcode",
                        "To emulate shellcodes, Malcat comes bundled with a script named speakeay_shellcode.py which emulates shellcodes using the Speakeasy emulator. Note that Speakeasy is not bundled with Malcat, you will have to install the python package yourself (and if you are running Malcat under Windows, be sure to check Use system python interpreter in the options).",
                        "It then seems to decrypt it in memory into an executable buffer before jumping at the beginning of the buffer (see the call eax below?). The file lognp is relatively small (5KB), it definitely looks like a shellcode.",
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"",
                        "But there is also the dirty way: we could patch the decrypted lognp shellcode in order to embed the content of d54hdan9c9ebsx in the shellcode space and patch the shellcode entry point to perform a call to the decryption function with the right parameters. Of course we will chose the dirty way. It is not only way faster, it is also more fun.",
                        ")<crlf>Infection chain:<crlf>Excel stylesheet -> Office equation -> Shellcode (downloader) -> NSIS installer -> Shellcode (stage 1) -> Shellcode (stage 2) -> Lokibot<crlf>Tools used:",
                        "At the end, the patched shellcode should look like in the picture below. For the lazy readers, you can download the patched lognp file here (password: infected).",
                        "Figure 7: locating the decryption function inside the shellcode",
                        "the architecture used: x86 in our case. This can be set using the dropdown menu in the status bar<crlf>the entry point of the shellcode, which is at address 0 in our case. We just have to define a new function start at this address using the context menu in disassembly mode (F3)",
                        "The lognp file, once decrypted, does not appear to be in any known file format. But the first byte is E9, which is a jump in the x86 architecture and is very typical for shellcode prologs. So before starting the analysis, we will have to tell Malcat two things:",
                        "We won't go through the exploit shellcode extraction and decryption process again since the procedure is exactly the same (see here, shellcode offset is also 0x50). The exploit is again a downloader, downloading from the following url:",
                        "Figure 8: patching the shellcode",
                        "NSIS installers have been abused by malware authors for some years now. While the NSIS VM instruction set is relatively limited, DLL plugins allow malicious actors to extend installer capabilities and obfuscate malware. In this example, two layers of shellcodes were used by the NSIS installer in order to deliver its final payload: a LokiBot password stealer.",
                        "First open a copy of the decrypted lognp shellcode in Malcat with extra space at the end of the file (File > Open Copy of File). The file d54hdan9c9ebsx is 216843 bytes big, we'll append 300KB just to be sure.<crlf>Copy the content of the file d54hdan9c9ebsx in the clipboard: in a second Malcat instance, open d54hdan9c9ebsx and then hit Ctrl+A followed by Ctrl+C<crlf>Paste the copied data after the shellcode in the first Malcat instance, let's say at address 0x2000 to make it easy to remember<crlf>Enter disassembly view (F3) and go to the shellcode's entry point at address 0"
                    ],
                    "titles": [
                        "The SETUP script",
                        "Analyzing the shellcode",
                        "Patching lognp",
                        "Reversing a NSIS dropper using quick and dirty shellcode emulation. The Excel document",
                        "Reversing a NSIS dropper using quick and dirty shellcode emulation",
                        "Stage 1: dwksh.dll",
                        "Emulating the decryption function",
                        "Conclusion",
                        "Stage2: obfuscated shellcode",
                        "The Excel document"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<THREAT_0xed169ce1>",
                            "type": "Threat",
                            "value": "lokibot_stealer"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xa6e9a9d0>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "e850f3849ea82980cf23844ad3caadf73856b2d5b0c4179847d82ce4016e80ee"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0xf1a480bb>",
                    "type": "Category",
                    "value": "malware"
                },
                "references": {
                    "sentences": [
                        "The sample we are about to dissect today is an OpenXML Excel document which came as email attachment. The malicious document is very similar to the one we did analyze in our previous blog post: an encrypted OpenXML Excel document embedding an Equation object exploiting CVE-2018-0798. The same author is most likely behind this document as well, they just updated the bait picture:",
                        "We hope you enjoyed this new quick-and-dirty malware unpacking sessions. Future blog posts will be more focused toward beginners as we will introduce a few of Malcat's features as in-depth tutorials.",
                        "The last (and final) stage we get is a PE file of sha 02dee91a81652e5234414e452622307fd61e7988e82bec43665f699f805c3151 (VT). Judging by the low entropy and the visible strings, the file does not seem to be obfuscated, good news.<crlf>So which kind of malware do we face? Malcat's Yara rules already spotted one of main malware intent: stealing credentials, as we can see in the screenshot below:",
                        "If we want to be more precise, we can use Malcat's online intelligence view (Ctrl+I, only for paid versions). Normally I would avoid using Virustotal to identify a malware family (because of packer reuse among threat actors). But here we are dealing with the plain text final malware, so we should get at least some valid labels. In our case, it seems to be Lokibot, a simple password stealer:",
                        "NSIS installers have been abused by malware authors for some years now. While the NSIS VM instruction set is relatively limited, DLL plugins allow malicious actors to extend installer capabilities and obfuscate malware. In this example, two layers of shellcodes were used by the NSIS installer in order to deliver its final payload: a LokiBot password stealer."
                    ],
                    "titles": [
                        "Conclusion",
                        "Stage 3: Lokibot and config extraction",
                        "The Excel document"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0xed169ce1>",
                            "type": "Threat",
                            "value": "lokibot_stealer"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0x32239007>",
                    "type": "Category",
                    "value": "stealer"
                },
                "references": {
                    "sentences": [
                        "If we want to be more precise, we can use Malcat's online intelligence view (Ctrl+I, only for paid versions). Normally I would avoid using Virustotal to identify a malware family (because of packer reuse among threat actors). But here we are dealing with the plain text final malware, so we should get at least some valid labels. In our case, it seems to be Lokibot, a simple password stealer:",
                        "NSIS installers have been abused by malware authors for some years now. While the NSIS VM instruction set is relatively limited, DLL plugins allow malicious actors to extend installer capabilities and obfuscate malware. In this example, two layers of shellcodes were used by the NSIS installer in order to deliver its final payload: a LokiBot password stealer."
                    ],
                    "titles": [
                        "Conclusion",
                        "Stage 3: Lokibot and config extraction"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0x32239007>",
                            "type": "Category",
                            "value": "stealer"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x32239007>",
                            "type": "Category",
                            "value": "stealer"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0xed169ce1>",
                            "type": "Threat",
                            "value": "lokibot_stealer"
                        }
                    }
                ]
            }
        ],
        "CVE": [
            {
                "token": {
                    "id": "<CVE_0x394b0f55>",
                    "type": "CVE",
                    "value": "cve-2018-0798"
                },
                "references": {
                    "sentences": [
                        "The sample we are about to dissect today is an OpenXML Excel document which came as email attachment. The malicious document is very similar to the one we did analyze in our previous blog post: an encrypted OpenXML Excel document embedding an Equation object exploiting CVE-2018-0798. The same author is most likely behind this document as well, they just updated the bait picture:"
                    ],
                    "titles": [
                        "The Excel document"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CVE_0x394b0f55>",
                            "type": "CVE",
                            "value": "cve-2018-0798"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    }
                ],
                "info": {
                    "vulners_score": 9.3,
                    "cvss_score": 9.3,
                    "exploit": "Unknown",
                    "softs": {
                        "microsoft office": [
                            "2010",
                            "2016",
                            "2016",
                            "2007",
                            "2013"
                        ],
                        "microsoft word": [
                            "2013",
                            "2016",
                            "2007",
                            "2010",
                            "2013"
                        ],
                        "microsoft office compatibility pack": [
                            "-"
                        ]
                    },
                    "patch": "official fix",
                    "risk_level": 7.8
                }
            }
        ]
    },
    "iocs": {
        "Url": [
            {
                "token": {
                    "id": "<URL_0x92a1279a>",
                    "type": "Url",
                    "value": "http://103.153.79.104/windows10/csrss.exe"
                },
                "references": {
                    "sentences": [
                        "hxxp://103.153.79.104/windows10/csrss.exe"
                    ],
                    "titles": [
                        "The Excel document"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<URL_0x92a1279a>",
                            "type": "Url",
                            "value": "http://103.153.79.104/windows10/csrss.exe"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    }
                ]
            }
        ],
        "File": [
            {
                "token": {
                    "id": "<FILE_0xde6c2b3>",
                    "type": "File",
                    "value": "csrss.exe"
                },
                "references": {
                    "sentences": [
                        "The file csrss.exe is a 418KB PE file of sha256 291df8186e62df74b8fcf2c361c6913b9b73e3e864dde58eb63d5c3159a4c32d (Bazaar, VT). A NSIS installer is nothing more than a NSIS archive appended to the NSIS PE installer. The file format of the archive, while not very documented, is relatively simple as we will see."
                    ],
                    "titles": [
                        "NSIS installer"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xde6c2b3>",
                            "type": "File",
                            "value": "csrss.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8f472f4d>",
                            "type": "UnknownWord",
                            "value": "418kb"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xde6c2b3>",
                            "type": "File",
                            "value": "csrss.exe"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xde6c2b3>",
                            "type": "File",
                            "value": "csrss.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf5308ba4>",
                            "type": "UnknownWord",
                            "value": "bazaar"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0x88a1f8ba>",
                    "type": "File",
                    "value": "dwksh.dll"
                },
                "references": {
                    "sentences": [
                        "extract the first buffer (offset header+0 in archive) to a file named d54hdan9c9ebsx<crlf>extract the second buffer (offset header+0x34f0f in archive) to a file named lognp<crlf>extract the third buffer (offset header+0x36390 in archive) to ${PLUGINDIR}\\dwksh.dll, wherever that could be<crlf>call dwksh.dll's exported method sdvffryp without any argument",
                        "dwksh.dll is a 294KB 32-bits DLL of sha256 be00a655cdf4e4706bf1bbf3659d698f967cad66acdf7cda0d12f16dc0cfda3e (VT). It contains several obfuscated methods. But we reversed the setup script and know what to look for: the method sdvffryp. This methods starts by reading a local file named lognp:"
                    ],
                    "titles": [
                        "Stage 1: dwksh.dll",
                        "The SETUP script"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x88a1f8ba>",
                            "type": "File",
                            "value": "dwksh.dll"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x88a1f8ba>",
                            "type": "File",
                            "value": "dwksh.dll"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xadbe9c72>",
                            "type": "UnknownWord",
                            "value": "sdvffryp"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x88a1f8ba>",
                            "type": "File",
                            "value": "dwksh.dll"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x229e72c5>",
                            "type": "UnknownWord",
                            "value": "294kb"
                        }
                    }
                ]
            }
        ],
        "Hash": [
            {
                "token": {
                    "id": "<SHA256_0xf49383ae>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "291df8186e62df74b8fcf2c361c6913b9b73e3e864dde58eb63d5c3159a4c32d"
                },
                "references": {
                    "sentences": [
                        "The file csrss.exe is a 418KB PE file of sha256 291df8186e62df74b8fcf2c361c6913b9b73e3e864dde58eb63d5c3159a4c32d (Bazaar, VT). A NSIS installer is nothing more than a NSIS archive appended to the NSIS PE installer. The file format of the archive, while not very documented, is relatively simple as we will see."
                    ],
                    "titles": [
                        "NSIS installer"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xf49383ae>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "291df8186e62df74b8fcf2c361c6913b9b73e3e864dde58eb63d5c3159a4c32d"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf5308ba4>",
                            "type": "UnknownWord",
                            "value": "bazaar"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xf49383ae>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "291df8186e62df74b8fcf2c361c6913b9b73e3e864dde58eb63d5c3159a4c32d"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xf49383ae>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "291df8186e62df74b8fcf2c361c6913b9b73e3e864dde58eb63d5c3159a4c32d"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8f472f4d>",
                            "type": "UnknownWord",
                            "value": "418kb"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0x2a4baf7b>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "be00a655cdf4e4706bf1bbf3659d698f967cad66acdf7cda0d12f16dc0cfda3e"
                },
                "references": {
                    "sentences": [
                        "dwksh.dll is a 294KB 32-bits DLL of sha256 be00a655cdf4e4706bf1bbf3659d698f967cad66acdf7cda0d12f16dc0cfda3e (VT). It contains several obfuscated methods. But we reversed the setup script and know what to look for: the method sdvffryp. This methods starts by reading a local file named lognp:"
                    ],
                    "titles": [
                        "Stage 1: dwksh.dll"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x2a4baf7b>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "be00a655cdf4e4706bf1bbf3659d698f967cad66acdf7cda0d12f16dc0cfda3e"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x229e72c5>",
                            "type": "UnknownWord",
                            "value": "294kb"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x2a4baf7b>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "be00a655cdf4e4706bf1bbf3659d698f967cad66acdf7cda0d12f16dc0cfda3e"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0xe86379a>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "02dee91a81652e5234414e452622307fd61e7988e82bec43665f699f805c3151"
                },
                "references": {
                    "sentences": [
                        "The last (and final) stage we get is a PE file of sha 02dee91a81652e5234414e452622307fd61e7988e82bec43665f699f805c3151 (VT). Judging by the low entropy and the visible strings, the file does not seem to be obfuscated, good news.<crlf>So which kind of malware do we face? Malcat's Yara rules already spotted one of main malware intent: stealing credentials, as we can see in the screenshot below:"
                    ],
                    "titles": [
                        "Stage 3: Lokibot and config extraction"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xe86379a>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "02dee91a81652e5234414e452622307fd61e7988e82bec43665f699f805c3151"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc7bc3592>",
                            "type": "UnknownWord",
                            "value": "sha"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xe86379a>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "02dee91a81652e5234414e452622307fd61e7988e82bec43665f699f805c3151"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xe86379a>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "02dee91a81652e5234414e452622307fd61e7988e82bec43665f699f805c3151"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xed169ce1>",
                            "type": "Threat",
                            "value": "lokibot_stealer"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0xa6e9a9d0>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "e850f3849ea82980cf23844ad3caadf73856b2d5b0c4179847d82ce4016e80ee"
                },
                "references": {
                    "sentences": [
                        "Sample:<crlf>e850f3849ea82980cf23844ad3caadf73856b2d5b0c4179847d82ce4016e80ee ("
                    ],
                    "titles": [
                        "Reversing a NSIS dropper using quick and dirty shellcode emulation"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xa6e9a9d0>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "e850f3849ea82980cf23844ad3caadf73856b2d5b0c4179847d82ce4016e80ee"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xa6e9a9d0>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "e850f3849ea82980cf23844ad3caadf73856b2d5b0c4179847d82ce4016e80ee"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0xb673273e>",
                            "type": "Threat",
                            "value": "nsis_dropper"
                        }
                    }
                ]
            }
        ]
    },
    "unknownwords": {
        "UnknownWord": [
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4f3177cc>",
                    "type": "UnknownWord",
                    "value": "openxml"
                },
                "references": {
                    "sentences": [
                        "The sample we are about to dissect today is an OpenXML Excel document which came as email attachment. The malicious document is very similar to the one we did analyze in our previous blog post: an encrypted OpenXML Excel document embedding an Equation object exploiting CVE-2018-0798. The same author is most likely behind this document as well, they just updated the bait picture:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbdb2df32>",
                    "type": "UnknownWord",
                    "value": "embedding"
                },
                "references": {
                    "sentences": [
                        "The sample we are about to dissect today is an OpenXML Excel document which came as email attachment. The malicious document is very similar to the one we did analyze in our previous blog post: an encrypted OpenXML Excel document embedding an Equation object exploiting CVE-2018-0798. The same author is most likely behind this document as well, they just updated the bait picture:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa4ed261a>",
                    "type": "UnknownWord",
                    "value": "baiting"
                },
                "references": {
                    "sentences": [
                        "Figure 1: Excel sheet baiting the user to deactivate safe mode"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdc39572c>",
                    "type": "UnknownWord",
                    "value": "won"
                },
                "references": {
                    "sentences": [
                        "We won't go through the exploit shellcode extraction and decryption process again since the procedure is exactly the same (see here, shellcode offset is also 0x50). The exploit is again a downloader, downloading from the following url:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x84b96bda>",
                    "type": "UnknownWord",
                    "value": "extraction"
                },
                "references": {
                    "sentences": [
                        "We won't go through the exploit shellcode extraction and decryption process again since the procedure is exactly the same (see here, shellcode offset is also 0x50). The exploit is again a downloader, downloading from the following url:"
                    ],
                    "titles": [
                        "Stage 3: Lokibot and config extraction"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7bf80a4>",
                    "type": "UnknownWord",
                    "value": "offset"
                },
                "references": {
                    "sentences": [
                        "extract the first buffer (offset header+0 in archive) to a file named d54hdan9c9ebsx<crlf>extract the second buffer (offset header+0x34f0f in archive) to a file named lognp<crlf>extract the third buffer (offset header+0x36390 in archive) to ${PLUGINDIR}\\dwksh.dll, wherever that could be<crlf>call dwksh.dll's exported method sdvffryp without any argument",
                        "We won't go through the exploit shellcode extraction and decryption process again since the procedure is exactly the same (see here, shellcode offset is also 0x50). The exploit is again a downloader, downloading from the following url:",
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8f472f4d>",
                    "type": "UnknownWord",
                    "value": "418kb"
                },
                "references": {
                    "sentences": [
                        "The file csrss.exe is a 418KB PE file of sha256 291df8186e62df74b8fcf2c361c6913b9b73e3e864dde58eb63d5c3159a4c32d (Bazaar, VT). A NSIS installer is nothing more than a NSIS archive appended to the NSIS PE installer. The file format of the archive, while not very documented, is relatively simple as we will see."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xde6c2b3>",
                            "type": "File",
                            "value": "csrss.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8f472f4d>",
                            "type": "UnknownWord",
                            "value": "418kb"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xf49383ae>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "291df8186e62df74b8fcf2c361c6913b9b73e3e864dde58eb63d5c3159a4c32d"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8f472f4d>",
                            "type": "UnknownWord",
                            "value": "418kb"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf5308ba4>",
                    "type": "UnknownWord",
                    "value": "bazaar"
                },
                "references": {
                    "sentences": [
                        "The file csrss.exe is a 418KB PE file of sha256 291df8186e62df74b8fcf2c361c6913b9b73e3e864dde58eb63d5c3159a4c32d (Bazaar, VT). A NSIS installer is nothing more than a NSIS archive appended to the NSIS PE installer. The file format of the archive, while not very documented, is relatively simple as we will see.",
                        "Bazaar"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xf49383ae>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "291df8186e62df74b8fcf2c361c6913b9b73e3e864dde58eb63d5c3159a4c32d"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf5308ba4>",
                            "type": "UnknownWord",
                            "value": "bazaar"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xde6c2b3>",
                            "type": "File",
                            "value": "csrss.exe"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xf5308ba4>",
                            "type": "UnknownWord",
                            "value": "bazaar"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x229e72c5>",
                    "type": "UnknownWord",
                    "value": "294kb"
                },
                "references": {
                    "sentences": [
                        "dwksh.dll is a 294KB 32-bits DLL of sha256 be00a655cdf4e4706bf1bbf3659d698f967cad66acdf7cda0d12f16dc0cfda3e (VT). It contains several obfuscated methods. But we reversed the setup script and know what to look for: the method sdvffryp. This methods starts by reading a local file named lognp:"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x2a4baf7b>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "be00a655cdf4e4706bf1bbf3659d698f967cad66acdf7cda0d12f16dc0cfda3e"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x229e72c5>",
                            "type": "UnknownWord",
                            "value": "294kb"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x88a1f8ba>",
                            "type": "File",
                            "value": "dwksh.dll"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x229e72c5>",
                            "type": "UnknownWord",
                            "value": "294kb"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf5c3f820>",
                    "type": "UnknownWord",
                    "value": "reversed"
                },
                "references": {
                    "sentences": [
                        "dwksh.dll is a 294KB 32-bits DLL of sha256 be00a655cdf4e4706bf1bbf3659d698f967cad66acdf7cda0d12f16dc0cfda3e (VT). It contains several obfuscated methods. But we reversed the setup script and know what to look for: the method sdvffryp. This methods starts by reading a local file named lognp:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xadbe9c72>",
                    "type": "UnknownWord",
                    "value": "sdvffryp"
                },
                "references": {
                    "sentences": [
                        "extract the first buffer (offset header+0 in archive) to a file named d54hdan9c9ebsx<crlf>extract the second buffer (offset header+0x34f0f in archive) to a file named lognp<crlf>extract the third buffer (offset header+0x36390 in archive) to ${PLUGINDIR}\\dwksh.dll, wherever that could be<crlf>call dwksh.dll's exported method sdvffryp without any argument",
                        "Figure 5: decryption loop in method sdvffryp",
                        "dwksh.dll is a 294KB 32-bits DLL of sha256 be00a655cdf4e4706bf1bbf3659d698f967cad66acdf7cda0d12f16dc0cfda3e (VT). It contains several obfuscated methods. But we reversed the setup script and know what to look for: the method sdvffryp. This methods starts by reading a local file named lognp:"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x88a1f8ba>",
                            "type": "File",
                            "value": "dwksh.dll"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xadbe9c72>",
                            "type": "UnknownWord",
                            "value": "sdvffryp"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe8248214>",
                    "type": "UnknownWord",
                    "value": "lognp"
                },
                "references": {
                    "sentences": [
                        "dwksh.dll is a 294KB 32-bits DLL of sha256 be00a655cdf4e4706bf1bbf3659d698f967cad66acdf7cda0d12f16dc0cfda3e (VT). It contains several obfuscated methods. But we reversed the setup script and know what to look for: the method sdvffryp. This methods starts by reading a local file named lognp:",
                        "For the lazy readers, you can download the decrypted lognp file here (password: infected).",
                        "Figure 4: lognp file is accessed",
                        "At the end, the patched shellcode should look like in the picture below. For the lazy readers, you can download the patched lognp file here (password: infected).",
                        "It then seems to decrypt it in memory into an executable buffer before jumping at the beginning of the buffer (see the call eax below?). The file lognp is relatively small (5KB), it definitely looks like a shellcode.",
                        "But there is also the dirty way: we could patch the decrypted lognp shellcode in order to embed the content of d54hdan9c9ebsx in the shellcode space and patch the shellcode entry point to perform a call to the decryption function with the right parameters. Of course we will chose the dirty way. It is not only way faster, it is also more fun.",
                        "extract the first buffer (offset header+0 in archive) to a file named d54hdan9c9ebsx<crlf>extract the second buffer (offset header+0x34f0f in archive) to a file named lognp<crlf>extract the third buffer (offset header+0x36390 in archive) to ${PLUGINDIR}\\dwksh.dll, wherever that could be<crlf>call dwksh.dll's exported method sdvffryp without any argument",
                        "Decrypting the lognp file should be a piece of cake. Just open the file inside Malcat, select every byte (Ctrl+A) and open the transform dialog (Ctrl+T). There you can chose the custom arithmetic transform which allows you to transform sequence of bytes/words/dwords using a custom python expression. Just paste the equation above, replacing byte[i] by value and voila, you've just decrypted the second stage.",
                        "The lognp file, once decrypted, does not appear to be in any known file format. But the first byte is E9, which is a jump in the x86 architecture and is very typical for shellcode prologs. So before starting the analysis, we will have to tell Malcat two things:",
                        "First open a copy of the decrypted lognp shellcode in Malcat with extra space at the end of the file (File > Open Copy of File). The file d54hdan9c9ebsx is 216843 bytes big, we'll append 300KB just to be sure.<crlf>Copy the content of the file d54hdan9c9ebsx in the clipboard: in a second Malcat instance, open d54hdan9c9ebsx and then hit Ctrl+A followed by Ctrl+C<crlf>Paste the copied data after the shellcode in the first Malcat instance, let's say at address 0x2000 to make it easy to remember<crlf>Enter disassembly view (F3) and go to the shellcode's entry point at address 0"
                    ],
                    "titles": [
                        "Patching lognp"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xedd6f487>",
                    "type": "UnknownWord",
                    "value": "accessed"
                },
                "references": {
                    "sentences": [
                        "Figure 4: lognp file is accessed"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe4f4a2d1>",
                    "type": "UnknownWord",
                    "value": "jumping"
                },
                "references": {
                    "sentences": [
                        "It then seems to decrypt it in memory into an executable buffer before jumping at the beginning of the buffer (see the call eax below?). The file lognp is relatively small (5KB), it definitely looks like a shellcode."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x436c4190>",
                    "type": "UnknownWord",
                    "value": "eax"
                },
                "references": {
                    "sentences": [
                        "It then seems to decrypt it in memory into an executable buffer before jumping at the beginning of the buffer (see the call eax below?). The file lognp is relatively small (5KB), it definitely looks like a shellcode."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x623375ab>",
                    "type": "UnknownWord",
                    "value": "definitely"
                },
                "references": {
                    "sentences": [
                        "It then seems to decrypt it in memory into an executable buffer before jumping at the beginning of the buffer (see the call eax below?). The file lognp is relatively small (5KB), it definitely looks like a shellcode."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5a686885>",
                    "type": "UnknownWord",
                    "value": "sleigh"
                },
                "references": {
                    "sentences": [
                        "The decryption is pretty straightforward according to the sleigh decompiler. Every byte seem to be decrypted using the following formula:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x30251f7d>",
                    "type": "UnknownWord",
                    "value": "decompiler"
                },
                "references": {
                    "sentences": [
                        "The decryption is pretty straightforward according to the sleigh decompiler. Every byte seem to be decrypted using the following formula:",
                        "Luckily for us, the full edition of Malcat features a NSIS disassembler / decompiler, so let us jump directly to the entry point of the script (Ctrl+E) and have a look at the OnInit method:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf2a893cc>",
                    "type": "UnknownWord",
                    "value": "cake"
                },
                "references": {
                    "sentences": [
                        "Decrypting the lognp file should be a piece of cake. Just open the file inside Malcat, select every byte (Ctrl+A) and open the transform dialog (Ctrl+T). There you can chose the custom arithmetic transform which allows you to transform sequence of bytes/words/dwords using a custom python expression. Just paste the equation above, replacing byte[i] by value and voila, you've just decrypted the second stage."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x734feb2b>",
                    "type": "UnknownWord",
                    "value": "malcat"
                },
                "references": {
                    "sentences": [
                        "Malcat does not (yet) support assembling your own instruction, so we will need to manually edit the machine code. Click on any hexa byte in disasm mode and enter edit mode (Insert key). We need to assemble the following code:",
                        "After this, Malcat is smart enough to recover most of the shellcode's CFG using its usual set of analyses. Following the control flow, we quickly arrive in the function sub_7dd which contains interesting patterns:",
                        "The first file is always the installer setup script, followed by user-provided files and/or installer plugins. As you can see, Malcat did give name to some of the files (all but the last one) which somehow contradicts what I said before. But these names have been recovered by reversing the SETUP script, and there is no guarantee that it is the real name for these files. Even worse, a buffer in the archive can be extracted under different names on the local filesystem, so don't trust these names 100%.",
                        "Instead of running everything in a VM, we made great use of Malcat's NSIS disassembler, Malcat's transforms and speakeasy emulator in order to quickly unpack these two layers statically.",
                        "Malcat",
                        "... and voila, Malcat should open the result in a new file. A PE file has been detected by Malcat's file format parser at address 0x2000, perfect! Just double-click the PE file under \"Carved Files\" to open it.",
                        "You can use Malcat's calculator to perform quick computation while analysing a binary, just hit Shift+Ctrl+C. Internally, it uses the python interpreter, so use python syntax.",
                        "We hope you enjoyed this new quick-and-dirty malware unpacking sessions. Future blog posts will be more focused toward beginners as we will introduce a few of Malcat's features as in-depth tutorials.",
                        "To emulate shellcodes, Malcat comes bundled with a script named speakeay_shellcode.py which emulates shellcodes using the Speakeasy emulator. Note that Speakeasy is not bundled with Malcat, you will have to install the python package yourself (and if you are running Malcat under Windows, be sure to check Use system python interpreter in the options).",
                        "Luckily for us, the full edition of Malcat features a NSIS disassembler / decompiler, so let us jump directly to the entry point of the script (Ctrl+E) and have a look at the OnInit method:",
                        "The code of the decryption function is given below. It is obviously obfuscated, and sadly it would not be immediate to reimplement it in python in Malcat. So we will have to find an alternative. Since the decryption function prototype is very simple (it just needs a pointer to the buffer and the buffer size) and is without side effects, why not give emulation a go?",
                        "The last (and final) stage we get is a PE file of sha 02dee91a81652e5234414e452622307fd61e7988e82bec43665f699f805c3151 (VT). Judging by the low entropy and the visible strings, the file does not seem to be obfuscated, good news.<crlf>So which kind of malware do we face? Malcat's Yara rules already spotted one of main malware intent: stealing credentials, as we can see in the screenshot below:",
                        "Can we go further? The last section of the PE file is weirdly named \".x\". It contains a single method at address 0x4a0000 and a few bytes of referenced data at address 0x4a0074. Looking at the function, it seems to decode the data using a XOR opcode, with the key 0xDDDDFFFF. But actually, only the first byte of the key is used (0xFF), so it is strictly equivalent to performing a simple NOT on the data. Great, let us decrypt these few bytes using Malcat's transform:",
                        "Decrypting the lognp file should be a piece of cake. Just open the file inside Malcat, select every byte (Ctrl+A) and open the transform dialog (Ctrl+T). There you can chose the custom arithmetic transform which allows you to transform sequence of bytes/words/dwords using a custom python expression. Just paste the equation above, replacing byte[i] by value and voila, you've just decrypted the second stage.",
                        "The lognp file, once decrypted, does not appear to be in any known file format. But the first byte is E9, which is a jump in the x86 architecture and is very typical for shellcode prologs. So before starting the analysis, we will have to tell Malcat two things:",
                        "If we want to be more precise, we can use Malcat's online intelligence view (Ctrl+I, only for paid versions). Normally I would avoid using Virustotal to identify a malware family (because of packer reuse among threat actors). But here we are dealing with the plain text final malware, so we should get at least some valid labels. In our case, it seems to be Lokibot, a simple password stealer:",
                        "Malcat supports NSIS files using both solid and non-solid mode for the Zlib and LZMA compression methods, but lacks support for bzip2, since the compression algorithm is custom. But since it's also the least used one, it's not really a big deal. The NSIS archive we are looking at is a solid LZMA archive, so unpacking it is no issue. Like for most archive formats, Malcat lists found files in the upper left corner of the screen, under the Virtual File System tree. Double-clicking on a file opens it inside Malcat.",
                        "First open a copy of the decrypted lognp shellcode in Malcat with extra space at the end of the file (File > Open Copy of File). The file d54hdan9c9ebsx is 216843 bytes big, we'll append 300KB just to be sure.<crlf>Copy the content of the file d54hdan9c9ebsx in the clipboard: in a second Malcat instance, open d54hdan9c9ebsx and then hit Ctrl+A followed by Ctrl+C<crlf>Paste the copied data after the shellcode in the first Malcat instance, let's say at address 0x2000 to make it easy to remember<crlf>Enter disassembly view (F3) and go to the shellcode's entry point at address 0"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xddd85a90>",
                    "type": "UnknownWord",
                    "value": "ctrl"
                },
                "references": {
                    "sentences": [
                        "let us define the entry point: right-click at address 0 and chose Force function start in the context menu<crlf>run the script speakeasy_shellcode.py (Ctrl+U to run user scripts)",
                        "You can use Malcat's calculator to perform quick computation while analysing a binary, just hit Shift+Ctrl+C. Internally, it uses the python interpreter, so use python syntax.",
                        "Luckily for us, the full edition of Malcat features a NSIS disassembler / decompiler, so let us jump directly to the entry point of the script (Ctrl+E) and have a look at the OnInit method:",
                        "Decrypting the lognp file should be a piece of cake. Just open the file inside Malcat, select every byte (Ctrl+A) and open the transform dialog (Ctrl+T). There you can chose the custom arithmetic transform which allows you to transform sequence of bytes/words/dwords using a custom python expression. Just paste the equation above, replacing byte[i] by value and voila, you've just decrypted the second stage.",
                        "If we want to be more precise, we can use Malcat's online intelligence view (Ctrl+I, only for paid versions). Normally I would avoid using Virustotal to identify a malware family (because of packer reuse among threat actors). But here we are dealing with the plain text final malware, so we should get at least some valid labels. In our case, it seems to be Lokibot, a simple password stealer:",
                        "First open a copy of the decrypted lognp shellcode in Malcat with extra space at the end of the file (File > Open Copy of File). The file d54hdan9c9ebsx is 216843 bytes big, we'll append 300KB just to be sure.<crlf>Copy the content of the file d54hdan9c9ebsx in the clipboard: in a second Malcat instance, open d54hdan9c9ebsx and then hit Ctrl+A followed by Ctrl+C<crlf>Paste the copied data after the shellcode in the first Malcat instance, let's say at address 0x2000 to make it easy to remember<crlf>Enter disassembly view (F3) and go to the shellcode's entry point at address 0"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xceb9971a>",
                    "type": "UnknownWord",
                    "value": "transform"
                },
                "references": {
                    "sentences": [
                        "Can we go further? The last section of the PE file is weirdly named \".x\". It contains a single method at address 0x4a0000 and a few bytes of referenced data at address 0x4a0074. Looking at the function, it seems to decode the data using a XOR opcode, with the key 0xDDDDFFFF. But actually, only the first byte of the key is used (0xFF), so it is strictly equivalent to performing a simple NOT on the data. Great, let us decrypt these few bytes using Malcat's transform:",
                        "Decrypting the lognp file should be a piece of cake. Just open the file inside Malcat, select every byte (Ctrl+A) and open the transform dialog (Ctrl+T). There you can chose the custom arithmetic transform which allows you to transform sequence of bytes/words/dwords using a custom python expression. Just paste the equation above, replacing byte[i] by value and voila, you've just decrypted the second stage."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6a9c94e2>",
                    "type": "UnknownWord",
                    "value": "dialog"
                },
                "references": {
                    "sentences": [
                        "Decrypting the lognp file should be a piece of cake. Just open the file inside Malcat, select every byte (Ctrl+A) and open the transform dialog (Ctrl+T). There you can chose the custom arithmetic transform which allows you to transform sequence of bytes/words/dwords using a custom python expression. Just paste the equation above, replacing byte[i] by value and voila, you've just decrypted the second stage."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7b7e4af4>",
                    "type": "UnknownWord",
                    "value": "voila"
                },
                "references": {
                    "sentences": [
                        "... and voila, Malcat should open the result in a new file. A PE file has been detected by Malcat's file format parser at address 0x2000, perfect! Just double-click the PE file under \"Carved Files\" to open it.",
                        "Decrypting the lognp file should be a piece of cake. Just open the file inside Malcat, select every byte (Ctrl+A) and open the transform dialog (Ctrl+T). There you can chose the custom arithmetic transform which allows you to transform sequence of bytes/words/dwords using a custom python expression. Just paste the equation above, replacing byte[i] by value and voila, you've just decrypted the second stage."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5d541cee>",
                    "type": "UnknownWord",
                    "value": "lazy"
                },
                "references": {
                    "sentences": [
                        "At the end, the patched shellcode should look like in the picture below. For the lazy readers, you can download the patched lognp file here (password: infected).",
                        "For the lazy readers, you can download the decrypted lognp file here (password: infected)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc7bc3592>",
                    "type": "UnknownWord",
                    "value": "sha"
                },
                "references": {
                    "sentences": [
                        "The last (and final) stage we get is a PE file of sha 02dee91a81652e5234414e452622307fd61e7988e82bec43665f699f805c3151 (VT). Judging by the low entropy and the visible strings, the file does not seem to be obfuscated, good news.<crlf>So which kind of malware do we face? Malcat's Yara rules already spotted one of main malware intent: stealing credentials, as we can see in the screenshot below:"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xe86379a>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "02dee91a81652e5234414e452622307fd61e7988e82bec43665f699f805c3151"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc7bc3592>",
                            "type": "UnknownWord",
                            "value": "sha"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7884deda>",
                    "type": "UnknownWord",
                    "value": "judging"
                },
                "references": {
                    "sentences": [
                        "The rest of the method seems like junk code, judging by the strings which are either random letters or picked out of dictionary. Quickly inspecting the first two files tells us that both are encrypted and/or compressed, so no quick-win there. We have to dig into the dll.",
                        "The last (and final) stage we get is a PE file of sha 02dee91a81652e5234414e452622307fd61e7988e82bec43665f699f805c3151 (VT). Judging by the low entropy and the visible strings, the file does not seem to be obfuscated, good news.<crlf>So which kind of malware do we face? Malcat's Yara rules already spotted one of main malware intent: stealing credentials, as we can see in the screenshot below:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9f1ab300>",
                    "type": "UnknownWord",
                    "value": "entropy"
                },
                "references": {
                    "sentences": [
                        "The last (and final) stage we get is a PE file of sha 02dee91a81652e5234414e452622307fd61e7988e82bec43665f699f805c3151 (VT). Judging by the low entropy and the visible strings, the file does not seem to be obfuscated, good news.<crlf>So which kind of malware do we face? Malcat's Yara rules already spotted one of main malware intent: stealing credentials, as we can see in the screenshot below:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9fb3368a>",
                    "type": "UnknownWord",
                    "value": "intent"
                },
                "references": {
                    "sentences": [
                        "The last (and final) stage we get is a PE file of sha 02dee91a81652e5234414e452622307fd61e7988e82bec43665f699f805c3151 (VT). Judging by the low entropy and the visible strings, the file does not seem to be obfuscated, good news.<crlf>So which kind of malware do we face? Malcat's Yara rules already spotted one of main malware intent: stealing credentials, as we can see in the screenshot below:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa1646ff5>",
                    "type": "UnknownWord",
                    "value": "displaying"
                },
                "references": {
                    "sentences": [
                        "Figure 10: file summary, displaying matching Yara rules"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd4613f5c>",
                    "type": "UnknownWord",
                    "value": "precise"
                },
                "references": {
                    "sentences": [
                        "If we want to be more precise, we can use Malcat's online intelligence view (Ctrl+I, only for paid versions). Normally I would avoid using Virustotal to identify a malware family (because of packer reuse among threat actors). But here we are dealing with the plain text final malware, so we should get at least some valid labels. In our case, it seems to be Lokibot, a simple password stealer:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3f27288e>",
                    "type": "UnknownWord",
                    "value": "normally"
                },
                "references": {
                    "sentences": [
                        "If we want to be more precise, we can use Malcat's online intelligence view (Ctrl+I, only for paid versions). Normally I would avoid using Virustotal to identify a malware family (because of packer reuse among threat actors). But here we are dealing with the plain text final malware, so we should get at least some valid labels. In our case, it seems to be Lokibot, a simple password stealer:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd04412ad>",
                    "type": "UnknownWord",
                    "value": "querying"
                },
                "references": {
                    "sentences": [
                        "Figure 11: querying online intelligence"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xea7a3054>",
                    "type": "UnknownWord",
                    "value": "weirdly"
                },
                "references": {
                    "sentences": [
                        "Can we go further? The last section of the PE file is weirdly named \".x\". It contains a single method at address 0x4a0000 and a few bytes of referenced data at address 0x4a0074. Looking at the function, it seems to decode the data using a XOR opcode, with the key 0xDDDDFFFF. But actually, only the first byte of the key is used (0xFF), so it is strictly equivalent to performing a simple NOT on the data. Great, let us decrypt these few bytes using Malcat's transform:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb7c96729>",
                    "type": "UnknownWord",
                    "value": "opcode"
                },
                "references": {
                    "sentences": [
                        "Can we go further? The last section of the PE file is weirdly named \".x\". It contains a single method at address 0x4a0000 and a few bytes of referenced data at address 0x4a0074. Looking at the function, it seems to decode the data using a XOR opcode, with the key 0xDDDDFFFF. But actually, only the first byte of the key is used (0xFF), so it is strictly equivalent to performing a simple NOT on the data. Great, let us decrypt these few bytes using Malcat's transform:",
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"",
                        "Push the second parameter which is the size of the buffer to decrypt (216843 = 0x34F0B). push uint32 is assembled using 0x68 + LSB-encoded uint32 in x86: 68 0B 4F 03 00<crlf>Push the first parameter which is the address of the buffer to decrypt (0x2000): 68 00 20 00 00<crlf>Call to the decryption function. The call opcode is 0xE8 + signed displacement starting from the end of the call opcode. The end of our call opcode is at address 0x000F, we want to jump to 0x0A01, so 0x0A01 - 0x000F = 0x09f2. We need to assemble E8 F2 09 00 00."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfe3c6312>",
                    "type": "UnknownWord",
                    "value": "strictly"
                },
                "references": {
                    "sentences": [
                        "Can we go further? The last section of the PE file is weirdly named \".x\". It contains a single method at address 0x4a0000 and a few bytes of referenced data at address 0x4a0074. Looking at the function, it seems to decode the data using a XOR opcode, with the key 0xDDDDFFFF. But actually, only the first byte of the key is used (0xFF), so it is strictly equivalent to performing a simple NOT on the data. Great, let us decrypt these few bytes using Malcat's transform:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x44e335ca>",
                    "type": "UnknownWord",
                    "value": "equivalent"
                },
                "references": {
                    "sentences": [
                        "Can we go further? The last section of the PE file is weirdly named \".x\". It contains a single method at address 0x4a0000 and a few bytes of referenced data at address 0x4a0074. Looking at the function, it seems to decode the data using a XOR opcode, with the key 0xDDDDFFFF. But actually, only the first byte of the key is used (0xFF), so it is strictly equivalent to performing a simple NOT on the data. Great, let us decrypt these few bytes using Malcat's transform:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x133f51b6>",
                    "type": "UnknownWord",
                    "value": "transforms"
                },
                "references": {
                    "sentences": [
                        "Instead of running everything in a VM, we made great use of Malcat's NSIS disassembler, Malcat's transforms and speakeasy emulator in order to quickly unpack these two layers statically."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbff3332d>",
                    "type": "UnknownWord",
                    "value": "speakeasy"
                },
                "references": {
                    "sentences": [
                        "Now the only thing we have to do is to let speakeasy do its magic:",
                        "Instead of running everything in a VM, we made great use of Malcat's NSIS disassembler, Malcat's transforms and speakeasy emulator in order to quickly unpack these two layers statically.",
                        "To emulate shellcodes, Malcat comes bundled with a script named speakeay_shellcode.py which emulates shellcodes using the Speakeasy emulator. Note that Speakeasy is not bundled with Malcat, you will have to install the python package yourself (and if you are running Malcat under Windows, be sure to check Use system python interpreter in the options).",
                        "Speakeasy emulator",
                        "There is the clean way: we could hook the CreateFileA/ReadFile APIs in speakeasy and intercept the call to give back the content of the file d54hdan9c9ebsx."
                    ],
                    "titles": [
                        "Running speakeasy"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc832e23c>",
                    "type": "UnknownWord",
                    "value": "unpack"
                },
                "references": {
                    "sentences": [
                        "Instead of running everything in a VM, we made great use of Malcat's NSIS disassembler, Malcat's transforms and speakeasy emulator in order to quickly unpack these two layers statically."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdbf9d535>",
                    "type": "UnknownWord",
                    "value": "hope"
                },
                "references": {
                    "sentences": [
                        "We hope you enjoyed this new quick-and-dirty malware unpacking sessions. Future blog posts will be more focused toward beginners as we will introduce a few of Malcat's features as in-depth tutorials."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x77fe14fb>",
                    "type": "UnknownWord",
                    "value": "quick-and-dirty"
                },
                "references": {
                    "sentences": [
                        "We hope you enjoyed this new quick-and-dirty malware unpacking sessions. Future blog posts will be more focused toward beginners as we will introduce a few of Malcat's features as in-depth tutorials."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x72524b90>",
                    "type": "UnknownWord",
                    "value": "unpacking"
                },
                "references": {
                    "sentences": [
                        "We hope you enjoyed this new quick-and-dirty malware unpacking sessions. Future blog posts will be more focused toward beginners as we will introduce a few of Malcat's features as in-depth tutorials."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x57b23fa4>",
                    "type": "UnknownWord",
                    "value": "toward"
                },
                "references": {
                    "sentences": [
                        "We hope you enjoyed this new quick-and-dirty malware unpacking sessions. Future blog posts will be more focused toward beginners as we will introduce a few of Malcat's features as in-depth tutorials."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xae3fa25f>",
                    "type": "UnknownWord",
                    "value": "beginners"
                },
                "references": {
                    "sentences": [
                        "We hope you enjoyed this new quick-and-dirty malware unpacking sessions. Future blog posts will be more focused toward beginners as we will introduce a few of Malcat's features as in-depth tutorials."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x479d6fbd>",
                    "type": "UnknownWord",
                    "value": "tutorials"
                },
                "references": {
                    "sentences": [
                        "We hope you enjoyed this new quick-and-dirty malware unpacking sessions. Future blog posts will be more focused toward beginners as we will introduce a few of Malcat's features as in-depth tutorials."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x43b1861e>",
                    "type": "UnknownWord",
                    "value": "stylesheet"
                },
                "references": {
                    "sentences": [
                        ")<crlf>Infection chain:<crlf>Excel stylesheet -> Office equation -> Shellcode (downloader) -> NSIS installer -> Shellcode (stage 1) -> Shellcode (stage 2) -> Lokibot<crlf>Tools used:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb9a1320d>",
                    "type": "UnknownWord",
                    "value": "->"
                },
                "references": {
                    "sentences": [
                        ")<crlf>Infection chain:<crlf>Excel stylesheet -> Office equation -> Shellcode (downloader) -> NSIS installer -> Shellcode (stage 1) -> Shellcode (stage 2) -> Lokibot<crlf>Tools used:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3fbcd7a>",
                    "type": "UnknownWord",
                    "value": "difficulty"
                },
                "references": {
                    "sentences": [
                        "Difficulty:<crlf>Easy"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8d24d1d>",
                    "type": "UnknownWord",
                    "value": "tell"
                },
                "references": {
                    "sentences": [
                        "Like you can see, it does not tell us a lot. Directly following the headers come the \"files\". I say \"files\" because they don't really have names, it is more like a list of data bytes or buffers. The files are compressed, and can be stored using two modes:",
                        "The lognp file, once decrypted, does not appear to be in any known file format. But the first byte is E9, which is a jump in the x86 architecture and is very typical for shellcode prologs. So before starting the analysis, we will have to tell Malcat two things:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xaf83929f>",
                    "type": "UnknownWord",
                    "value": "stream"
                },
                "references": {
                    "sentences": [
                        "the solid mode: archive content is a single compressed stream. The unpacked stream is a sequence of N buffers, where each buffer is prefixed by a DWORD telling the size of the buffer.<crlf>the non-solid mode: archive content is a sequence of N compressed streams, one for each file. Each compressed stream is prefixed by a DWORD telling the size of the stream."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x488615ae>",
                    "type": "UnknownWord",
                    "value": "prefixed"
                },
                "references": {
                    "sentences": [
                        "the solid mode: archive content is a single compressed stream. The unpacked stream is a sequence of N buffers, where each buffer is prefixed by a DWORD telling the size of the buffer.<crlf>the non-solid mode: archive content is a sequence of N compressed streams, one for each file. Each compressed stream is prefixed by a DWORD telling the size of the stream."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9f929de9>",
                    "type": "UnknownWord",
                    "value": "non-solid"
                },
                "references": {
                    "sentences": [
                        "There is sadly no flag in the header telling us which mode is used, this information is hardcoded inside the NSIS installer executable. The only solution there is trial and error: if the start of the archive starts with a DWORD which could be a size, then it's most likely the non-solid mode. If it looks like a compression header, then it's most likely the solid mode. And regarding compression, NSIS supports three compression algorithms:",
                        "Malcat supports NSIS files using both solid and non-solid mode for the Zlib and LZMA compression methods, but lacks support for bzip2, since the compression algorithm is custom. But since it's also the least used one, it's not really a big deal. The NSIS archive we are looking at is a solid LZMA archive, so unpacking it is no issue. Like for most archive formats, Malcat lists found files in the upper left corner of the screen, under the Virtual File System tree. Double-clicking on a file opens it inside Malcat.",
                        "the solid mode: archive content is a single compressed stream. The unpacked stream is a sequence of N buffers, where each buffer is prefixed by a DWORD telling the size of the buffer.<crlf>the non-solid mode: archive content is a sequence of N compressed streams, one for each file. Each compressed stream is prefixed by a DWORD telling the size of the stream."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x752fa3b2>",
                    "type": "UnknownWord",
                    "value": "streams"
                },
                "references": {
                    "sentences": [
                        "the solid mode: archive content is a single compressed stream. The unpacked stream is a sequence of N buffers, where each buffer is prefixed by a DWORD telling the size of the buffer.<crlf>the non-solid mode: archive content is a sequence of N compressed streams, one for each file. Each compressed stream is prefixed by a DWORD telling the size of the stream."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6b3eeaba>",
                    "type": "UnknownWord",
                    "value": "sadly"
                },
                "references": {
                    "sentences": [
                        "There is sadly no flag in the header telling us which mode is used, this information is hardcoded inside the NSIS installer executable. The only solution there is trial and error: if the start of the archive starts with a DWORD which could be a size, then it's most likely the non-solid mode. If it looks like a compression header, then it's most likely the solid mode. And regarding compression, NSIS supports three compression algorithms:",
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdeb72ed9>",
                    "type": "UnknownWord",
                    "value": "trial"
                },
                "references": {
                    "sentences": [
                        "There is sadly no flag in the header telling us which mode is used, this information is hardcoded inside the NSIS installer executable. The only solution there is trial and error: if the start of the archive starts with a DWORD which could be a size, then it's most likely the non-solid mode. If it looks like a compression header, then it's most likely the solid mode. And regarding compression, NSIS supports three compression algorithms:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3c35fb7d>",
                    "type": "UnknownWord",
                    "value": "lzma"
                },
                "references": {
                    "sentences": [
                        "LZMA (without headers)<crlf>Zlib<crlf>A custom bzip2 compression algorithm",
                        "Malcat supports NSIS files using both solid and non-solid mode for the Zlib and LZMA compression methods, but lacks support for bzip2, since the compression algorithm is custom. But since it's also the least used one, it's not really a big deal. The NSIS archive we are looking at is a solid LZMA archive, so unpacking it is no issue. Like for most archive formats, Malcat lists found files in the upper left corner of the screen, under the Virtual File System tree. Double-clicking on a file opens it inside Malcat."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1ecab03b>",
                    "type": "UnknownWord",
                    "value": "zlib"
                },
                "references": {
                    "sentences": [
                        "LZMA (without headers)<crlf>Zlib<crlf>A custom bzip2 compression algorithm",
                        "Malcat supports NSIS files using both solid and non-solid mode for the Zlib and LZMA compression methods, but lacks support for bzip2, since the compression algorithm is custom. But since it's also the least used one, it's not really a big deal. The NSIS archive we are looking at is a solid LZMA archive, so unpacking it is no issue. Like for most archive formats, Malcat lists found files in the upper left corner of the screen, under the Virtual File System tree. Double-clicking on a file opens it inside Malcat."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1eb3585c>",
                    "type": "UnknownWord",
                    "value": "bzip2"
                },
                "references": {
                    "sentences": [
                        "LZMA (without headers)<crlf>Zlib<crlf>A custom bzip2 compression algorithm",
                        "Malcat supports NSIS files using both solid and non-solid mode for the Zlib and LZMA compression methods, but lacks support for bzip2, since the compression algorithm is custom. But since it's also the least used one, it's not really a big deal. The NSIS archive we are looking at is a solid LZMA archive, so unpacking it is no issue. Like for most archive formats, Malcat lists found files in the upper left corner of the screen, under the Virtual File System tree. Double-clicking on a file opens it inside Malcat."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9342b4cf>",
                    "type": "UnknownWord",
                    "value": "deal"
                },
                "references": {
                    "sentences": [
                        "Malcat supports NSIS files using both solid and non-solid mode for the Zlib and LZMA compression methods, but lacks support for bzip2, since the compression algorithm is custom. But since it's also the least used one, it's not really a big deal. The NSIS archive we are looking at is a solid LZMA archive, so unpacking it is no issue. Like for most archive formats, Malcat lists found files in the upper left corner of the screen, under the Virtual File System tree. Double-clicking on a file opens it inside Malcat."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x88c04e22>",
                    "type": "UnknownWord",
                    "value": "corner"
                },
                "references": {
                    "sentences": [
                        "Malcat supports NSIS files using both solid and non-solid mode for the Zlib and LZMA compression methods, but lacks support for bzip2, since the compression algorithm is custom. But since it's also the least used one, it's not really a big deal. The NSIS archive we are looking at is a solid LZMA archive, so unpacking it is no issue. Like for most archive formats, Malcat lists found files in the upper left corner of the screen, under the Virtual File System tree. Double-clicking on a file opens it inside Malcat."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd0752dd8>",
                    "type": "UnknownWord",
                    "value": "tree"
                },
                "references": {
                    "sentences": [
                        "Malcat supports NSIS files using both solid and non-solid mode for the Zlib and LZMA compression methods, but lacks support for bzip2, since the compression algorithm is custom. But since it's also the least used one, it's not really a big deal. The NSIS archive we are looking at is a solid LZMA archive, so unpacking it is no issue. Like for most archive formats, Malcat lists found files in the upper left corner of the screen, under the Virtual File System tree. Double-clicking on a file opens it inside Malcat."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x51236b87>",
                    "type": "UnknownWord",
                    "value": "double-clicking"
                },
                "references": {
                    "sentences": [
                        "Malcat supports NSIS files using both solid and non-solid mode for the Zlib and LZMA compression methods, but lacks support for bzip2, since the compression algorithm is custom. But since it's also the least used one, it's not really a big deal. The NSIS archive we are looking at is a solid LZMA archive, so unpacking it is no issue. Like for most archive formats, Malcat lists found files in the upper left corner of the screen, under the Virtual File System tree. Double-clicking on a file opens it inside Malcat."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x84853c1a>",
                    "type": "UnknownWord",
                    "value": "user-provided"
                },
                "references": {
                    "sentences": [
                        "The first file is always the installer setup script, followed by user-provided files and/or installer plugins. As you can see, Malcat did give name to some of the files (all but the last one) which somehow contradicts what I said before. But these names have been recovered by reversing the SETUP script, and there is no guarantee that it is the real name for these files. Even worse, a buffer in the archive can be extracted under different names on the local filesystem, so don't trust these names 100%."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8ace4fc4>",
                    "type": "UnknownWord",
                    "value": "somehow"
                },
                "references": {
                    "sentences": [
                        "The first file is always the installer setup script, followed by user-provided files and/or installer plugins. As you can see, Malcat did give name to some of the files (all but the last one) which somehow contradicts what I said before. But these names have been recovered by reversing the SETUP script, and there is no guarantee that it is the real name for these files. Even worse, a buffer in the archive can be extracted under different names on the local filesystem, so don't trust these names 100%."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2b6a4472>",
                    "type": "UnknownWord",
                    "value": "contradicts"
                },
                "references": {
                    "sentences": [
                        "The first file is always the installer setup script, followed by user-provided files and/or installer plugins. As you can see, Malcat did give name to some of the files (all but the last one) which somehow contradicts what I said before. But these names have been recovered by reversing the SETUP script, and there is no guarantee that it is the real name for these files. Even worse, a buffer in the archive can be extracted under different names on the local filesystem, so don't trust these names 100%."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5078f807>",
                    "type": "UnknownWord",
                    "value": "guarantee"
                },
                "references": {
                    "sentences": [
                        "The first file is always the installer setup script, followed by user-provided files and/or installer plugins. As you can see, Malcat did give name to some of the files (all but the last one) which somehow contradicts what I said before. But these names have been recovered by reversing the SETUP script, and there is no guarantee that it is the real name for these files. Even worse, a buffer in the archive can be extracted under different names on the local filesystem, so don't trust these names 100%."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8a2c480>",
                    "type": "UnknownWord",
                    "value": "worse"
                },
                "references": {
                    "sentences": [
                        "The first file is always the installer setup script, followed by user-provided files and/or installer plugins. As you can see, Malcat did give name to some of the files (all but the last one) which somehow contradicts what I said before. But these names have been recovered by reversing the SETUP script, and there is no guarantee that it is the real name for these files. Even worse, a buffer in the archive can be extracted under different names on the local filesystem, so don't trust these names 100%."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdc05298a>",
                    "type": "UnknownWord",
                    "value": "bunch"
                },
                "references": {
                    "sentences": [
                        "The first thing to look at when reversing a NSIS installer is the setup script. NSIS scripts are a bunch of sections and assembly code written for the NSIS virtual machine. The NSIS VM architecture is relatively simple:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa48ee11f>",
                    "type": "UnknownWord",
                    "value": "assembly"
                },
                "references": {
                    "sentences": [
                        "The first thing to look at when reversing a NSIS installer is the setup script. NSIS scripts are a bunch of sections and assembly code written for the NSIS virtual machine. The NSIS VM architecture is relatively simple:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1cbb693c>",
                    "type": "UnknownWord",
                    "value": "opcodes"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5d5f3c45>",
                    "type": "UnknownWord",
                    "value": "encode"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf4beaaa4>",
                    "type": "UnknownWord",
                    "value": "exepath"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1a246b36>",
                    "type": "UnknownWord",
                    "value": "cmdline"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x60dcc10c>",
                    "type": "UnknownWord",
                    "value": "read-only"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfd464d56>",
                    "type": "UnknownWord",
                    "value": "var0"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe7ddef2d>",
                    "type": "UnknownWord",
                    "value": "varn"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1490e2a5>",
                    "type": "UnknownWord",
                    "value": "jump-like"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x761a8528>",
                    "type": "UnknownWord",
                    "value": "precisely"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9c6a38db>",
                    "type": "UnknownWord",
                    "value": "somewhat"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x69498a18>",
                    "type": "UnknownWord",
                    "value": "ansi"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6c66868a>",
                    "type": "UnknownWord",
                    "value": "park"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xaccd0746>",
                    "type": "UnknownWord",
                    "value": "mix"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb3a7d5f1>",
                    "type": "UnknownWord",
                    "value": "unicode"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc9740a34>",
                    "type": "UnknownWord",
                    "value": "var"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x51c4de>",
                    "type": "UnknownWord",
                    "value": "lang"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6942624>",
                    "type": "UnknownWord",
                    "value": "instdir"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd45a5e45>",
                    "type": "UnknownWord",
                    "value": "rampage"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf25c54d8>",
                    "type": "UnknownWord",
                    "value": "goodie"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbe830882>",
                    "type": "UnknownWord",
                    "value": "noticeably"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xecd116b8>",
                    "type": "UnknownWord",
                    "value": "tif"
                },
                "references": {
                    "sentences": [
                        "Every instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70 different opcodes) and the other 6 DWORD encode arguments<crlf>Depending on the opcode, arguments can be either: a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants) a global variable: $var0 .. $varN an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes a string, more precisely an index into the Strings section of the setup script<crlf>a register (up to 31 registers): $0 .. $9, $R0 .. $R9 or one of 11 specific registers like $EXEPATH or $CMDLINE (some are read-only, so more like constants)<crlf>a global variable: $var0 .. $varN<crlf>an integer, signed or unsigned. It can also be an offset into the code section for jump-like opcodes<crlf>a string, more precisely an index into the Strings section of the setup script<crlf>Strings themselves can be somewhat complex to parse/interpret: there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used. strings can contains any of 4 special opcodes: skip, shell, var or lang strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"<crlf>there are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and unicode. Each version encodes strings differently. There is sadly no flag telling you which version is used.<crlf>strings can contains any of 4 special opcodes: skip, shell, var or lang<crlf>strings can include reference to system paths, variables or other strings, e.g. \"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf175665e>",
                    "type": "UnknownWord",
                    "value": "luckily"
                },
                "references": {
                    "sentences": [
                        "Luckily for us, the full edition of Malcat features a NSIS disassembler / decompiler, so let us jump directly to the entry point of the script (Ctrl+E) and have a look at the OnInit method:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb716e0bd>",
                    "type": "UnknownWord",
                    "value": "oninit"
                },
                "references": {
                    "sentences": [
                        "Luckily for us, the full edition of Malcat features a NSIS disassembler / decompiler, so let us jump directly to the entry point of the script (Ctrl+E) and have a look at the OnInit method:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa0763844>",
                    "type": "UnknownWord",
                    "value": "d54hdan9c9ebsx"
                },
                "references": {
                    "sentences": [
                        "the string d54hdan9c9ebsx (one of the NSIS archive's file names) is pushed on the stack at address 0x8eb<crlf>something like a CreateFileA API call is performed at address 0x989 (the constant 0x80000000 is most likely for GENERIC_READ). If we wanted to be sure, we would have to emulate the API lookup function at address 0x776, but it looks like safe assumption.<crlf>soon after, the function sub_a01 gets called. Decompiling this functions reveals something similar to a decryption loop",
                        "But there is also the dirty way: we could patch the decrypted lognp shellcode in order to embed the content of d54hdan9c9ebsx in the shellcode space and patch the shellcode entry point to perform a call to the decryption function with the right parameters. Of course we will chose the dirty way. It is not only way faster, it is also more fun.",
                        "extract the first buffer (offset header+0 in archive) to a file named d54hdan9c9ebsx<crlf>extract the second buffer (offset header+0x34f0f in archive) to a file named lognp<crlf>extract the third buffer (offset header+0x36390 in archive) to ${PLUGINDIR}\\dwksh.dll, wherever that could be<crlf>call dwksh.dll's exported method sdvffryp without any argument",
                        "Figure 9: decrypted d54hdan9c9ebsx",
                        "There is the clean way: we could hook the CreateFileA/ReadFile APIs in speakeasy and intercept the call to give back the content of the file d54hdan9c9ebsx.",
                        "First open a copy of the decrypted lognp shellcode in Malcat with extra space at the end of the file (File > Open Copy of File). The file d54hdan9c9ebsx is 216843 bytes big, we'll append 300KB just to be sure.<crlf>Copy the content of the file d54hdan9c9ebsx in the clipboard: in a second Malcat instance, open d54hdan9c9ebsx and then hit Ctrl+A followed by Ctrl+C<crlf>Paste the copied data after the shellcode in the first Malcat instance, let's say at address 0x2000 to make it easy to remember<crlf>Enter disassembly view (F3) and go to the shellcode's entry point at address 0"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7e445b6e>",
                    "type": "UnknownWord",
                    "value": "plugindir"
                },
                "references": {
                    "sentences": [
                        "extract the first buffer (offset header+0 in archive) to a file named d54hdan9c9ebsx<crlf>extract the second buffer (offset header+0x34f0f in archive) to a file named lognp<crlf>extract the third buffer (offset header+0x36390 in archive) to ${PLUGINDIR}\\dwksh.dll, wherever that could be<crlf>call dwksh.dll's exported method sdvffryp without any argument"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe5756f0b>",
                    "type": "UnknownWord",
                    "value": "dwksh"
                },
                "references": {
                    "sentences": [
                        "extract the first buffer (offset header+0 in archive) to a file named d54hdan9c9ebsx<crlf>extract the second buffer (offset header+0x34f0f in archive) to a file named lognp<crlf>extract the third buffer (offset header+0x36390 in archive) to ${PLUGINDIR}\\dwksh.dll, wherever that could be<crlf>call dwksh.dll's exported method sdvffryp without any argument"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xba0ece6d>",
                    "type": "UnknownWord",
                    "value": "picked"
                },
                "references": {
                    "sentences": [
                        "The rest of the method seems like junk code, judging by the strings which are either random letters or picked out of dictionary. Quickly inspecting the first two files tells us that both are encrypted and/or compressed, so no quick-win there. We have to dig into the dll."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x95a5f6c8>",
                    "type": "UnknownWord",
                    "value": "dictionary"
                },
                "references": {
                    "sentences": [
                        "The rest of the method seems like junk code, judging by the strings which are either random letters or picked out of dictionary. Quickly inspecting the first two files tells us that both are encrypted and/or compressed, so no quick-win there. We have to dig into the dll."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa3f46e0b>",
                    "type": "UnknownWord",
                    "value": "inspecting"
                },
                "references": {
                    "sentences": [
                        "The rest of the method seems like junk code, judging by the strings which are either random letters or picked out of dictionary. Quickly inspecting the first two files tells us that both are encrypted and/or compressed, so no quick-win there. We have to dig into the dll."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb7d3c3b9>",
                    "type": "UnknownWord",
                    "value": "quick-win"
                },
                "references": {
                    "sentences": [
                        "The rest of the method seems like junk code, judging by the strings which are either random letters or picked out of dictionary. Quickly inspecting the first two files tells us that both are encrypted and/or compressed, so no quick-win there. We have to dig into the dll."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa02dc11e>",
                    "type": "UnknownWord",
                    "value": "dig"
                },
                "references": {
                    "sentences": [
                        "The rest of the method seems like junk code, judging by the strings which are either random letters or picked out of dictionary. Quickly inspecting the first two files tells us that both are encrypted and/or compressed, so no quick-win there. We have to dig into the dll."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa35e97be>",
                    "type": "UnknownWord",
                    "value": "prologs"
                },
                "references": {
                    "sentences": [
                        "The lognp file, once decrypted, does not appear to be in any known file format. But the first byte is E9, which is a jump in the x86 architecture and is very typical for shellcode prologs. So before starting the analysis, we will have to tell Malcat two things:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc6cc93c9>",
                    "type": "UnknownWord",
                    "value": "dropdown"
                },
                "references": {
                    "sentences": [
                        "the architecture used: x86 in our case. This can be set using the dropdown menu in the status bar<crlf>the entry point of the shellcode, which is at address 0 in our case. We just have to define a new function start at this address using the context menu in disassembly mode (F3)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa573c9c0>",
                    "type": "UnknownWord",
                    "value": "bar"
                },
                "references": {
                    "sentences": [
                        "the architecture used: x86 in our case. This can be set using the dropdown menu in the status bar<crlf>the entry point of the shellcode, which is at address 0 in our case. We just have to define a new function start at this address using the context menu in disassembly mode (F3)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x38959f4c>",
                    "type": "UnknownWord",
                    "value": "smart"
                },
                "references": {
                    "sentences": [
                        "After this, Malcat is smart enough to recover most of the shellcode's CFG using its usual set of analyses. Following the control flow, we quickly arrive in the function sub_7dd which contains interesting patterns:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6e295d51>",
                    "type": "UnknownWord",
                    "value": "cfg"
                },
                "references": {
                    "sentences": [
                        "After this, Malcat is smart enough to recover most of the shellcode's CFG using its usual set of analyses. Following the control flow, we quickly arrive in the function sub_7dd which contains interesting patterns:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x79ac989b>",
                    "type": "UnknownWord",
                    "value": "sub_7dd"
                },
                "references": {
                    "sentences": [
                        "After this, Malcat is smart enough to recover most of the shellcode's CFG using its usual set of analyses. Following the control flow, we quickly arrive in the function sub_7dd which contains interesting patterns:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1525fafe>",
                    "type": "UnknownWord",
                    "value": "stack"
                },
                "references": {
                    "sentences": [
                        "the string d54hdan9c9ebsx (one of the NSIS archive's file names) is pushed on the stack at address 0x8eb<crlf>something like a CreateFileA API call is performed at address 0x989 (the constant 0x80000000 is most likely for GENERIC_READ). If we wanted to be sure, we would have to emulate the API lookup function at address 0x776, but it looks like safe assumption.<crlf>soon after, the function sub_a01 gets called. Decompiling this functions reveals something similar to a decryption loop"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x377b521a>",
                    "type": "UnknownWord",
                    "value": "createfilea"
                },
                "references": {
                    "sentences": [
                        "Before emulating anything, we need to solve a problem: the data to decrypt (d54hdan9c9ebsx) is not embedded in the lognp shellcode, it is read from the filesystem using CreateFileA. So emulation is likely to fail. How are we going to solve this issue?",
                        "There is the clean way: we could hook the CreateFileA/ReadFile APIs in speakeasy and intercept the call to give back the content of the file d54hdan9c9ebsx.",
                        "the string d54hdan9c9ebsx (one of the NSIS archive's file names) is pushed on the stack at address 0x8eb<crlf>something like a CreateFileA API call is performed at address 0x989 (the constant 0x80000000 is most likely for GENERIC_READ). If we wanted to be sure, we would have to emulate the API lookup function at address 0x776, but it looks like safe assumption.<crlf>soon after, the function sub_a01 gets called. Decompiling this functions reveals something similar to a decryption loop"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6644b25c>",
                    "type": "UnknownWord",
                    "value": "generic_read"
                },
                "references": {
                    "sentences": [
                        "the string d54hdan9c9ebsx (one of the NSIS archive's file names) is pushed on the stack at address 0x8eb<crlf>something like a CreateFileA API call is performed at address 0x989 (the constant 0x80000000 is most likely for GENERIC_READ). If we wanted to be sure, we would have to emulate the API lookup function at address 0x776, but it looks like safe assumption.<crlf>soon after, the function sub_a01 gets called. Decompiling this functions reveals something similar to a decryption loop"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb99ead62>",
                    "type": "UnknownWord",
                    "value": "emulate"
                },
                "references": {
                    "sentences": [
                        "To emulate shellcodes, Malcat comes bundled with a script named speakeay_shellcode.py which emulates shellcodes using the Speakeasy emulator. Note that Speakeasy is not bundled with Malcat, you will have to install the python package yourself (and if you are running Malcat under Windows, be sure to check Use system python interpreter in the options).",
                        "the string d54hdan9c9ebsx (one of the NSIS archive's file names) is pushed on the stack at address 0x8eb<crlf>something like a CreateFileA API call is performed at address 0x989 (the constant 0x80000000 is most likely for GENERIC_READ). If we wanted to be sure, we would have to emulate the API lookup function at address 0x776, but it looks like safe assumption.<crlf>soon after, the function sub_a01 gets called. Decompiling this functions reveals something similar to a decryption loop"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x60cf3f31>",
                    "type": "UnknownWord",
                    "value": "lookup"
                },
                "references": {
                    "sentences": [
                        "the string d54hdan9c9ebsx (one of the NSIS archive's file names) is pushed on the stack at address 0x8eb<crlf>something like a CreateFileA API call is performed at address 0x989 (the constant 0x80000000 is most likely for GENERIC_READ). If we wanted to be sure, we would have to emulate the API lookup function at address 0x776, but it looks like safe assumption.<crlf>soon after, the function sub_a01 gets called. Decompiling this functions reveals something similar to a decryption loop"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe7c7e42e>",
                    "type": "UnknownWord",
                    "value": "assumption"
                },
                "references": {
                    "sentences": [
                        "the string d54hdan9c9ebsx (one of the NSIS archive's file names) is pushed on the stack at address 0x8eb<crlf>something like a CreateFileA API call is performed at address 0x989 (the constant 0x80000000 is most likely for GENERIC_READ). If we wanted to be sure, we would have to emulate the API lookup function at address 0x776, but it looks like safe assumption.<crlf>soon after, the function sub_a01 gets called. Decompiling this functions reveals something similar to a decryption loop"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7c7f6b94>",
                    "type": "UnknownWord",
                    "value": "sub_a01"
                },
                "references": {
                    "sentences": [
                        "the string d54hdan9c9ebsx (one of the NSIS archive's file names) is pushed on the stack at address 0x8eb<crlf>something like a CreateFileA API call is performed at address 0x989 (the constant 0x80000000 is most likely for GENERIC_READ). If we wanted to be sure, we would have to emulate the API lookup function at address 0x776, but it looks like safe assumption.<crlf>soon after, the function sub_a01 gets called. Decompiling this functions reveals something similar to a decryption loop"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8e6e3a00>",
                    "type": "UnknownWord",
                    "value": "decompiling"
                },
                "references": {
                    "sentences": [
                        "the string d54hdan9c9ebsx (one of the NSIS archive's file names) is pushed on the stack at address 0x8eb<crlf>something like a CreateFileA API call is performed at address 0x989 (the constant 0x80000000 is most likely for GENERIC_READ). If we wanted to be sure, we would have to emulate the API lookup function at address 0x776, but it looks like safe assumption.<crlf>soon after, the function sub_a01 gets called. Decompiling this functions reveals something similar to a decryption loop"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa4551ec4>",
                    "type": "UnknownWord",
                    "value": "retraced"
                },
                "references": {
                    "sentences": [
                        "The whole process can be retraced in the animated GIF below:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb8a857fa>",
                    "type": "UnknownWord",
                    "value": "animated"
                },
                "references": {
                    "sentences": [
                        "The whole process can be retraced in the animated GIF below:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa46a9646>",
                    "type": "UnknownWord",
                    "value": "locating"
                },
                "references": {
                    "sentences": [
                        "Figure 7: locating the decryption function inside the shellcode"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8234ba24>",
                    "type": "UnknownWord",
                    "value": "obviously"
                },
                "references": {
                    "sentences": [
                        "The code of the decryption function is given below. It is obviously obfuscated, and sadly it would not be immediate to reimplement it in python in Malcat. So we will have to find an alternative. Since the decryption function prototype is very simple (it just needs a pointer to the buffer and the buffer size) and is without side effects, why not give emulation a go?"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x80d8c818>",
                    "type": "UnknownWord",
                    "value": "immediate"
                },
                "references": {
                    "sentences": [
                        "The code of the decryption function is given below. It is obviously obfuscated, and sadly it would not be immediate to reimplement it in python in Malcat. So we will have to find an alternative. Since the decryption function prototype is very simple (it just needs a pointer to the buffer and the buffer size) and is without side effects, why not give emulation a go?"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x28f425fe>",
                    "type": "UnknownWord",
                    "value": "prototype"
                },
                "references": {
                    "sentences": [
                        "The code of the decryption function is given below. It is obviously obfuscated, and sadly it would not be immediate to reimplement it in python in Malcat. So we will have to find an alternative. Since the decryption function prototype is very simple (it just needs a pointer to the buffer and the buffer size) and is without side effects, why not give emulation a go?"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x97194fbf>",
                    "type": "UnknownWord",
                    "value": "pointer"
                },
                "references": {
                    "sentences": [
                        "The code of the decryption function is given below. It is obviously obfuscated, and sadly it would not be immediate to reimplement it in python in Malcat. So we will have to find an alternative. Since the decryption function prototype is very simple (it just needs a pointer to the buffer and the buffer size) and is without side effects, why not give emulation a go?"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfe79fbac>",
                    "type": "UnknownWord",
                    "value": "effects"
                },
                "references": {
                    "sentences": [
                        "The code of the decryption function is given below. It is obviously obfuscated, and sadly it would not be immediate to reimplement it in python in Malcat. So we will have to find an alternative. Since the decryption function prototype is very simple (it just needs a pointer to the buffer and the buffer size) and is without side effects, why not give emulation a go?"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x995abc43>",
                    "type": "UnknownWord",
                    "value": "emulates"
                },
                "references": {
                    "sentences": [
                        "To emulate shellcodes, Malcat comes bundled with a script named speakeay_shellcode.py which emulates shellcodes using the Speakeasy emulator. Note that Speakeasy is not bundled with Malcat, you will have to install the python package yourself (and if you are running Malcat under Windows, be sure to check Use system python interpreter in the options)."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x203bf2df>",
                    "type": "UnknownWord",
                    "value": "decrypt d54hdan9c9ebsx"
                },
                "references": {
                    "sentences": [
                        "Before emulating anything, we need to solve a problem: the data to decrypt (d54hdan9c9ebsx) is not embedded in the lognp shellcode, it is read from the filesystem using CreateFileA. So emulation is likely to fail. How are we going to solve this issue?"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe3a63e9d>",
                    "type": "UnknownWord",
                    "value": "readfile"
                },
                "references": {
                    "sentences": [
                        "There is the clean way: we could hook the CreateFileA/ReadFile APIs in speakeasy and intercept the call to give back the content of the file d54hdan9c9ebsx."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x512c57d3>",
                    "type": "UnknownWord",
                    "value": "embed"
                },
                "references": {
                    "sentences": [
                        "But there is also the dirty way: we could patch the decrypted lognp shellcode in order to embed the content of d54hdan9c9ebsx in the shellcode space and patch the shellcode entry point to perform a call to the decryption function with the right parameters. Of course we will chose the dirty way. It is not only way faster, it is also more fun."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x146797fe>",
                    "type": "UnknownWord",
                    "value": "fun"
                },
                "references": {
                    "sentences": [
                        "But there is also the dirty way: we could patch the decrypted lognp shellcode in order to embed the content of d54hdan9c9ebsx in the shellcode space and patch the shellcode entry point to perform a call to the decryption function with the right parameters. Of course we will chose the dirty way. It is not only way faster, it is also more fun."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xeceedc11>",
                    "type": "UnknownWord",
                    "value": "extra"
                },
                "references": {
                    "sentences": [
                        "First open a copy of the decrypted lognp shellcode in Malcat with extra space at the end of the file (File > Open Copy of File). The file d54hdan9c9ebsx is 216843 bytes big, we'll append 300KB just to be sure.<crlf>Copy the content of the file d54hdan9c9ebsx in the clipboard: in a second Malcat instance, open d54hdan9c9ebsx and then hit Ctrl+A followed by Ctrl+C<crlf>Paste the copied data after the shellcode in the first Malcat instance, let's say at address 0x2000 to make it easy to remember<crlf>Enter disassembly view (F3) and go to the shellcode's entry point at address 0"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x834a4f78>",
                    "type": "UnknownWord",
                    "value": "300kb"
                },
                "references": {
                    "sentences": [
                        "First open a copy of the decrypted lognp shellcode in Malcat with extra space at the end of the file (File > Open Copy of File). The file d54hdan9c9ebsx is 216843 bytes big, we'll append 300KB just to be sure.<crlf>Copy the content of the file d54hdan9c9ebsx in the clipboard: in a second Malcat instance, open d54hdan9c9ebsx and then hit Ctrl+A followed by Ctrl+C<crlf>Paste the copied data after the shellcode in the first Malcat instance, let's say at address 0x2000 to make it easy to remember<crlf>Enter disassembly view (F3) and go to the shellcode's entry point at address 0"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9cfcaa99>",
                    "type": "UnknownWord",
                    "value": "remember"
                },
                "references": {
                    "sentences": [
                        "First open a copy of the decrypted lognp shellcode in Malcat with extra space at the end of the file (File > Open Copy of File). The file d54hdan9c9ebsx is 216843 bytes big, we'll append 300KB just to be sure.<crlf>Copy the content of the file d54hdan9c9ebsx in the clipboard: in a second Malcat instance, open d54hdan9c9ebsx and then hit Ctrl+A followed by Ctrl+C<crlf>Paste the copied data after the shellcode in the first Malcat instance, let's say at address 0x2000 to make it easy to remember<crlf>Enter disassembly view (F3) and go to the shellcode's entry point at address 0"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbc15ff9f>",
                    "type": "UnknownWord",
                    "value": "assembling"
                },
                "references": {
                    "sentences": [
                        "Malcat does not (yet) support assembling your own instruction, so we will need to manually edit the machine code. Click on any hexa byte in disasm mode and enter edit mode (Insert key). We need to assemble the following code:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9b8a6287>",
                    "type": "UnknownWord",
                    "value": "manually"
                },
                "references": {
                    "sentences": [
                        "Malcat does not (yet) support assembling your own instruction, so we will need to manually edit the machine code. Click on any hexa byte in disasm mode and enter edit mode (Insert key). We need to assemble the following code:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf94653fd>",
                    "type": "UnknownWord",
                    "value": "hexa"
                },
                "references": {
                    "sentences": [
                        "Malcat does not (yet) support assembling your own instruction, so we will need to manually edit the machine code. Click on any hexa byte in disasm mode and enter edit mode (Insert key). We need to assemble the following code:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9bfb33eb>",
                    "type": "UnknownWord",
                    "value": "disasm"
                },
                "references": {
                    "sentences": [
                        "Malcat does not (yet) support assembling your own instruction, so we will need to manually edit the machine code. Click on any hexa byte in disasm mode and enter edit mode (Insert key). We need to assemble the following code:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5be4c5f7>",
                    "type": "UnknownWord",
                    "value": "insert"
                },
                "references": {
                    "sentences": [
                        "Malcat does not (yet) support assembling your own instruction, so we will need to manually edit the machine code. Click on any hexa byte in disasm mode and enter edit mode (Insert key). We need to assemble the following code:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc442e680>",
                    "type": "UnknownWord",
                    "value": "assemble"
                },
                "references": {
                    "sentences": [
                        "Malcat does not (yet) support assembling your own instruction, so we will need to manually edit the machine code. Click on any hexa byte in disasm mode and enter edit mode (Insert key). We need to assemble the following code:",
                        "Push the second parameter which is the size of the buffer to decrypt (216843 = 0x34F0B). push uint32 is assembled using 0x68 + LSB-encoded uint32 in x86: 68 0B 4F 03 00<crlf>Push the first parameter which is the address of the buffer to decrypt (0x2000): 68 00 20 00 00<crlf>Call to the decryption function. The call opcode is 0xE8 + signed displacement starting from the end of the call opcode. The end of our call opcode is at address 0x000F, we want to jump to 0x0A01, so 0x0A01 - 0x000F = 0x09f2. We need to assemble E8 F2 09 00 00."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1f7c2d2e>",
                    "type": "UnknownWord",
                    "value": "assembled"
                },
                "references": {
                    "sentences": [
                        "Push the second parameter which is the size of the buffer to decrypt (216843 = 0x34F0B). push uint32 is assembled using 0x68 + LSB-encoded uint32 in x86: 68 0B 4F 03 00<crlf>Push the first parameter which is the address of the buffer to decrypt (0x2000): 68 00 20 00 00<crlf>Call to the decryption function. The call opcode is 0xE8 + signed displacement starting from the end of the call opcode. The end of our call opcode is at address 0x000F, we want to jump to 0x0A01, so 0x0A01 - 0x000F = 0x09f2. We need to assemble E8 F2 09 00 00."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x180e734e>",
                    "type": "UnknownWord",
                    "value": "lsb-encoded"
                },
                "references": {
                    "sentences": [
                        "Push the second parameter which is the size of the buffer to decrypt (216843 = 0x34F0B). push uint32 is assembled using 0x68 + LSB-encoded uint32 in x86: 68 0B 4F 03 00<crlf>Push the first parameter which is the address of the buffer to decrypt (0x2000): 68 00 20 00 00<crlf>Call to the decryption function. The call opcode is 0xE8 + signed displacement starting from the end of the call opcode. The end of our call opcode is at address 0x000F, we want to jump to 0x0A01, so 0x0A01 - 0x000F = 0x09f2. We need to assemble E8 F2 09 00 00."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6751f887>",
                    "type": "UnknownWord",
                    "value": "displacement"
                },
                "references": {
                    "sentences": [
                        "Push the second parameter which is the size of the buffer to decrypt (216843 = 0x34F0B). push uint32 is assembled using 0x68 + LSB-encoded uint32 in x86: 68 0B 4F 03 00<crlf>Push the first parameter which is the address of the buffer to decrypt (0x2000): 68 00 20 00 00<crlf>Call to the decryption function. The call opcode is 0xE8 + signed displacement starting from the end of the call opcode. The end of our call opcode is at address 0x000F, we want to jump to 0x0A01, so 0x0A01 - 0x000F = 0x09f2. We need to assemble E8 F2 09 00 00."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5b214e43>",
                    "type": "UnknownWord",
                    "value": "calculator"
                },
                "references": {
                    "sentences": [
                        "You can use Malcat's calculator to perform quick computation while analysing a binary, just hit Shift+Ctrl+C. Internally, it uses the python interpreter, so use python syntax."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb2437425>",
                    "type": "UnknownWord",
                    "value": "computation"
                },
                "references": {
                    "sentences": [
                        "You can use Malcat's calculator to perform quick computation while analysing a binary, just hit Shift+Ctrl+C. Internally, it uses the python interpreter, so use python syntax."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1e1b9d41>",
                    "type": "UnknownWord",
                    "value": "syntax"
                },
                "references": {
                    "sentences": [
                        "You can use Malcat's calculator to perform quick computation while analysing a binary, just hit Shift+Ctrl+C. Internally, it uses the python interpreter, so use python syntax."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa4d6c66a>",
                    "type": "UnknownWord",
                    "value": "right-click"
                },
                "references": {
                    "sentences": [
                        "let us define the entry point: right-click at address 0 and chose Force function start in the context menu<crlf>run the script speakeasy_shellcode.py (Ctrl+U to run user scripts)"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe6fdd3ad>",
                    "type": "UnknownWord",
                    "value": "parser"
                },
                "references": {
                    "sentences": [
                        "... and voila, Malcat should open the result in a new file. A PE file has been detected by Malcat's file format parser at address 0x2000, perfect! Just double-click the PE file under \"Carved Files\" to open it."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x47e566de>",
                    "type": "UnknownWord",
                    "value": "carved"
                },
                "references": {
                    "sentences": [
                        "... and voila, Malcat should open the result in a new file. A PE file has been detected by Malcat's file format parser at address 0x2000, perfect! Just double-click the PE file under \"Carved Files\" to open it."
                    ],
                    "titles": []
                }
            }
        ]
    },
    "other_links": [],
    "info": {
        "potential_threats": {},
        "sigma": false,
        "yara": true
    },
    "keywords": {
        "classified": [],
        "dubbed": [],
        "associated": [],
        "targets": [],
        "attributed": []
    },
    "resources": {
        "links": {
            "github": [
                "https://github.com/mandiant/speakeasy",
                "https://github.com/mandiant/speakeasy"
            ],
            "pastebin": [],
            "text_files": [],
            "other": [
                "https://malcat.fr/blog/exploit-steganography-and-delphi-unpacking-dbatloader/",
                "https://malcat.fr/blog/exploit-steganography-and-delphi-unpacking-dbatloader/#exploiting-cve-2018-0798",
                "https://bazaar.abuse.ch/sample/291df8186e62df74b8fcf2c361c6913b9b73e3e864dde58eb63d5c3159a4c32d/",
                "https://www.virustotal.com/gui/file/291df8186e62df74b8fcf2c361c6913b9b73e3e864dde58eb63d5c3159a4c32d",
                "https://www.virustotal.com/gui/file/be00a655cdf4e4706bf1bbf3659d698f967cad66acdf7cda0d12f16dc0cfda3e/detection",
                "https://malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation/shellcode.zip",
                "https://www.virustotal.com/gui/file/02dee91a81652e5234414e452622307fd61e7988e82bec43665f699f805c3151",
                "https://bazaar.abuse.ch/sample/e850f3849ea82980cf23844ad3caadf73856b2d5b0c4179847d82ce4016e80ee/",
                "https://www.virustotal.com/gui/file/e850f3849ea82980cf23844ad3caadf73856b2d5b0c4179847d82ce4016e80ee",
                "https://malcat.fr",
                "https://malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation/shellcode.patched.zip"
            ]
        },
        "images": [
            "https://malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation/excel_decoy.jpg",
            "https://malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation/lognp.png",
            "https://malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation/decrypt.png",
            "https://malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation/transform.png",
            "https://malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation/loki.png",
            "https://malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation/loki2.png",
            "https://malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation/cc.png",
            "https://malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation/vfs.png",
            "https://malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation/oninit.png",
            "https://malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation/sc_start.gif",
            "https://malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation/patch.png",
            "https://malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation/pe.png"
        ]
    }
}