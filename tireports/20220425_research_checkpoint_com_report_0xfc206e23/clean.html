<div>
<h1>Check Point Research detects vulnerability in the Everscale blockchain wallet, preventing cryptocurrency theft</h1>
					April 25, 2022				
<p>Research By: Alexey Bukhteyev</p>
<h2>Highlights</h2>
<ul>
<li>Check Point Research (CPR) discovered a vulnerability in the web version of Ever Surf wallet, part of the <a href="https://everscale.network/">Everscale</a> blockchain ecosystem</li>
<li>By exploiting the vulnerability, an attacker could have gained full control over victim’s wallet</li>
<li>After responsible disclosure, CPR collaborated with the Everscale teams, which acknowledged the vulnerability and released a new desktop version to replace the vulnerable web version</li>
</ul>
<h2>Background</h2>
<p>Blockchain technology and decentralized applications (dAPPs) provide users with a number of advantages. For example, users can utilize the service without creating an account and it can be implemented as a single-page application written in JavaScript. This type of application does not require communication with a centralized infrastructure, such as a web server, and it can interact with the blockchain directly or by using a browser extension like Metamask.</p>
<p>In this case, the user is identified using keys that are stored only on a local machine inside a browser extension or a web wallet. If a decentralized application or a wallet stores sensitive data locally, it must ensure this data is reliably protected. In most cases, dAPPs run inside the browser and therefore may be vulnerable to attacks such as XSS.</p>
<p>This research describes the vulnerability found in the web version of <a href="https://ever.surf/">Ever Surf</a>, a wallet for the <a href="https://everscale.network/">Everscale</a> blockchain (formerly <a href="https://en.wikipedia.org/wiki/Telegram_Open_Network#Post_Telegram">Free TON</a>). By exploiting the vulnerability, it’s possible to decrypt the private keys and seed phrases that are stored in the browser’s local storage. In other words, attackers could gain full control over victim’s wallets.</p>
<h2>Responsible disclosure and collaboration with Everscale</h2>
<p>CPR disclosed the vulnerability to Ever Surf developers who then released a desktop version that mitigates this vulnerability. The web version is now declared deprecated and should only be used for development purposes. Seed phrases from accounts that store real value in crypto should not be used in the web version of Ever Surf.</p>
<h2>Vulnerability description</h2>
<p>Ever Surf is a cross-platform messenger, a blockchain browser, and a crypto wallet for Everscale blockchain. It is written in React Native and is available in Google Play Market and Apple Store. There is also a <a href="https://web.ever.surf/">web version of Ever Surf</a> that runs on any platform.</p>
<figure class="aligncenter size-large"><img alt="Web version of Ever Surf" class="wp-image-26069" height="627" src="https://research.checkpoint.com//research.checkpoint.com/wp-content/uploads/2022/04/Figure-1-%E2%80%93-Web-version-of-Ever-Surf-1024x627.png" style="max-width:800px;height:auto;width:auto;" width="1024"/></figure>
<p>Figure 1 – Web version of Ever Surf</p>
<p>Surf doesn’t require a backend to work with the blockchain because it implements a non-custodial wallet. This means the keys required to sign transactions are only stored on the user’s device. Operations with the blockchain are performed entirely on the client’s side. Therefore, like other non-custodial wallets, it doesn’t have a registration using login names and passwords.</p>
<p>When users run the application for the first time, it suggests creating a new wallet. Surf generates a <a href="https://www.coinbase.com/learn/crypto-basics/what-is-a-seed-phrase">seed phrase</a> and a pair of the public and the private keys. In addition, the user is prompted to create a 6-digit PIN code:</p>
<figure class="aligncenter size-medium"><img alt="PIN code setup in Ever Surf" class="wp-image-26070" height="300" src="https://research.checkpoint.com//research.checkpoint.com/wp-content/uploads/2022/04/Figure-2-%E2%80%93-PIN-code-setup-in-Ever-Surf-159x300.png" width="159"/></figure>
<p>Figure 2 – PIN code setup in Ever Surf</p>
<p>This PIN is then used to log into the application and also to confirm transactions. Surf has a protection against brute-forcing the PIN code. When users enter an incorrect PIN code five times in a row, the application is temporary blocked and users are prevented from entering additional PIN codes:</p>
<figure class="aligncenter size-full"><img alt="Ever Surf prevents brute-forcing PIN codes" class="wp-image-26071" height="128" src="https://research.checkpoint.com//research.checkpoint.com/wp-content/uploads/2022/04/Figure-3-%E2%80%93-Ever-Surf-prevents-brute-forcing-PIN-codes.png" width="399"/></figure>
<p>Figure 3 – Ever Surf prevents brute-forcing PIN codes</p>
<p>Even without such protection, the performance of manually brute-forcing PIN codes cannot be efficient enough to bother with in most cases. Therefore, to implement a real attack, attackers would need to extract the keystore from the application.</p>
<p>The created keys and the seed phrase are stored in the web browser’s <a href="https://en.wikipedia.org/wiki/Web_storage">local storage</a>. The local storage is a key-value storage accessed from JavaScript using the “localStorage” property. For example:</p>
// Store value on the browser beyond the duration of the sessionlocalStorage.setItem('key', 'value');// Retrieve value (persists even after closing and re-opening the browser)alert(localStorage.getItem('key'));// Store value on the browser beyond the duration of the session
localStorage.setItem('key', 'value');
// Retrieve value (persists even after closing and re-opening the browser)
alert(localStorage.getItem('key'));// Store value on the browser beyond the duration of the session
localStorage.setItem('key', 'value');
// Retrieve value (persists even after closing and re-opening the browser)
alert(localStorage.getItem('key'));
<p>Surf stores the keys and the seed phrase in the “surf.ton.wallet” key of the local storage in the following format:</p>
<figure class="aligncenter size-full"><img alt="Encrypted wallet data is stored in the browser’s localStorage" class="wp-image-26072" height="176" src="https://research.checkpoint.com//research.checkpoint.com/wp-content/uploads/2022/04/Figure-4-%E2%80%93-Encrypted-wallet-data-is-stored-in-the-browsers-localStorage.png" style="max-width:800px;height:auto;width:auto;" width="744"/></figure>
<p>Figure 4 – Encrypted wallet data is stored in the browser’s localStorage</p>
<p>Local storage is not protected in web browsers. For example, in Firefox it is stored in a non-encrypted SQLite database in the file:</p>
<code>Mozilla\Firefox\Profiles\{profile_name}\webappstore.sqlite</code>
<p>Chrome stores the local storage in the non-encrypted form in a LevelDB database in the folder:</p>
<code>Google\Chrome\User Data\Default\Local Storage\leveldb\</code>
<p>This means that a human with physical access to the computer or any application or malware such as an infostealer can obtain this data.</p>
<p>In addition, localStorage can be accessed by a browser extension, which can then leak the stored data. To demonstrate this, we created a simple Chrome web extension with the following code:</p>
alert(localStorage.getItem("surf.ton.wallet"));alert(localStorage.getItem("surf.ton.wallet"));alert(localStorage.getItem("surf.ton.wallet"));
<p>If we open the Surf website after installing the extension, we see the message containing the encrypted keystore:</p>
<figure class="aligncenter size-full"><img alt="Extracting encrypted wallet data from localStorage using a browser extension" class="wp-image-26073" height="425" src="https://research.checkpoint.com//research.checkpoint.com/wp-content/uploads/2022/04/Figure-5-%E2%80%93-Extracting-encrypted-wallet-data-from-localStorage-using-a-browser-extension.png" style="max-width:800px;height:auto;width:auto;" width="651"/></figure>
<p>Figure 5 – Extracting encrypted wallet data from localStorage using a browser extension</p>
<p>Therefore, the browser’s local storage cannot be considered secure enough.</p>
<p>The responsibility for the reliability of the stored data encryption rests entirely with the web application.</p>
<p>Websites that require registration, such as well-known social networks, may not rely only on the data stored in cookies or local storage. They may also check the web browser and the user’s IP address, and require additional user verification in case of suspicious activities. This is impossible with Surf because the data required to control a user’s wallet is stored entirely on their computer. The only protection for their funds is strong encryption.</p>
<h2>Keystore encryption</h2>
<p>Unfortunately, Surf is not open-source. Therefore, Check Point researchers had to analyze the minified JavaScript application bundle to understand the logic.</p>
<p>Although an attacker would be primarily interested in the keys decryption, it is enough to get the seed phrase which can be used to restore the keys. The application decrypts the seed phrase and shows it to the user after entering the PIN code:</p>
<figure class="aligncenter size-full"><img alt="Surf asks for the PIN code before showing the seed phrase" class="wp-image-26074" height="272" src="https://research.checkpoint.com//research.checkpoint.com/wp-content/uploads/2022/04/Figure-6-%E2%80%93-Surf-asks-for-the-PIN-code-before-showing-the-seed-phrase.png" style="max-width:800px;height:auto;width:auto;" width="923"/></figure>
<p>Figure 6 – Surf asks for the PIN code before showing the seed phrase</p>
<p>Therefore, to find where the decryption occurs, CPR first anchored to the function that fetches the seed phrase. In this function, the askForPassword function is called and receives the encrypted keystore.</p>
<figure class="aligncenter size-full"><img alt="The function responsible for fetching the seed phrase asks for the PIN code" class="wp-image-26075" height="285" src="https://research.checkpoint.com//research.checkpoint.com/wp-content/uploads/2022/04/Figure-7-%E2%80%93-The-function-responsible-for-fetching-the-seed-phrase-asks-for-the-PIN-code.png" style="max-width:800px;height:auto;width:auto;" width="761"/></figure>
<p>Figure 7 – The function responsible for fetching the seed phrase asks for the PIN code</p>
<p>The askForPassword function performs the PIN code validation by calling the validatePassword function.</p>
<figure class="wp-block-image size-full"><img alt="The askForPassword function reads and validates the PIN code" class="wp-image-26076" height="146" src="https://research.checkpoint.com//research.checkpoint.com/wp-content/uploads/2022/04/Figure-8-%E2%80%93-The-askForPassword-function-reads-and-validates-the-PIN-code.png" style="max-width:800px;height:auto;width:auto;" width="918"/></figure>
<p>Figure 8 – The askForPassword function reads and validates the PIN code</p>
<p>The most important actions are performed throughout the PIN code validation. By calling the deriveKeyFromPasswordAndSalt function, Surf generates the derived key, which is used to decrypt the keystore. Then, in the isDerivedKeyCorrect function, Surf performs the decryption using <a href="https://github.com/tonlabs/TON-SDK/blob/master/docs/reference/types-and-methods/mod_crypto.md#nacl_secret_box_open">nacl_secret_box_open</a>:</p>
<figure class="aligncenter size-full"><img alt="Surf decrypts the keys using nacl_secret_box_open" class="wp-image-26077" height="71" src="https://research.checkpoint.com//research.checkpoint.com/wp-content/uploads/2022/04/Figure-9-%E2%80%93-Surf-decrypts-the-keys-using-nacl_secret_box_open.png" width="442"/></figure>
<p>Figure 9 – Surf decrypts the keys using nacl_secret_box_open.</p>
<p>These are the arguments for nacl_secret_box_open:</p>
<ul>
<li>encrypted – Encrypted string in base64-encoded form</li>
<li>nonce – Hex-encoded nonce</li>
<li>key – 64 symbols hex-encoded key derived from the PIN-code</li>
</ul>
<p>The values “encrypted” and “nonce” are taken from the keystore (encStr and nonce):</p>
{"encSeed": { "encStr":"6rjkbh88WXkrJWl4os3cjRzvZkQGlnV39U3YvLYUrM7yzf6h79XxXX/VziNde2bkPeSnJZ11Yi4T8CFgPJMyI1W+EN0Yzw+FDdtTq5gaKHjk5nF60CSHZ4qKXObIQ7zBbped", "nonce":"2Tdr9FFP0RcpjecwcS8XtcC5M2/FRY+I"}}{"encSeed": { 
 "encStr":"6rjkbh88WXkrJWl4os3cjRzvZkQGlnV39U3YvLYUrM7yzf6h79XxXX/VziNde2bkPeSnJZ11Yi4T8CFgPJMyI1W+EN0Yzw+FDdtTq5gaKHjk5nF60CSHZ4qKXObIQ7zBbped",
 "nonce":"2Tdr9FFP0RcpjecwcS8XtcC5M2/FRY+I"
}}{"encSeed": { 
 "encStr":"6rjkbh88WXkrJWl4os3cjRzvZkQGlnV39U3YvLYUrM7yzf6h79XxXX/VziNde2bkPeSnJZ11Yi4T8CFgPJMyI1W+EN0Yzw+FDdtTq5gaKHjk5nF60CSHZ4qKXObIQ7zBbped",
 "nonce":"2Tdr9FFP0RcpjecwcS8XtcC5M2/FRY+I"
}}
<p>The next step is to understand how the derived key appears. Inside the deriveKeyFromPasswordAndSalt, Surf derives the decryption key from the PIN code using the <a href="https://en.wikipedia.org/wiki/Scrypt">Scrypt key derivation function</a> with the following arguments:</p>
<figure class="aligncenter size-full"><img alt="Surf derives the keystore decryption key from the entered PIN code and salt using Scrypt" class="wp-image-26078" height="289" src="https://research.checkpoint.com//research.checkpoint.com/wp-content/uploads/2022/04/Figure-10-%E2%80%93-Surf-derives-the-keystore-decryption-key-from-the-entered-PIN-code-and-salt-using-Scrypt.png" width="480"/></figure>
<p>Figure 10 – Surf derives the keystore decryption key from the entered PIN code and salt using Scrypt</p>
<p>These are the arguments for <a href="https://github.com/tonlabs/TON-SDK/blob/master/docs/reference/types-and-methods/mod_crypto.md#scrypt">scrypt</a>:</p>
<ul>
<li>password – Base64-encoded PIN-code</li>
<li>salt – Salt value in the base64-encoded form</li>
</ul>
<p>As the password is entered by the user, the only missing piece is the salt value. The salt value is calculated on the client’s device and has two roles:</p>
<ul>
<li>It is not stored in the keystore. This should mean decryption is impossible if the encrypted keys were leaked and the attacker doesn’t know how to calculate the salt.</li>
<li>Protects the resulting value against <a href="https://en.wikipedia.org/wiki/Rainbow_table">rainbow table</a> attacks.</li>
</ul>
<p>Salt is calculated as SHA256 hash of one of the values returned by the <a href="https://github.com/react-native-device-info/react-native-device-info#getuniqueid">DeviceInfo.getUniqueId</a> function of the react-native-device-info package:</p>
<figure class="aligncenter size-full"><img alt="Surf generates the salt by hashing the value returned by DeviceInfo.getUniqueId()" class="wp-image-26079" height="332" src="https://research.checkpoint.com//research.checkpoint.com/wp-content/uploads/2022/04/Figure-11-%E2%80%93-Surf-generates-the-salt-by-hashing-the-value-returned-by-DeviceInfo.getUniqueId.png" style="max-width:800px;height:auto;width:auto;" width="866"/></figure>
<p>Figure 11 – Surf generates the salt by hashing the value returned by DeviceInfo.getUniqueId()</p>
<p>Nevertheless, there is another option. The salt can be calculated as SHA256 of the window.process.argv.slice(-1) value. In a web browser, the window.process is undefined. Therefore, DeviceInfo.getUniqueId is always used.</p>
<p>After checking <a href="https://github.com/react-native-device-info/react-native-device-info">react-native-device-info</a> documentation, researchers see that it is not supported in a web browser:</p>
<figure class="aligncenter size-full"><img alt="getUniqueId() is not supported in a web browser" class="wp-image-26080" height="82" src="https://research.checkpoint.com//research.checkpoint.com/wp-content/uploads/2022/04/Figure-12-%E2%80%93-getUniqueId-is-not-supported-in-a-web-browser.png" style="max-width:800px;height:auto;width:auto;" width="686"/></figure>
<p>Figure 12 – getUniqueId() is not supported in a web browser</p>
<p>In a web browser, this function always returns the value “unknown”:</p>
<figure class="wp-block-image size-full"><img alt="getUniqueId always returns the value “unknown”" class="wp-image-26081" height="62" src="https://research.checkpoint.com//research.checkpoint.com/wp-content/uploads/2022/04/getUniqueId-returns-unknown.png" style="max-width:800px;height:auto;width:auto;" width="950"/></figure>
<p>Therefore, the salt is always the same and can be easily calculated as <code>sha256(“unknown”)</code> and is equal to “<code>b23a6a8439c0dde5515893e7c90c1e3233b8616e634470f20dc4928bcf3609bc</code>”:</p>
<figure class="aligncenter size-full"><img alt="The salt is always equal to sha256(“unknown”)" class="wp-image-26082" height="48" src="https://research.checkpoint.com//research.checkpoint.com/wp-content/uploads/2022/04/Figure-13-%E2%80%93-The-salt-is-always-equal-to-sha256unknown.png" width="527"/></figure>
<p>Figure 13 – The salt is always equal to sha256(“unknown”)</p>
<h2>Attack</h2>
<p>CPR roughly re-implemented the key derivation and keystore decryption in NodeJS and performed a brute-force attack on the PIN code.</p>
<p>This resulted in a performance of 95 passwords per second on 4-core Intel Core i7 CPU. Although this is not a very high speed, it is sufficient for the attack on a 6-digit PIN code. In the worst case scenario, checking 10^6 possible variants means the entire attack takes approximately 175 minutes.</p>
<p>For our experiment, we created a new key in Surf and dumped the keystore from the browser’s local storage:</p>
{ "encSeed": { "encStr":"6rjkbh88WXkrJWl4os3cjRzvZkQGlnV39U3YvLYUrM7yzf6h79XxXX/VziNde2bkPeSnJZ11Yi4T8CFgPJMyI1W+EN0Yzw+FDdtTq5gaKHjk5nF60CSHZ4qKXObIQ7zBbped", "nonce":"2Tdr9FFP0RcpjecwcS8XtcC5M2/FRY+I" }}{
 "encSeed": {
 "encStr":"6rjkbh88WXkrJWl4os3cjRzvZkQGlnV39U3YvLYUrM7yzf6h79XxXX/VziNde2bkPeSnJZ11Yi4T8CFgPJMyI1W+EN0Yzw+FDdtTq5gaKHjk5nF60CSHZ4qKXObIQ7zBbped",
 "nonce":"2Tdr9FFP0RcpjecwcS8XtcC5M2/FRY+I"
 }
}{
 "encSeed": {
 "encStr":"6rjkbh88WXkrJWl4os3cjRzvZkQGlnV39U3YvLYUrM7yzf6h79XxXX/VziNde2bkPeSnJZ11Yi4T8CFgPJMyI1W+EN0Yzw+FDdtTq5gaKHjk5nF60CSHZ4qKXObIQ7zBbped",
 "nonce":"2Tdr9FFP0RcpjecwcS8XtcC5M2/FRY+I"
 }
}
<p>In our case, the attack took 38 minutes. At the end, we got the derived key and decrypted the seed phrase that can be used to restore the keys on another device:</p>
<figure class="aligncenter size-full"><img alt="PIN code brute force results" class="wp-image-26083" height="97" src="https://research.checkpoint.com//research.checkpoint.com/wp-content/uploads/2022/04/Figure-14-%E2%80%93-PIN-code-brute-force-results.png" style="max-width:800px;height:auto;width:auto;" width="786"/></figure>
<p>Figure 14 – PIN code brute force results</p>
<p>If cybercriminals perform scalable attacks using infostealers, they may collect huge numbers of encrypted keys and seed phrases. If they try to decrypt them one by one, it may take a significantly long time.</p>
<p>However, since the salt for all encrypted data from different users is the same, the key derivation function Scrypt can be called only once per checked PIN code. While the Scrypt function is computationally intensive, the nacl_secret_box_open function that is used for the decryption is very fast. This allows brute-forcing the PIN codes for multiple wallets without a significant performance impact.</p>
<p>Compared to brute-forcing PIN codes for one encrypted seed phrase when the performance was 95 PIN codes per second, when we tried to force the PIN code for 100 encrypted seed phrases simultaneously, we got a performance of 79 passwords per second.</p>
<h2>Tips to stay safe</h2>
<p>We would like to remind you that blockchain transactions are irreversible. In blockchain, unlike a bank, you cannot block a stolen card or dispute a transaction. If the keys for your wallet are stolen, your crypto funds can become easy prey for cybercriminals, and no one can help to return your money back. To prevent theft of the keys, we recommend:</p>
<ul>
<li>Do not follow suspicious links especially if they received from strangers.</li>
<li>Keep your OS and anti-virus software updated.</li>
<li>Do not download software and browser extensions from unverified sources.</li>
</ul>
<h2>Conclusion</h2>
<p>As the browser’s local storage is unprotected, the data stored there must be securely encrypted. Despite the fact that Surf uses reliable cryptographic libraries for the key derivation and the encryption, the sensitive data in the web version of Surf doesn’t appear to have adequate protection.</p>
<p>CPR’s PoC shows that the combination of the issues found presents several attack vectors that can lead to an attacker obtaining private keys and seed phrases in clear text, which can then be used to gain full control over the victim’s wallet.</p>
<p>Check Point Researchers collaborated with the Ever Surf teams which decided that the vulnerable web version will be deprecated and replaced with a desktop version. Ever Surf published an article about the new version in which they stated:</p>
<p>“Check Point Research conducted their own independent research about the security status of the Surf web version and found out its weakness. We followed this report, checked everything and ensured that the vulnerability exists. Our web version cannot provide a secure use of password-based KDF because of an inability to provide a unique salt such as device ID for that platform. In simple terms, that means there is a theoretical way to get access to your wallet and assets on it.</p>
<p>Therefore, we needed to take quick steps to eliminate it so as not to put our users at risk. It became clear that we cannot longer postpone the release of the Surf desktop app. Our basic idea was to wrap the existing web application into an Electron packager and pass a unique machineID inside in order to use its hash as a salt for the key derivation. </p>
<p>Thus we could save the familiar interface and everything you are used to in the web version. We didn’t want to ruin your user experience so you can still unlock the app with a short PIN instead of memorizing strong and heavy passwords. In the long run, desktop version gives options compared to the web version.”</p>
</div>