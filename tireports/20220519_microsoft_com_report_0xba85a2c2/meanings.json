{
    "title": "Rise in XorDdos: A deeper look at the stealthy DDoS malware targeting Linux devices",
    "url": "https://www.microsoft.com/security/blog/2022/05/19/rise-in-xorddos-a-deeper-look-at-the-stealthy-ddos-malware-targeting-linux-devices",
    "threats": {
        "Threat": [
            {
                "token": {
                    "id": "<THREAT_0x628e285a>",
                    "type": "Threat",
                    "value": "xorddos"
                },
                "references": {
                    "sentences": [
                        "As its name suggests, XorDdos uses XOR-based encryption to obfuscate data. It calls the dec_conf function to decode encoded strings using the XOR key BB2FA36AAA9541F0. The table below shows the decoded values of the obfuscated data used across the malwares various modules to conduct its activities.",
                        "Events with the following titles indicate threat activity related to XorDdos:",
                        "Our analysis determined two of XorDdos methods for initial access. The first method involves copying a malicious ELF file to temporary file storage /dev/shm and then running it. Files written at /dev/shm are deleted during system restart, thus concealing the source of infection during forensic analysis.",
                        "XorDdos may further illustrate another trend observed in various platforms, in which malware is used to deliver other dangerous threats. We found that devices first infected with XorDdos were later infected with additional malware such as the Tsunami backdoor, which further deploys the XMRig coin miner. While we did not observe XorDdos directly installing and distributing secondary payloads like Tsunami, its possible that the trojan is leveraged as a vector for follow-on activities.",
                        "The malware runs a command to install startup services that automatically run XorDdos at boot. The malwares LinuxExec_Argv2 subroutine runs the system API with the provided arguments.",
                        "Microsoft Defender for Endpoint detects and blocks XorDdos components and behavior as the following malware:",
                        "Some XorDdos samples install a kernel rootkit. A rootkit is a kernel module that hides the presence of malicious code by modifying operating systems data structures. The XorDdos kernel rootkit generally has following capabilities:",
                        "XorDdos contains modules with specific functionalities to evade detection, as detailed below.",
                        "Based on the debug symbols found in the rootkit, its likely that XorDdos rootkit code was inspired by an open-source project called rooty. The following table describes the symbols found in the rootkit and their corresponding functionalities:",
                        "DoS:Linux/Xorddos.A<crlf>DoS:Linux/Xorddos!rfn<crlf>Trojan:Linux/Xorddos<crlf>Trojan:Linux/Xorddos.AA<crlf>Trojan:Linux/Xorddos!rfn<crlf>Behavior:Linux/Xorddos.A",
                        "Adept at stealing sensitive data, installing a rootkit device, using various evasion and persistence mechanisms, and performing DDoS attacks, XorDdos enables adversaries to create potentially significant disruptions on target systems. Moreover, XorDdos may be used to bring in other dangerous threats or to provide a vector for follow-on activities.",
                        "XorDdos and other threats targeting Linux devices emphasize how crucial it is to have security solutions with comprehensive capabilities and complete visibility spanning numerous distributions of Linux operating systems. Microsoft Defender for Endpoint offers such visibility and protection to catch these emerging threats with its next-generation antimalware and endpoint detection and response (EDR) capabilities. Leveraging threat intelligence from integrated threat data, including client and cloud heuristics, machine learning models, memory scanning, and behavioral monitoring, Microsoft Defender for Endpoint can detect and remediate XorDdos and its multi-stage, modular attacks. This includes detecting and protecting against its use of a malicious shell script for initial access, its drop-and-execution of binaries from a world-writable location, and any potential follow-on activities on endpoints.",
                        "XorDdos propagates primarily via SSH brute force. It uses a malicious shell script to try various root credential combinations across thousands of servers until finding a match on a target Linux device. As a result, we see many failed sign-in attempts on devices successfully infected by the malware:",
                        "Whichever initial access method is used, the result is the same: the running of a malicious ELF file, which is the XorDdos malware. In the next section, we do a deep dive into the XorDdos payload.",
                        "In the last six months, we observed a 254% increase in activity from a Linux trojan called XorDdos. First discovered in 2014 by the research group MalwareMustDie, XorDdos was named after its denial-of-service-related activities on Linux endpoints and servers as well as its usage of XOR-based encryption for its communications.",
                        "A daemon process is a process that runs in the background rather than under the control of users and detaches itself from the controlling terminal, terminating only when the system is shut down. Similar to some Linux malware families, the XorDdos trojan uses daemon processes, as detailed below, to break process tree-based analysis:",
                        "XorDdos uses various persistence mechanisms to support different Linux distributions when automatically launching upon system startup, as detailed below.",
                        "To locate malicious activity related to XorDdos activity, run the following advanced hunting queries in Microsoft 365 Defender or Microsoft Defender Security Center:",
                        "When XorDdos is detected on a device, Microsoft 365 Defender raises an alert, which shows the complete attack chain, including the process tree, file information, user information, and prevention details.",
                        "This code path depicts the malwares standard workflow, which is also the typical workflow where XorDdos runs as part of the entries created in system start-up locations.",
                        "XorDdos uses evasion and persistence mechanisms that allow its operations to remain robust and stealthy. Its evasion capabilities include obfuscating the malwares activities, evading rule-based detection mechanisms and hash-based malicious file lookup, as well as using anti-forensic techniques to break process tree-based analysis. We observed in recent campaigns that XorDdos hides malicious activities from analysis by overwriting sensitive files with a null byte. It also includes various persistence mechanisms to support different Linux distributions.",
                        "Microsoft Defender for Endpoint protects against XorDdos by detecting and remediating the trojans multi-stage, modular attacks throughout its entire attack chain and any potential follow-on activities on endpoints. In this blog post, we detail our in-depth analysis of XorDdos to help defenders understand its techniques and protect their networks from this stealthy malware.",
                        "Figure 1. A typical attack vector for XorDdos malware",
                        "XorDdos payload analysis",
                        "XorDdos depicts the trend of malware increasingly targeting Linux-based operating systems, which are commonly deployed on cloud infrastructures and Internet of Things (IoT) devices. By compromising IoT and other internet-connected devices, XorDdos amasses botnets that can be used to carry out distributed denial-of-service (DDoS) attacks. Using a botnet to perform DDoS attacks can potentially create significant disruptions, such as the 2.4 Tbps DDoS attack Microsoft mitigated in August 2021. DDoS attacks in and of themselves can be highly problematic for numerous reasons, but such attacks can also be used as cover to hide further malicious activities, like deploying malware and infiltrating target systems.",
                        "The XorDdos payload we analyzed for this research is a 32-bit ELF file that was not stripped, meaning it contained debug symbols that detailed the malwares dedicated code for each of its activities. The inclusion of debug symbols makes it easier to debug and reverse engineer non-stripped binaries, as compared to stripped binaries that discard these symbols. In this case, the non-stripped binary includes the following source-code file names associated with the symbol table entries as part of the .strtab section in the ELF file:",
                        "Figure 18. Microsoft 365 Defender alert for detection of XorDdos malware",
                        "Botnets can also be used to compromise other devices, and XorDdos is known for using Secure Shell (SSH) brute force attacks to gain remote control on target devices. SSH is one of the most common protocols in IT infrastructures and enables encrypted communications over insecure networks for remote system administration purposes, making it an attractive vector for attackers. Once XorDdos identifies valid SSH credentials, it uses root privileges to run a script that downloads and installs XorDdos on the target device.",
                        "Figure 2. Failed sign-in attempts on a device affected by XorDdos",
                        "XorDdos has specific code paths corresponding to the number of arguments provided to the program. This flexibility makes its operation more robust and stealthy. The malware first runs without any argument and then later runs another instance with different arguments, such as PIDs and fake commands, to perform capabilities like clean-up, spoofing, and persistence.",
                        "XorDdos modular nature provides attackers with a versatile trojan capable of infecting a variety of Linux system architectures. Its SSH brute force attacks are a relatively simple yet effective technique for gaining root access over a number of potential targets.",
                        "When a process is launched, arguments are provided to its main function as null-terminated strings, where the first argument is always the process image path. To spoof its process name, XorDdos zeroes out all argument buffers while running and overrides its first argument buffer containing the image path with a fake command line, such as cat resolv.conf.",
                        "The timeline view displays all of the detection and prevention events associated with XorDdos, providing details such as the MITRE ATT&CK techniques and tactics, remediation status, and event entities graph."
                    ],
                    "titles": [
                        "Rise in XorDdos: A deeper look at the stealthy DDoS malware targeting Linux devices",
                        "Defending against Linux platform threats",
                        "Detection evasion capabilities",
                        "Initial access",
                        "Hunting queries",
                        "Argument-based code-flow",
                        "Persistence mechanisms",
                        "Detection details",
                        "XorDdos payload analysis",
                        "File information"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<URL_0x78e18023>",
                            "type": "Url",
                            "value": "http://aa.hostasa.org/config.rar"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x2ff279a6>",
                            "type": "Category",
                            "value": "phishing"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xd91561a2>",
                            "type": "Category",
                            "value": "botnet"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xc8b7ae0c>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "b5fba27a8e457c1ab6573c378171f057d151dc615d6a8d339195716fa9ac277a"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<TTP_0x10d0e446>",
                            "type": "TTP",
                            "value": "ta0003"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x7a1325f0>",
                            "type": "Threat",
                            "value": "xmrig_miner"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x1c03897b>",
                            "type": "Category",
                            "value": "rootkit"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x17feba75>",
                            "type": "Threat",
                            "value": "tsunami_botnet"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x151cee5c>",
                            "type": "Category",
                            "value": "trojan"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xe00d8c4>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "ef0a4c12d98dc0ad4db86aadd641389c7219f57f15642ed35b4443daf3ff8c1e"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x8f66bff6>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "359c41da1cbae573d2c99f7da9eeb03df135f018f6c660b4e44fbd2b4ddecd39"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x3dca1e53>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "d71ea3b98286d39a711b626f687f0d3fc852c3e3a05de3f51450fb8f7bd2b0d7"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xd685405a>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "e6c7eee304dfc29b19012ef6d31848c0b5bb07362691e4e9633c8581f1c2d65b"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x825ecaea>",
                            "type": "Category",
                            "value": "cryptomining"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x3610f5de>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "2b4500987d50a24ba5c118f506f2507362d6b5c63c80b1984b4ae86641779ff3"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x133026e0>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "cbb72e542e8f19240130fc9381c2351730d437d42926c6e68e056907c8456459"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<TTP_0x10d0e446>",
                            "type": "TTP",
                            "value": "ta0003"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x93894c6e>",
                            "type": "Category",
                            "value": "ddos"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<INDUSTRY_0xc57b659c>",
                            "type": "Industry",
                            "value": "iot"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x1a0456ec>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "6e506f32c6fb7b5d342d1382989ab191c6f21c2d311251d8f623814f468952cf"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x93894c6e>",
                            "type": "Category",
                            "value": "ddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xe528394f>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "c8f761d3ef7cd16ebe41042a0daf901c2fdffce96c8e9e1fa0d422c6e31332ea"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7373bc55>",
                            "type": "File",
                            "value": "seconds.unhides"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x38bac132>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "932feef3ab6fccb3502f900619b1f87e1cb44a7adab48f2c927ecdd67ff6830a"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xb15ba76>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "dc2b1cee161ebe90be68561755d99e66f454ad80b27cebe3d4773518ac45cbb7"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xe7de3a04>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "175667933088fbebcb62c8450993422ccc876495299173c646779a9e67501ff4"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<TTP_0x4ac053a1>",
                            "type": "TTP",
                            "value": "ta0001"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<TTP_0x4ac053a1>",
                            "type": "TTP",
                            "value": "ta0001"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x8a10eea2>",
                            "type": "Category",
                            "value": "scam"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<DOMAIN_0x79214987>",
                            "type": "Domain",
                            "value": "www.enoan2107.com:3306"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<HASHSET_0xb853bf31>",
                            "type": "HashSet",
                            "value": [
                                {
                                    "id": "<MD5_0xbd34a140>",
                                    "type": "Hash",
                                    "hash_type": "MD5",
                                    "value": "2dc6225a9d104a950fb33a74da262b93"
                                },
                                {
                                    "id": "<SHA256_0xdfc31533>",
                                    "type": "Hash",
                                    "hash_type": "SHA256",
                                    "value": "f2df54eb827f3c733d481ebb167a5bc77c5ae39a6bda7f340bb23b24dc9a4432"
                                },
                                {
                                    "id": "<SHA1_0x69d4f3f4>",
                                    "type": "Hash",
                                    "hash_type": "SHA1",
                                    "value": "f05194fb2b3978611b99cfbf5e5f1dd44cd5e04b"
                                }
                            ]
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x17feba75>",
                            "type": "Threat",
                            "value": "tsunami_botnet"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x235e860>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "53f062a93cf19aeaa2f8481b32118a31b658a126624abb8a7d82237884f0a394"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<TTP_0x10d0e446>",
                            "type": "TTP",
                            "value": "ta0003"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xe42cc34c>",
                            "type": "Category",
                            "value": "dns"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xd1a508ed>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "360a6258dd66a3ba595a93896d9b55d22406d02e5c02100e5a18382c54e7d5cd"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x4ab535f0>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "9d6f115f31ee71089cc85b18852974e349c68fad3276145dafd0076951f32489"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<TTP_0x4ac053a1>",
                            "type": "TTP",
                            "value": "ta0001"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x23485769>",
                            "type": "File",
                            "value": "hflggwyfsc.elf"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xc84f7c79>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "798577202477c0c233d4af51c4d8fb2f574ddb3c9d1d90325d359a84cb1bd51c"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x7a1325f0>",
                            "type": "Threat",
                            "value": "xmrig_miner"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        },
                        "relation": "use_industry",
                        "dst": {
                            "id": "<INDUSTRY_0xc57b659c>",
                            "type": "Industry",
                            "value": "iot"
                        }
                    },
                    {
                        "src": {
                            "id": "<DOMAIN_0xaf85ca38>",
                            "type": "Domain",
                            "value": "www.gzcfr5axf6.com:3306"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xbb3f44ca>",
                            "type": "File",
                            "value": "process.intends"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<THREAT_0x17feba75>",
                    "type": "Threat",
                    "value": "tsunami_botnet"
                },
                "references": {
                    "sentences": [
                        "XorDdos may further illustrate another trend observed in various platforms, in which malware is used to deliver other dangerous threats. We found that devices first infected with XorDdos were later infected with additional malware such as the Tsunami backdoor, which further deploys the XMRig coin miner. While we did not observe XorDdos directly installing and distributing secondary payloads like Tsunami, its possible that the trojan is leveraged as a vector for follow-on activities."
                    ],
                    "titles": [
                        "Rise in XorDdos: A deeper look at the stealthy DDoS malware targeting Linux devices"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<THREAT_0x17feba75>",
                            "type": "Threat",
                            "value": "tsunami_botnet"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x7a1325f0>",
                            "type": "Threat",
                            "value": "xmrig_miner"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x17feba75>",
                            "type": "Threat",
                            "value": "tsunami_botnet"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x93894c6e>",
                            "type": "Category",
                            "value": "ddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x17feba75>",
                            "type": "Threat",
                            "value": "tsunami_botnet"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x17feba75>",
                            "type": "Threat",
                            "value": "tsunami_botnet"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x17feba75>",
                            "type": "Threat",
                            "value": "tsunami_botnet"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<THREAT_0x7a1325f0>",
                    "type": "Threat",
                    "value": "xmrig_miner"
                },
                "references": {
                    "sentences": [
                        "XorDdos may further illustrate another trend observed in various platforms, in which malware is used to deliver other dangerous threats. We found that devices first infected with XorDdos were later infected with additional malware such as the Tsunami backdoor, which further deploys the XMRig coin miner. While we did not observe XorDdos directly installing and distributing secondary payloads like Tsunami, its possible that the trojan is leveraged as a vector for follow-on activities."
                    ],
                    "titles": [
                        "Rise in XorDdos: A deeper look at the stealthy DDoS malware targeting Linux devices"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<THREAT_0x7a1325f0>",
                            "type": "Threat",
                            "value": "xmrig_miner"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x93894c6e>",
                            "type": "Category",
                            "value": "ddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x17feba75>",
                            "type": "Threat",
                            "value": "tsunami_botnet"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x7a1325f0>",
                            "type": "Threat",
                            "value": "xmrig_miner"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x7a1325f0>",
                            "type": "Threat",
                            "value": "xmrig_miner"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x7a1325f0>",
                            "type": "Threat",
                            "value": "xmrig_miner"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x7a1325f0>",
                            "type": "Threat",
                            "value": "xmrig_miner"
                        }
                    }
                ]
            }
        ]
    },
    "ttps": {
        "TTP": [
            {
                "token": {
                    "id": "<TTP_0x4ac053a1>",
                    "type": "TTP",
                    "value": "ta0001"
                },
                "references": {
                    "sentences": [
                        "Initial access"
                    ],
                    "titles": [
                        "Initial access",
                        "Rise in XorDdos: A deeper look at the stealthy DDoS malware targeting Linux devices"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<TTP_0x4ac053a1>",
                            "type": "TTP",
                            "value": "ta0001"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<TTP_0x4ac053a1>",
                            "type": "TTP",
                            "value": "ta0001"
                        }
                    },
                    {
                        "src": {
                            "id": "<TTP_0x4ac053a1>",
                            "type": "TTP",
                            "value": "ta0001"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<TTP_0x4ac053a1>",
                            "type": "TTP",
                            "value": "ta0001"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<TTP_0x4ac053a1>",
                            "type": "TTP",
                            "value": "ta0001"
                        }
                    },
                    {
                        "src": {
                            "id": "<TTP_0x4ac053a1>",
                            "type": "TTP",
                            "value": "ta0001"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x93894c6e>",
                            "type": "Category",
                            "value": "ddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<TTP_0x4ac053a1>",
                            "type": "TTP",
                            "value": "ta0001"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<TTP_0x10d0e446>",
                    "type": "TTP",
                    "value": "ta0003"
                },
                "references": {
                    "sentences": [
                        "Persistence mechanisms"
                    ],
                    "titles": [
                        "Rise in XorDdos: A deeper look at the stealthy DDoS malware targeting Linux devices",
                        "Persistence mechanisms"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<TTP_0x10d0e446>",
                            "type": "TTP",
                            "value": "ta0003"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<TTP_0x10d0e446>",
                            "type": "TTP",
                            "value": "ta0003"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<TTP_0x10d0e446>",
                            "type": "TTP",
                            "value": "ta0003"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x93894c6e>",
                            "type": "Category",
                            "value": "ddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<TTP_0x10d0e446>",
                            "type": "TTP",
                            "value": "ta0003"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<TTP_0x10d0e446>",
                            "type": "TTP",
                            "value": "ta0003"
                        }
                    },
                    {
                        "src": {
                            "id": "<TTP_0x10d0e446>",
                            "type": "TTP",
                            "value": "ta0003"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    }
                ]
            }
        ]
    },
    "meanings": {
        "Category": [
            {
                "token": {
                    "id": "<CATEGORY_0x93894c6e>",
                    "type": "Category",
                    "value": "ddos"
                },
                "references": {
                    "sentences": [
                        "Adept at stealing sensitive data, installing a rootkit device, using various evasion and persistence mechanisms, and performing DDoS attacks, XorDdos enables adversaries to create potentially significant disruptions on target systems. Moreover, XorDdos may be used to bring in other dangerous threats or to provide a vector for follow-on activities.",
                        "XorDdos depicts the trend of malware increasingly targeting Linux-based operating systems, which are commonly deployed on cloud infrastructures and Internet of Things (IoT) devices. By compromising IoT and other internet-connected devices, XorDdos amasses botnets that can be used to carry out distributed denial-of-service (DDoS) attacks. Using a botnet to perform DDoS attacks can potentially create significant disruptions, such as the 2.4 Tbps DDoS attack Microsoft mitigated in August 2021. DDoS attacks in and of themselves can be highly problematic for numerous reasons, but such attacks can also be used as cover to hide further malicious activities, like deploying malware and infiltrating target systems.",
                        "DDoS attack thread pool",
                        "Invoking each thread internally calls the thread routine threadwork. Using the global variable g_stop and commands received from the C2 server, threadwork then sends crafted packets 65,535 times to perform a DDoS attack."
                    ],
                    "titles": [
                        "Rise in XorDdos: A deeper look at the stealthy DDoS malware targeting Linux devices",
                        "Malicious activity threads",
                        "DDoS attack thread pool",
                        "Defending against Linux platform threats"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<INDUSTRY_0xc57b659c>",
                            "type": "Industry",
                            "value": "iot"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x93894c6e>",
                            "type": "Category",
                            "value": "ddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x7a1325f0>",
                            "type": "Threat",
                            "value": "xmrig_miner"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x93894c6e>",
                            "type": "Category",
                            "value": "ddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<TTP_0x10d0e446>",
                            "type": "TTP",
                            "value": "ta0003"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x93894c6e>",
                            "type": "Category",
                            "value": "ddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x93894c6e>",
                            "type": "Category",
                            "value": "ddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x17feba75>",
                            "type": "Threat",
                            "value": "tsunami_botnet"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x93894c6e>",
                            "type": "Category",
                            "value": "ddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x93894c6e>",
                            "type": "Category",
                            "value": "ddos"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<TTP_0x4ac053a1>",
                            "type": "TTP",
                            "value": "ta0001"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x93894c6e>",
                            "type": "Category",
                            "value": "ddos"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0xf1a480bb>",
                    "type": "Category",
                    "value": "malware"
                },
                "references": {
                    "sentences": [
                        "In this code path, the malware uses process name spoofing to hide from the process tree by modifying its fake command line at runtime. It then hides its process by calling HidePidPort with command 1 and reads the content of the file on disk related to the current process.",
                        "As its name suggests, XorDdos uses XOR-based encryption to obfuscate data. It calls the dec_conf function to decode encoded strings using the XOR key BB2FA36AAA9541F0. The table below shows the decoded values of the obfuscated data used across the malwares various modules to conduct its activities.",
                        "AddService Creates the persistent auto-start entries previously mentioned so that the malware runs when the system starts.<crlf>HidePidPort Hides the malwares ports and processes.<crlf>CheckLKM Checks whether the rootkit device is active or not. It uses a similar IOCTL call with the number 0x9748712 and command 0 to find if the rootkit is active. If the rootkit is active, it uses the owner value 0xAD1473B8 and group value 0xAD1473B8 to change the ownership of dropped files with the function lchown(<filename>, 0xAD1473B8, 0xAD1473B8).<crlf>decrypt_remotestr Decodes remote URLs using the same XOR key, BB2FA36AAA9541F0, to decode config.rar and the other directories. After decoding the URLs, it adds them into a remote list, which is later used to communicate and fetch commands from the command and control (C2) server:www[.]enoan2107[.]com:3306www[.]gzcfr5axf6[.]com:3306",
                        "Encourage the use of Microsoft Edgeavailable on Linux and various platformsor other web browsers that support Microsoft Defender SmartScreen, which identifies and blocks malicious websites, including phishing sites, scam sites, and sites that contain exploits and host malware.<crlf>Use device discovery to find unmanaged Linux devices on your network and onboard them to Microsoft Defender for Endpoint.<crlf>Turn on cloud-delivered protection in Microsoft Defender Antivirus or the equivalent for your antivirus product to use cloud-based machine learning protections that can block a huge majority of new and unknown variants.<crlf>Run EDR in block mode so that Microsoft Defender for Endpoint can block malicious artifacts, even when your non-Microsoft antivirus doesnt detect the threat or when Microsoft Defender Antivirus is running in passive mode.<crlf>Enable network protection to prevent applications or users from accessing malicious domains and other malicious content on the internet.<crlf>Enable investigation and remediation in full automated mode to allow Microsoft Defender for Endpoint to take immediate action on alerts to resolve breaches, significantly reducing alert volume.",
                        "This code path is similar to the standard code path, with the main difference being that the malware runs from one of the following locations:",
                        "Once it runs from one of these locations, the malware calls the following functions to perform various tasks:",
                        "Our analysis determined two of XorDdos methods for initial access. The first method involves copying a malicious ELF file to temporary file storage /dev/shm and then running it. Files written at /dev/shm are deleted during system restart, thus concealing the source of infection during forensic analysis.",
                        "After creating persistent entries, deleting evidence of its activities, and decoding config.rar, the malware initializes a cyclic redundancy check (CRC) table followed by an unnamed semaphore using the sem_init API. This semaphore is initialized with apshared value set to 0, making the resultant semaphore shared between all the threads. The semaphore is used to maintain concurrency between threads accessing a shared object, such as kill_cfg data.",
                        "XorDdos may further illustrate another trend observed in various platforms, in which malware is used to deliver other dangerous threats. We found that devices first infected with XorDdos were later infected with additional malware such as the Tsunami backdoor, which further deploys the XMRig coin miner. While we did not observe XorDdos directly installing and distributing secondary payloads like Tsunami, its possible that the trojan is leveraged as a vector for follow-on activities.",
                        "The malware runs a command to install startup services that automatically run XorDdos at boot. The malwares LinuxExec_Argv2 subroutine runs the system API with the provided arguments.",
                        "Microsoft Defender for Endpoint detects and blocks XorDdos components and behavior as the following malware:",
                        "Some XorDdos samples install a kernel rootkit. A rootkit is a kernel module that hides the presence of malicious code by modifying operating systems data structures. The XorDdos kernel rootkit generally has following capabilities:",
                        "Malicious activity threads",
                        "The malware creates a cron script at the location /etc/cron.hourly/gcc.sh.The cron script passes parameters with the following content:",
                        "In this case, the malware has a provision for communicating with its rootkit component /proc/rs_dev by sending input and output control (IOCTL) calls with additional information to take appropriate action. IOCTL is one way to communicate between the user-mode service and kernel device driver. The malware uses the number 0x9748712 to uniquely identify its IOCTL calls from other IOCTL calls in the system.",
                        "Command-line of malicious process",
                        "The malware tries to hide its processes and ports using its kernel rootkit component. Hiding a process assists the malware in evading rule-based detections.",
                        "XorDdos and other threats targeting Linux devices emphasize how crucial it is to have security solutions with comprehensive capabilities and complete visibility spanning numerous distributions of Linux operating systems. Microsoft Defender for Endpoint offers such visibility and protection to catch these emerging threats with its next-generation antimalware and endpoint detection and response (EDR) capabilities. Leveraging threat intelligence from integrated threat data, including client and cloud heuristics, machine learning models, memory scanning, and behavioral monitoring, Microsoft Defender for Endpoint can detect and remediate XorDdos and its multi-stage, modular attacks. This includes detecting and protecting against its use of a malicious shell script for initial access, its drop-and-execution of binaries from a world-writable location, and any potential follow-on activities on endpoints.",
                        "XorDdos propagates primarily via SSH brute force. It uses a malicious shell script to try various root credential combinations across thousands of servers until finding a match on a target Linux device. As a result, we see many failed sign-in attempts on devices successfully infected by the malware:",
                        "Whichever initial access method is used, the result is the same: the running of a malicious ELF file, which is the XorDdos malware. In the next section, we do a deep dive into the XorDdos payload.",
                        "In the last six months, we observed a 254% increase in activity from a Linux trojan called XorDdos. First discovered in 2014 by the research group MalwareMustDie, XorDdos was named after its denial-of-service-related activities on Linux endpoints and servers as well as its usage of XOR-based encryption for its communications.",
                        "Reads the content of the file /var/run/gcc.pid to get a unique 32-byte magic string that identifies the device while connecting with the C2 server; if the file doesnt exist, then it creates the file and updates it with a random 32-byte string.<crlf>Calculates the CRC header, including details of the device such as the magic string, OS release version, malware version, rootkit presence, memory stats, CPU information, and LAN speed.<crlf>Encrypts the data and sends it to the C2 server.<crlf>Waits to receive any of the following commands from the C2 server and then acts on the command using the exec_packet subroutine.",
                        "The malware then initializes three threads to perform malicious activities, such as stopping a process, creating a TCP connection, and retrieving kill_cfg data.",
                        "A daemon process is a process that runs in the background rather than under the control of users and detaches itself from the controlling terminal, terminating only when the system is shut down. Similar to some Linux malware families, the XorDdos trojan uses daemon processes, as detailed below, to break process tree-based analysis:",
                        "To locate malicious activity related to XorDdos activity, run the following advanced hunting queries in Microsoft 365 Defender or Microsoft Defender Security Center:",
                        "The malware calls sysconf(_SC_NPROCESSORS_CONF) to fetch the number of processors in the device. It then creates threads with twice the number of processors found on the device.",
                        "Using the above example, the malware shares the 64-byte size memory segment with the IPC key 0xDA718716 to check for another malware process provided as an argument. If not found, it runs its own binary without any argument and calls the fork() API twice to make sure the grandchild process has no parent. This results in the grandchild process being adopted by the init process, which disconnects it from the process tree and acts as an anti-forensic technique.",
                        "This code path depicts the malwares standard workflow, which is also the typical workflow where XorDdos runs as part of the entries created in system start-up locations.",
                        "It also creates a copy of itself at the location /lib/libudev.so. To evade hash-based malicious file lookup, it performs the following steps, which modify the file hash to make every file unique:",
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum.",
                        "The malware spawns new dropped binaries with two additional arguments: a fake command line and its PIDs, for example:",
                        "Microsoft Defender for Endpoint protects against XorDdos by detecting and remediating the trojans multi-stage, modular attacks throughout its entire attack chain and any potential follow-on activities on endpoints. In this blog post, we detail our in-depth analysis of XorDdos to help defenders understand its techniques and protect their networks from this stealthy malware.",
                        "If the malware hides the $pid specific directory, it can conceal fetching the corresponding process from a user mode.",
                        "Figure 1. A typical attack vector for XorDdos malware",
                        "In this code path, the malware runs with another argument provided as the PID, for example:",
                        "Figure 13. The end of the malware file contains two random strings, wieegnexuk and yybrdajydg, indicating that the original malware binary was modified twice",
                        "Figure 15. Semaphore and malicious thread initialization",
                        "Iterates the following folders to find a writable directory:/bin /home /root /tmp /usr /etc<crlf>If a writable directory is found, changes the working directory to the discovered writable directory.<crlf>Uses the curl command to download the ELF file payload from the remote location hxxp://Ipv4PII_777789ffaa5b68638cdaea8ecfa10b24b326ed7d/1[.]txt and saves the file as ygljglkjgfg0.<crlf>Changes the file mode to executable.<crlf>Runs the ELF file payload.<crlf>Moves and renames the Wget binary to evade rule-based detections triggered by malicious usage of the Wget binary. In this case, it renames the Wget binary to good and moves the file to the following locations:mv /usr/bin/wget /usr/bin/good mv /bin/wget /bin/good<crlf>Attempts to download the ELF file payload for a second time, now only using the file good and not the Wget binary.<crlf>After running the ELF file, uses an anti-forensic technique that hides its past activity by overwriting the content of the following sensitive files with a newline character:",
                        "XorDdos depicts the trend of malware increasingly targeting Linux-based operating systems, which are commonly deployed on cloud infrastructures and Internet of Things (IoT) devices. By compromising IoT and other internet-connected devices, XorDdos amasses botnets that can be used to carry out distributed denial-of-service (DDoS) attacks. Using a botnet to perform DDoS attacks can potentially create significant disruptions, such as the 2.4 Tbps DDoS attack Microsoft mitigated in August 2021. DDoS attacks in and of themselves can be highly problematic for numerous reasons, but such attacks can also be used as cover to hide further malicious activities, like deploying malware and infiltrating target systems.",
                        "The malware first checks whether its running from the locations /usr/bin/, /bin/, or /tmp/. If its not running from these locations, then it creates and copies itself using a 10-character string name on those locations, as well as /lib/ and /var/run/.",
                        "Provide root access<crlf>Hide the kernel module<crlf>Hide the malwares processes<crlf>Hide the malwares network connections and ports",
                        "The XorDdos payload we analyzed for this research is a 32-bit ELF file that was not stripped, meaning it contained debug symbols that detailed the malwares dedicated code for each of its activities. The inclusion of debug symbols makes it easier to debug and reverse engineer non-stripped binaries, as compared to stripped binaries that discard these symbols. In this case, the non-stripped binary includes the following source-code file names associated with the symbol table entries as part of the .strtab section in the ELF file:",
                        "Figure 18. Microsoft 365 Defender alert for detection of XorDdos malware",
                        "The malware drops an init script at the location /etc/init.d. Init scripts are startup scripts used to run any program when the system starts up. They follow the Linux Standard Base (LSB)-style header section to include default runlevels, descriptions, and dependencies.",
                        "XorDdos has specific code paths corresponding to the number of arguments provided to the program. This flexibility makes its operation more robust and stealthy. The malware first runs without any argument and then later runs another instance with different arguments, such as PIDs and fake commands, to perform capabilities like clean-up, spoofing, and persistence.",
                        "The malware creates a symlink for the init script dropped at the location /etc/init.d/<base_file_name> with the directories associated with runlevels 1 through 5 at /etc/rc<run_level>.d/S90<base_file_name> and /etc/rc.d/rc<run_level>.d/S90<base_file_name>.",
                        "XorDdos uses evasion and persistence mechanisms that allow its operations to remain robust and stealthy. Its evasion capabilities include obfuscating the malwares activities, evading rule-based detection mechanisms and hash-based malicious file lookup, as well as using anti-forensic techniques to break process tree-based analysis. We observed in recent campaigns that XorDdos hides malicious activities from analysis by overwriting sensitive files with a null byte. It also includes various persistence mechanisms to support different Linux distributions."
                    ],
                    "titles": [
                        "Rise in XorDdos: A deeper look at the stealthy DDoS malware targeting Linux devices",
                        "Malicious activity threads",
                        "DDoS attack thread pool",
                        "Defending against Linux platform threats",
                        "Detection evasion capabilities",
                        "Initial access",
                        "Hunting queries",
                        "Argument-based code-flow",
                        "Persistence mechanisms",
                        "Detection details",
                        "XorDdos payload analysis"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<TTP_0x10d0e446>",
                            "type": "TTP",
                            "value": "ta0003"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<TTP_0x4ac053a1>",
                            "type": "TTP",
                            "value": "ta0001"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x7a1325f0>",
                            "type": "Threat",
                            "value": "xmrig_miner"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<TTP_0x10d0e446>",
                            "type": "TTP",
                            "value": "ta0003"
                        }
                    },
                    {
                        "src": {
                            "id": "<URL_0x78e18023>",
                            "type": "Url",
                            "value": "http://aa.hostasa.org/config.rar"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x17feba75>",
                            "type": "Threat",
                            "value": "tsunami_botnet"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<TTP_0x4ac053a1>",
                            "type": "TTP",
                            "value": "ta0001"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<INDUSTRY_0xc57b659c>",
                            "type": "Industry",
                            "value": "iot"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0x151cee5c>",
                    "type": "Category",
                    "value": "trojan"
                },
                "references": {
                    "sentences": [
                        "DoS:Linux/Xorddos.A<crlf>DoS:Linux/Xorddos!rfn<crlf>Trojan:Linux/Xorddos<crlf>Trojan:Linux/Xorddos.AA<crlf>Trojan:Linux/Xorddos!rfn<crlf>Behavior:Linux/Xorddos.A",
                        "In the last six months, we observed a 254% increase in activity from a Linux trojan called XorDdos. First discovered in 2014 by the research group MalwareMustDie, XorDdos was named after its denial-of-service-related activities on Linux endpoints and servers as well as its usage of XOR-based encryption for its communications.",
                        "XorDdos may further illustrate another trend observed in various platforms, in which malware is used to deliver other dangerous threats. We found that devices first infected with XorDdos were later infected with additional malware such as the Tsunami backdoor, which further deploys the XMRig coin miner. While we did not observe XorDdos directly installing and distributing secondary payloads like Tsunami, its possible that the trojan is leveraged as a vector for follow-on activities.",
                        "XorDdos modular nature provides attackers with a versatile trojan capable of infecting a variety of Linux system architectures. Its SSH brute force attacks are a relatively simple yet effective technique for gaining root access over a number of potential targets.",
                        "A daemon process is a process that runs in the background rather than under the control of users and detaches itself from the controlling terminal, terminating only when the system is shut down. Similar to some Linux malware families, the XorDdos trojan uses daemon processes, as detailed below, to break process tree-based analysis:"
                    ],
                    "titles": [
                        "Rise in XorDdos: A deeper look at the stealthy DDoS malware targeting Linux devices",
                        "Detection details",
                        "Detection evasion capabilities",
                        "Defending against Linux platform threats"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0x151cee5c>",
                            "type": "Category",
                            "value": "trojan"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0xd91561a2>",
                    "type": "Category",
                    "value": "botnet"
                },
                "references": {
                    "sentences": [
                        "XorDdos depicts the trend of malware increasingly targeting Linux-based operating systems, which are commonly deployed on cloud infrastructures and Internet of Things (IoT) devices. By compromising IoT and other internet-connected devices, XorDdos amasses botnets that can be used to carry out distributed denial-of-service (DDoS) attacks. Using a botnet to perform DDoS attacks can potentially create significant disruptions, such as the 2.4 Tbps DDoS attack Microsoft mitigated in August 2021. DDoS attacks in and of themselves can be highly problematic for numerous reasons, but such attacks can also be used as cover to hide further malicious activities, like deploying malware and infiltrating target systems.",
                        "Botnets can also be used to compromise other devices, and XorDdos is known for using Secure Shell (SSH) brute force attacks to gain remote control on target devices. SSH is one of the most common protocols in IT infrastructures and enables encrypted communications over insecure networks for remote system administration purposes, making it an attractive vector for attackers. Once XorDdos identifies valid SSH credentials, it uses root privileges to run a script that downloads and installs XorDdos on the target device."
                    ],
                    "titles": [
                        "Rise in XorDdos: A deeper look at the stealthy DDoS malware targeting Linux devices"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0xd91561a2>",
                            "type": "Category",
                            "value": "botnet"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0xb68aa214>",
                    "type": "Category",
                    "value": "rat"
                },
                "references": {
                    "sentences": [
                        "The content of libudev.so was collected into libudev.so.6<crlf>bash process performed System Information Discovery by invoking ifconfig<crlf>gcc.sh was executed after being dropped by HFLgGwYfSC.elf<crlf>A shell command was executed by crond<crlf>SUID/SGID process unix_chkpwd executed",
                        "Figure 20. Microsoft 365 Defender timeline with an event on a suspicious shell command run by crond after it was dropped from HFLgGwYfSC.elf",
                        "Botnets can also be used to compromise other devices, and XorDdos is known for using Secure Shell (SSH) brute force attacks to gain remote control on target devices. SSH is one of the most common protocols in IT infrastructures and enables encrypted communications over insecure networks for remote system administration purposes, making it an attractive vector for attackers. Once XorDdos identifies valid SSH credentials, it uses root privileges to run a script that downloads and installs XorDdos on the target device.",
                        "XorDdos and other threats targeting Linux devices emphasize how crucial it is to have security solutions with comprehensive capabilities and complete visibility spanning numerous distributions of Linux operating systems. Microsoft Defender for Endpoint offers such visibility and protection to catch these emerging threats with its next-generation antimalware and endpoint detection and response (EDR) capabilities. Leveraging threat intelligence from integrated threat data, including client and cloud heuristics, machine learning models, memory scanning, and behavioral monitoring, Microsoft Defender for Endpoint can detect and remediate XorDdos and its multi-stage, modular attacks. This includes detecting and protecting against its use of a malicious shell script for initial access, its drop-and-execution of binaries from a world-writable location, and any potential follow-on activities on endpoints.",
                        "Ratnesh Pandey, Yevgeny Kulakov, and Jonathan Bar Or<crlf>Microsoft 365 Defender Research Team",
                        "XorDdos propagates primarily via SSH brute force. It uses a malicious shell script to try various root credential combinations across thousands of servers until finding a match on a target Linux device. As a result, we see many failed sign-in attempts on devices successfully infected by the malware:",
                        "A daemon process is a process that runs in the background rather than under the control of users and detaches itself from the controlling terminal, terminating only when the system is shut down. Similar to some Linux malware families, the XorDdos trojan uses daemon processes, as detailed below, to break process tree-based analysis:"
                    ],
                    "titles": [
                        "Rise in XorDdos: A deeper look at the stealthy DDoS malware targeting Linux devices",
                        "Dropped files",
                        "Download URLs",
                        "Detection evasion capabilities",
                        "Defending against Linux platform threats",
                        "Initial access",
                        "Detection details"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x1a0456ec>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "6e506f32c6fb7b5d342d1382989ab191c6f21c2d311251d8f623814f468952cf"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x133026e0>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "cbb72e542e8f19240130fc9381c2351730d437d42926c6e68e056907c8456459"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<TTP_0x4ac053a1>",
                            "type": "TTP",
                            "value": "ta0001"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x23485769>",
                            "type": "File",
                            "value": "hflggwyfsc.elf"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0x96121f83>",
                    "type": "Category",
                    "value": "backdoor"
                },
                "references": {
                    "sentences": [
                        "XorDdos may further illustrate another trend observed in various platforms, in which malware is used to deliver other dangerous threats. We found that devices first infected with XorDdos were later infected with additional malware such as the Tsunami backdoor, which further deploys the XMRig coin miner. While we did not observe XorDdos directly installing and distributing secondary payloads like Tsunami, its possible that the trojan is leveraged as a vector for follow-on activities."
                    ],
                    "titles": [
                        "Rise in XorDdos: A deeper look at the stealthy DDoS malware targeting Linux devices"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0x96121f83>",
                            "type": "Category",
                            "value": "backdoor"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0x825ecaea>",
                    "type": "Category",
                    "value": "cryptomining"
                },
                "references": {
                    "sentences": [
                        "XorDdos may further illustrate another trend observed in various platforms, in which malware is used to deliver other dangerous threats. We found that devices first infected with XorDdos were later infected with additional malware such as the Tsunami backdoor, which further deploys the XMRig coin miner. While we did not observe XorDdos directly installing and distributing secondary payloads like Tsunami, its possible that the trojan is leveraged as a vector for follow-on activities."
                    ],
                    "titles": [
                        "Rise in XorDdos: A deeper look at the stealthy DDoS malware targeting Linux devices"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0x825ecaea>",
                            "type": "Category",
                            "value": "cryptomining"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0xe42cc34c>",
                    "type": "Category",
                    "value": "dns"
                },
                "references": {
                    "sentences": [
                        "crtstuff.c<crlf>autorun.c<crlf>crc32.c<crlf>encrypt.c<crlf>execpacket.c<crlf>buildnet.c<crlf>hide.c<crlf>http.c<crlf>kill.c<crlf>main.c<crlf>proc.c<crlf>socket.c<crlf>tcp.c<crlf>thread.c<crlf>findip.c<crlf>dns.c"
                    ],
                    "titles": [
                        "DDoS attack thread pool",
                        "XorDdos payload analysis"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0xe42cc34c>",
                            "type": "Category",
                            "value": "dns"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0x1c03897b>",
                    "type": "Category",
                    "value": "rootkit"
                },
                "references": {
                    "sentences": [
                        "InstallSYS The name suggests that this function is a wrapper that should deploy a rootkit driver, but it only zeroes-out two local arrays.",
                        "AddService Creates the persistent auto-start entries previously mentioned so that the malware runs when the system starts.<crlf>HidePidPort Hides the malwares ports and processes.<crlf>CheckLKM Checks whether the rootkit device is active or not. It uses a similar IOCTL call with the number 0x9748712 and command 0 to find if the rootkit is active. If the rootkit is active, it uses the owner value 0xAD1473B8 and group value 0xAD1473B8 to change the ownership of dropped files with the function lchown(<filename>, 0xAD1473B8, 0xAD1473B8).<crlf>decrypt_remotestr Decodes remote URLs using the same XOR key, BB2FA36AAA9541F0, to decode config.rar and the other directories. After decoding the URLs, it adds them into a remote list, which is later used to communicate and fetch commands from the command and control (C2) server:www[.]enoan2107[.]com:3306www[.]gzcfr5axf6[.]com:3306",
                        "Based on the debug symbols found in the rootkit, its likely that XorDdos rootkit code was inspired by an open-source project called rooty. The following table describes the symbols found in the rootkit and their corresponding functionalities:",
                        "In this case, the malware has a provision for communicating with its rootkit component /proc/rs_dev by sending input and output control (IOCTL) calls with additional information to take appropriate action. IOCTL is one way to communicate between the user-mode service and kernel device driver. The malware uses the number 0x9748712 to uniquely identify its IOCTL calls from other IOCTL calls in the system.",
                        "Kernel rootkit",
                        "Adept at stealing sensitive data, installing a rootkit device, using various evasion and persistence mechanisms, and performing DDoS attacks, XorDdos enables adversaries to create potentially significant disruptions on target systems. Moreover, XorDdos may be used to bring in other dangerous threats or to provide a vector for follow-on activities.",
                        "The malware tries to hide its processes and ports using its kernel rootkit component. Hiding a process assists the malware in evading rule-based detections.",
                        "Reads the content of the file /var/run/gcc.pid to get a unique 32-byte magic string that identifies the device while connecting with the C2 server; if the file doesnt exist, then it creates the file and updates it with a random 32-byte string.<crlf>Calculates the CRC header, including details of the device such as the magic string, OS release version, malware version, rootkit presence, memory stats, CPU information, and LAN speed.<crlf>Encrypts the data and sends it to the C2 server.<crlf>Waits to receive any of the following commands from the C2 server and then acts on the command using the exec_packet subroutine.",
                        "Some XorDdos samples install a kernel rootkit. A rootkit is a kernel module that hides the presence of malicious code by modifying operating systems data structures. The XorDdos kernel rootkit generally has following capabilities:"
                    ],
                    "titles": [
                        "Dropped files",
                        "Malicious activity threads",
                        "Defending against Linux platform threats",
                        "Detection evasion capabilities",
                        "Argument-based code-flow"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xe528394f>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "c8f761d3ef7cd16ebe41042a0daf901c2fdffce96c8e9e1fa0d422c6e31332ea"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x1c03897b>",
                            "type": "Category",
                            "value": "rootkit"
                        }
                    },
                    {
                        "src": {
                            "id": "<CATEGORY_0x1c03897b>",
                            "type": "Category",
                            "value": "rootkit"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0xc8ecca29>",
                    "type": "Category",
                    "value": "c2"
                },
                "references": {
                    "sentences": [
                        "Reads the content of the file /var/run/gcc.pid to get a unique 32-byte magic string that identifies the device while connecting with the C2 server; if the file doesnt exist, then it creates the file and updates it with a random 32-byte string.<crlf>Calculates the CRC header, including details of the device such as the magic string, OS release version, malware version, rootkit presence, memory stats, CPU information, and LAN speed.<crlf>Encrypts the data and sends it to the C2 server.<crlf>Waits to receive any of the following commands from the C2 server and then acts on the command using the exec_packet subroutine.",
                        "Invoking each thread internally calls the thread routine threadwork. Using the global variable g_stop and commands received from the C2 server, threadwork then sends crafted packets 65,535 times to perform a DDoS attack.",
                        "The tcp_thread triggers the connection with the C2 server decoded earlier using decrypt_remotestr(). It performs the following tasks:",
                        "AddService Creates the persistent auto-start entries previously mentioned so that the malware runs when the system starts.<crlf>HidePidPort Hides the malwares ports and processes.<crlf>CheckLKM Checks whether the rootkit device is active or not. It uses a similar IOCTL call with the number 0x9748712 and command 0 to find if the rootkit is active. If the rootkit is active, it uses the owner value 0xAD1473B8 and group value 0xAD1473B8 to change the ownership of dropped files with the function lchown(<filename>, 0xAD1473B8, 0xAD1473B8).<crlf>decrypt_remotestr Decodes remote URLs using the same XOR key, BB2FA36AAA9541F0, to decode config.rar and the other directories. After decoding the URLs, it adds them into a remote list, which is later used to communicate and fetch commands from the command and control (C2) server:www[.]enoan2107[.]com:3306www[.]gzcfr5axf6[.]com:3306"
                    ],
                    "titles": [
                        "Malicious activity threads",
                        "DDoS attack thread pool",
                        "Argument-based code-flow"
                    ]
                }
            },
            {
                "token": {
                    "id": "<CATEGORY_0x2ff279a6>",
                    "type": "Category",
                    "value": "phishing"
                },
                "references": {
                    "sentences": [
                        "Encourage the use of Microsoft Edgeavailable on Linux and various platformsor other web browsers that support Microsoft Defender SmartScreen, which identifies and blocks malicious websites, including phishing sites, scam sites, and sites that contain exploits and host malware.<crlf>Use device discovery to find unmanaged Linux devices on your network and onboard them to Microsoft Defender for Endpoint.<crlf>Turn on cloud-delivered protection in Microsoft Defender Antivirus or the equivalent for your antivirus product to use cloud-based machine learning protections that can block a huge majority of new and unknown variants.<crlf>Run EDR in block mode so that Microsoft Defender for Endpoint can block malicious artifacts, even when your non-Microsoft antivirus doesnt detect the threat or when Microsoft Defender Antivirus is running in passive mode.<crlf>Enable network protection to prevent applications or users from accessing malicious domains and other malicious content on the internet.<crlf>Enable investigation and remediation in full automated mode to allow Microsoft Defender for Endpoint to take immediate action on alerts to resolve breaches, significantly reducing alert volume."
                    ],
                    "titles": [
                        "Defending against Linux platform threats"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0x2ff279a6>",
                            "type": "Category",
                            "value": "phishing"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<CATEGORY_0x8a10eea2>",
                    "type": "Category",
                    "value": "scam"
                },
                "references": {
                    "sentences": [
                        "Encourage the use of Microsoft Edgeavailable on Linux and various platformsor other web browsers that support Microsoft Defender SmartScreen, which identifies and blocks malicious websites, including phishing sites, scam sites, and sites that contain exploits and host malware.<crlf>Use device discovery to find unmanaged Linux devices on your network and onboard them to Microsoft Defender for Endpoint.<crlf>Turn on cloud-delivered protection in Microsoft Defender Antivirus or the equivalent for your antivirus product to use cloud-based machine learning protections that can block a huge majority of new and unknown variants.<crlf>Run EDR in block mode so that Microsoft Defender for Endpoint can block malicious artifacts, even when your non-Microsoft antivirus doesnt detect the threat or when Microsoft Defender Antivirus is running in passive mode.<crlf>Enable network protection to prevent applications or users from accessing malicious domains and other malicious content on the internet.<crlf>Enable investigation and remediation in full automated mode to allow Microsoft Defender for Endpoint to take immediate action on alerts to resolve breaches, significantly reducing alert volume."
                    ],
                    "titles": [
                        "Defending against Linux platform threats"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<CATEGORY_0x8a10eea2>",
                            "type": "Category",
                            "value": "scam"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    }
                ]
            }
        ],
        "Industry": [
            {
                "token": {
                    "id": "<INDUSTRY_0xc57b659c>",
                    "type": "Industry",
                    "value": "iot"
                },
                "references": {
                    "sentences": [
                        "XorDdos depicts the trend of malware increasingly targeting Linux-based operating systems, which are commonly deployed on cloud infrastructures and Internet of Things (IoT) devices. By compromising IoT and other internet-connected devices, XorDdos amasses botnets that can be used to carry out distributed denial-of-service (DDoS) attacks. Using a botnet to perform DDoS attacks can potentially create significant disruptions, such as the 2.4 Tbps DDoS attack Microsoft mitigated in August 2021. DDoS attacks in and of themselves can be highly problematic for numerous reasons, but such attacks can also be used as cover to hide further malicious activities, like deploying malware and infiltrating target systems."
                    ],
                    "titles": [
                        "Rise in XorDdos: A deeper look at the stealthy DDoS malware targeting Linux devices"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<INDUSTRY_0xc57b659c>",
                            "type": "Industry",
                            "value": "iot"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x93894c6e>",
                            "type": "Category",
                            "value": "ddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<INDUSTRY_0xc57b659c>",
                            "type": "Industry",
                            "value": "iot"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        },
                        "relation": "use_industry",
                        "dst": {
                            "id": "<INDUSTRY_0xc57b659c>",
                            "type": "Industry",
                            "value": "iot"
                        }
                    },
                    {
                        "src": {
                            "id": "<INDUSTRY_0xc57b659c>",
                            "type": "Industry",
                            "value": "iot"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    }
                ]
            }
        ]
    },
    "iocs": {
        "File": [
            {
                "token": {
                    "id": "<FILE_0x132cf0c2>",
                    "type": "File",
                    "value": "resolv.conf"
                },
                "references": {
                    "sentences": [
                        "cat resolv.conf<crlf>netstat -an<crlf>bash<crlf>whoami<crlf>id<crlf>cd /etc<crlf>ifconfig eth0<crlf>ifconfig<crlf>echo find<crlf>uptime<crlf>sh<crlf>top<crlf>gnome-terminal<crlf>su<crlf>netstat -antop<crlf>grep A<crlf>who<crlf>ls -la<crlf>pwd<crlf>route -n<crlf>ps -ef<crlf>ls<crlf>sleep 1",
                        "Figure 6. Output of the ps -aef contains an entry for cat resolv.conf",
                        "/usr/bin/jwvwvxoupv cat resolv.conf 4849<crlf>/usr/bin/jwvwvxoupv gnome-terminal 4849<crlf>/usr/bin/jwvwvxoupv top 4849<crlf>/usr/bin/jwvwvxoupv pwd 4849<crlf>/usr/bin/kagbjahdic id 4849",
                        "DeviceProcessEvents<crlf>| where ProcessCommandLine contains \"cat resolv.conf\"",
                        "When a process is launched, arguments are provided to its main function as null-terminated strings, where the first argument is always the process image path. To spoof its process name, XorDdos zeroes out all argument buffers while running and overrides its first argument buffer containing the image path with a fake command line, such as cat resolv.conf."
                    ],
                    "titles": [
                        "Hunting queries",
                        "Argument-based code-flow",
                        "Detection evasion capabilities"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd682ee5f>",
                            "type": "UnknownWord",
                            "value": "ff3ve"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcfffbed9>",
                            "type": "UnknownWord",
                            "value": "-7"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9454329b>",
                            "type": "UnknownWord",
                            "value": "_"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x38e3d7d7>",
                            "type": "UnknownWord",
                            "value": "zeroes"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x405af380>",
                            "type": "UnknownWord",
                            "value": "overrides"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbbe44895>",
                            "type": "UnknownWord",
                            "value": "processcommandline"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x11c34425>",
                            "type": "UnknownWord",
                            "value": "jwvwvxoupv"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa6ac9dd4>",
                            "type": "UnknownWord",
                            "value": "x17v"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x43215109>",
                            "type": "UnknownWord",
                            "value": "cat"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2d11d5d5>",
                            "type": "UnknownWord",
                            "value": "-aef"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0x6aec4444>",
                    "type": "File",
                    "value": "argument.deletes"
                },
                "references": {
                    "sentences": [
                        "Fetches the file name specific to the $pid provided as part of the third argument by calling the readlink API on /proc/$pid/exe.If the readlink call fails, that likely indicates that the file on disk doesnt exist. In this case, it:Calls the stat API for the file /lib/libudev.so. If the stat API returns a non-zero value, then it attempts to copy the content of the current processs image-file fetched earlier to the following locations with a random name:If the readlink call is successful and returns the count of bytes copied, sleeps for one second and then loops for the remaining time out of five seconds.Unhides the current process and the $pid that was provided as part of the third argument.Deletes the on-disk file for the current process.Intends to delete all service-related entries for the $pid but fails. This appears to be due to a code flaw that allows a zeroed-out buffer to be passed as a service name when the buffer is supposed to be filled from a successful readlink API call.<crlf>Creates directories similar to the standard code path scenario.<crlf>/usr/bin/<crlf>/bin/<crlf>/tmp/<crlf>Copies the /lib/libudev.so file to the same three directories listed above if the stat API call is successful on /lib/libudev.so.<crlf>Changes the hash of the written or copied file and then runs it without passing any parameters.",
                        "Fetches the process file name corresponding to the provided $pidDeletes the file for the provided $pidDeletes the installed init services:Ends the process that was provided as an argument.Deletes /etc/init.d/<file_name><crlf>For runlevels 1-5, unlinks and deletes /etc/rc<runlevel>.d/S90<file_name><crlf>Performs the command chkconfig del <file_name><crlf>Performs the command update-rc.d <file_name> remove"
                    ],
                    "titles": [
                        "Argument-based code-flow"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1e4c0bd7>",
                            "type": "UnknownWord",
                            "value": "readlink"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x665b92c6>",
                            "type": "UnknownWord",
                            "value": "<file_name>"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe93107f8>",
                            "type": "UnknownWord",
                            "value": "service-related"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe539604a>",
                            "type": "UnknownWord",
                            "value": "pid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbace30a4>",
                            "type": "UnknownWord",
                            "value": "stat"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x55b3a03a>",
                            "type": "UnknownWord",
                            "value": "fetched"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4faa7172>",
                            "type": "UnknownWord",
                            "value": "non-zero"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x90299db1>",
                            "type": "UnknownWord",
                            "value": "piddeletes"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbd76d9c5>",
                            "type": "UnknownWord",
                            "value": "on-disk"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd67f6c51>",
                            "type": "UnknownWord",
                            "value": "image-file"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0x7373bc55>",
                    "type": "File",
                    "value": "seconds.unhides"
                },
                "references": {
                    "sentences": [
                        "Fetches the file name specific to the $pid provided as part of the third argument by calling the readlink API on /proc/$pid/exe.If the readlink call fails, that likely indicates that the file on disk doesnt exist. In this case, it:Calls the stat API for the file /lib/libudev.so. If the stat API returns a non-zero value, then it attempts to copy the content of the current processs image-file fetched earlier to the following locations with a random name:If the readlink call is successful and returns the count of bytes copied, sleeps for one second and then loops for the remaining time out of five seconds.Unhides the current process and the $pid that was provided as part of the third argument.Deletes the on-disk file for the current process.Intends to delete all service-related entries for the $pid but fails. This appears to be due to a code flaw that allows a zeroed-out buffer to be passed as a service name when the buffer is supposed to be filled from a successful readlink API call.<crlf>Creates directories similar to the standard code path scenario.<crlf>/usr/bin/<crlf>/bin/<crlf>/tmp/<crlf>Copies the /lib/libudev.so file to the same three directories listed above if the stat API call is successful on /lib/libudev.so.<crlf>Changes the hash of the written or copied file and then runs it without passing any parameters."
                    ],
                    "titles": [
                        "Argument-based code-flow"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x7373bc55>",
                            "type": "File",
                            "value": "seconds.unhides"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbd76d9c5>",
                            "type": "UnknownWord",
                            "value": "on-disk"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7373bc55>",
                            "type": "File",
                            "value": "seconds.unhides"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4faa7172>",
                            "type": "UnknownWord",
                            "value": "non-zero"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7373bc55>",
                            "type": "File",
                            "value": "seconds.unhides"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1e4c0bd7>",
                            "type": "UnknownWord",
                            "value": "readlink"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7373bc55>",
                            "type": "File",
                            "value": "seconds.unhides"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe93107f8>",
                            "type": "UnknownWord",
                            "value": "service-related"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7373bc55>",
                            "type": "File",
                            "value": "seconds.unhides"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe539604a>",
                            "type": "UnknownWord",
                            "value": "pid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7373bc55>",
                            "type": "File",
                            "value": "seconds.unhides"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x55b3a03a>",
                            "type": "UnknownWord",
                            "value": "fetched"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7373bc55>",
                            "type": "File",
                            "value": "seconds.unhides"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbace30a4>",
                            "type": "UnknownWord",
                            "value": "stat"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7373bc55>",
                            "type": "File",
                            "value": "seconds.unhides"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7373bc55>",
                            "type": "File",
                            "value": "seconds.unhides"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd67f6c51>",
                            "type": "UnknownWord",
                            "value": "image-file"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0xbb3f44ca>",
                    "type": "File",
                    "value": "process.intends"
                },
                "references": {
                    "sentences": [
                        "Fetches the file name specific to the $pid provided as part of the third argument by calling the readlink API on /proc/$pid/exe.If the readlink call fails, that likely indicates that the file on disk doesnt exist. In this case, it:Calls the stat API for the file /lib/libudev.so. If the stat API returns a non-zero value, then it attempts to copy the content of the current processs image-file fetched earlier to the following locations with a random name:If the readlink call is successful and returns the count of bytes copied, sleeps for one second and then loops for the remaining time out of five seconds.Unhides the current process and the $pid that was provided as part of the third argument.Deletes the on-disk file for the current process.Intends to delete all service-related entries for the $pid but fails. This appears to be due to a code flaw that allows a zeroed-out buffer to be passed as a service name when the buffer is supposed to be filled from a successful readlink API call.<crlf>Creates directories similar to the standard code path scenario.<crlf>/usr/bin/<crlf>/bin/<crlf>/tmp/<crlf>Copies the /lib/libudev.so file to the same three directories listed above if the stat API call is successful on /lib/libudev.so.<crlf>Changes the hash of the written or copied file and then runs it without passing any parameters."
                    ],
                    "titles": [
                        "Argument-based code-flow"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xbb3f44ca>",
                            "type": "File",
                            "value": "process.intends"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbd76d9c5>",
                            "type": "UnknownWord",
                            "value": "on-disk"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xbb3f44ca>",
                            "type": "File",
                            "value": "process.intends"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4faa7172>",
                            "type": "UnknownWord",
                            "value": "non-zero"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xbb3f44ca>",
                            "type": "File",
                            "value": "process.intends"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1e4c0bd7>",
                            "type": "UnknownWord",
                            "value": "readlink"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xbb3f44ca>",
                            "type": "File",
                            "value": "process.intends"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe93107f8>",
                            "type": "UnknownWord",
                            "value": "service-related"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xbb3f44ca>",
                            "type": "File",
                            "value": "process.intends"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe539604a>",
                            "type": "UnknownWord",
                            "value": "pid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xbb3f44ca>",
                            "type": "File",
                            "value": "process.intends"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbace30a4>",
                            "type": "UnknownWord",
                            "value": "stat"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xbb3f44ca>",
                            "type": "File",
                            "value": "process.intends"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x55b3a03a>",
                            "type": "UnknownWord",
                            "value": "fetched"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xbb3f44ca>",
                            "type": "File",
                            "value": "process.intends"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xbb3f44ca>",
                            "type": "File",
                            "value": "process.intends"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd67f6c51>",
                            "type": "UnknownWord",
                            "value": "image-file"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0x66e19c4e>",
                    "type": "File",
                    "value": "config.rar"
                },
                "references": {
                    "sentences": [
                        "AddService Creates the persistent auto-start entries previously mentioned so that the malware runs when the system starts.<crlf>HidePidPort Hides the malwares ports and processes.<crlf>CheckLKM Checks whether the rootkit device is active or not. It uses a similar IOCTL call with the number 0x9748712 and command 0 to find if the rootkit is active. If the rootkit is active, it uses the owner value 0xAD1473B8 and group value 0xAD1473B8 to change the ownership of dropped files with the function lchown(<filename>, 0xAD1473B8, 0xAD1473B8).<crlf>decrypt_remotestr Decodes remote URLs using the same XOR key, BB2FA36AAA9541F0, to decode config.rar and the other directories. After decoding the URLs, it adds them into a remote list, which is later used to communicate and fetch commands from the command and control (C2) server:www[.]enoan2107[.]com:3306www[.]gzcfr5axf6[.]com:3306",
                        "After creating persistent entries, deleting evidence of its activities, and decoding config.rar, the malware initializes a cyclic redundancy check (CRC) table followed by an unnamed semaphore using the sem_init API. This semaphore is initialized with apshared value set to 0, making the resultant semaphore shared between all the threads. The semaphore is used to maintain concurrency between threads accessing a shared object, such as kill_cfg data."
                    ],
                    "titles": [
                        "Malicious activity threads",
                        "Argument-based code-flow"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x76b2e5cf>",
                            "type": "UnknownWord",
                            "value": "decrypt_remotestr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc4b1ceb>",
                            "type": "UnknownWord",
                            "value": "cyclic"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9fe4dc66>",
                            "type": "UnknownWord",
                            "value": "crc"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3293ee27>",
                            "type": "UnknownWord",
                            "value": "semaphore"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x89147a11>",
                            "type": "UnknownWord",
                            "value": "initializes"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x102bb0e3>",
                            "type": "UnknownWord",
                            "value": "bb2fa36aaa9541f0"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc69a003c>",
                            "type": "UnknownWord",
                            "value": "sem_init"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3ff27b2>",
                            "type": "UnknownWord",
                            "value": "redundancy"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<FILE_0x23485769>",
                    "type": "File",
                    "value": "hflggwyfsc.elf"
                },
                "references": {
                    "sentences": [
                        "The content of libudev.so was collected into libudev.so.6<crlf>bash process performed System Information Discovery by invoking ifconfig<crlf>gcc.sh was executed after being dropped by HFLgGwYfSC.elf<crlf>A shell command was executed by crond<crlf>SUID/SGID process unix_chkpwd executed",
                        "Figure 20. Microsoft 365 Defender timeline with an event on a suspicious shell command run by crond after it was dropped from HFLgGwYfSC.elf",
                        "Figure 19. Microsoft 365 Defender timeline displaying that HFLgGwYfSC.elf was run from a world-writable directory and the remediation of dropped binaries"
                    ],
                    "titles": [
                        "Detection details",
                        "File information"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x23485769>",
                            "type": "File",
                            "value": "hflggwyfsc.elf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1c1586af>",
                            "type": "UnknownWord",
                            "value": "crond"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x23485769>",
                            "type": "File",
                            "value": "hflggwyfsc.elf"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x23485769>",
                            "type": "File",
                            "value": "hflggwyfsc.elf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa1646ff5>",
                            "type": "UnknownWord",
                            "value": "displaying"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x23485769>",
                            "type": "File",
                            "value": "hflggwyfsc.elf"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x23485769>",
                            "type": "File",
                            "value": "hflggwyfsc.elf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3cb76839>",
                            "type": "UnknownWord",
                            "value": "world-writable"
                        }
                    }
                ]
            }
        ],
        "Url": [
            {
                "token": {
                    "id": "<URL_0x78e18023>",
                    "type": "Url",
                    "value": "http://aa.hostasa.org/config.rar"
                },
                "references": {
                    "sentences": [
                        "The daemon_get_killed_processthread downloads the kill_cfg data from the remote URL decoded earlier (hxxp://aa[.]hostasa[.]org/config[.]rar) and decrypts it using the same XOR key previously mentioned. It then sleeps for 30 minutes.",
                        "www[.]enoan2107[.]com:3306<crlf>www[.]gzcfr5axf6[.]com:3306<crlf>hxxp://aa[.]hostasa[.]org/config.rar"
                    ],
                    "titles": [
                        "Malicious activity threads",
                        "Detection evasion capabilities",
                        "Download URLs"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<URL_0x78e18023>",
                            "type": "Url",
                            "value": "http://aa.hostasa.org/config.rar"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<URL_0x78e18023>",
                            "type": "Url",
                            "value": "http://aa.hostasa.org/config.rar"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xf1a480bb>",
                            "type": "Category",
                            "value": "malware"
                        }
                    },
                    {
                        "src": {
                            "id": "<URL_0x78e18023>",
                            "type": "Url",
                            "value": "http://aa.hostasa.org/config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x73a88e92>",
                            "type": "UnknownWord",
                            "value": "kill_cfg"
                        }
                    },
                    {
                        "src": {
                            "id": "<URL_0x78e18023>",
                            "type": "Url",
                            "value": "http://aa.hostasa.org/config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xee30f9bd>",
                            "type": "UnknownWord",
                            "value": "<encrypted_remote_url>"
                        }
                    },
                    {
                        "src": {
                            "id": "<URL_0x78e18023>",
                            "type": "Url",
                            "value": "http://aa.hostasa.org/config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8b8bd435>",
                            "type": "UnknownWord",
                            "value": "daemon_get_killed_processthread"
                        }
                    }
                ]
            }
        ],
        "Hash": [
            {
                "token": {
                    "id": "<SHA256_0x1a0456ec>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "6e506f32c6fb7b5d342d1382989ab191c6f21c2d311251d8f623814f468952cf"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Dropped files"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x1a0456ec>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "6e506f32c6fb7b5d342d1382989ab191c6f21c2d311251d8f623814f468952cf"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x1a0456ec>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "6e506f32c6fb7b5d342d1382989ab191c6f21c2d311251d8f623814f468952cf"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x1a0456ec>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "6e506f32c6fb7b5d342d1382989ab191c6f21c2d311251d8f623814f468952cf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x67b8622d>",
                            "type": "UnknownWord",
                            "value": "hflggwyfsc"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0x133026e0>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "cbb72e542e8f19240130fc9381c2351730d437d42926c6e68e056907c8456459"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Dropped files"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x133026e0>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "cbb72e542e8f19240130fc9381c2351730d437d42926c6e68e056907c8456459"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x208a9862>",
                            "type": "UnknownWord",
                            "value": "hourly"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x133026e0>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "cbb72e542e8f19240130fc9381c2351730d437d42926c6e68e056907c8456459"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xaca99cc6>",
                            "type": "UnknownWord",
                            "value": "gcc"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x133026e0>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "cbb72e542e8f19240130fc9381c2351730d437d42926c6e68e056907c8456459"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x133026e0>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "cbb72e542e8f19240130fc9381c2351730d437d42926c6e68e056907c8456459"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0xb68aa214>",
                            "type": "Category",
                            "value": "rat"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0x38bac132>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "932feef3ab6fccb3502f900619b1f87e1cb44a7adab48f2c927ecdd67ff6830a"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Dropped files"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x38bac132>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "932feef3ab6fccb3502f900619b1f87e1cb44a7adab48f2c927ecdd67ff6830a"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x38bac132>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "932feef3ab6fccb3502f900619b1f87e1cb44a7adab48f2c927ecdd67ff6830a"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe539604a>",
                            "type": "UnknownWord",
                            "value": "pid"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x38bac132>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "932feef3ab6fccb3502f900619b1f87e1cb44a7adab48f2c927ecdd67ff6830a"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xaca99cc6>",
                            "type": "UnknownWord",
                            "value": "gcc"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0x235e860>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "53f062a93cf19aeaa2f8481b32118a31b658a126624abb8a7d82237884f0a394"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Dropped files"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x235e860>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "53f062a93cf19aeaa2f8481b32118a31b658a126624abb8a7d82237884f0a394"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x235e860>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "53f062a93cf19aeaa2f8481b32118a31b658a126624abb8a7d82237884f0a394"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x878437ca>",
                            "type": "UnknownWord",
                            "value": "djtctpzfdq"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x235e860>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "53f062a93cf19aeaa2f8481b32118a31b658a126624abb8a7d82237884f0a394"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0xc84f7c79>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "798577202477c0c233d4af51c4d8fb2f574ddb3c9d1d90325d359a84cb1bd51c"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Dropped files"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xc84f7c79>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "798577202477c0c233d4af51c4d8fb2f574ddb3c9d1d90325d359a84cb1bd51c"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xc84f7c79>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "798577202477c0c233d4af51c4d8fb2f574ddb3c9d1d90325d359a84cb1bd51c"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xc84f7c79>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "798577202477c0c233d4af51c4d8fb2f574ddb3c9d1d90325d359a84cb1bd51c"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3992499e>",
                            "type": "UnknownWord",
                            "value": "dmpyuitfoq"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0x3610f5de>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "2b4500987d50a24ba5c118f506f2507362d6b5c63c80b1984b4ae86641779ff3"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Dropped files"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x3610f5de>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "2b4500987d50a24ba5c118f506f2507362d6b5c63c80b1984b4ae86641779ff3"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x3610f5de>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "2b4500987d50a24ba5c118f506f2507362d6b5c63c80b1984b4ae86641779ff3"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x90dc2b31>",
                            "type": "UnknownWord",
                            "value": "fdinprytpq"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x3610f5de>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "2b4500987d50a24ba5c118f506f2507362d6b5c63c80b1984b4ae86641779ff3"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0x8f66bff6>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "359c41da1cbae573d2c99f7da9eeb03df135f018f6c660b4e44fbd2b4ddecd39"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Dropped files"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x8f66bff6>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "359c41da1cbae573d2c99f7da9eeb03df135f018f6c660b4e44fbd2b4ddecd39"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x11c34425>",
                            "type": "UnknownWord",
                            "value": "jwvwvxoupv"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x8f66bff6>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "359c41da1cbae573d2c99f7da9eeb03df135f018f6c660b4e44fbd2b4ddecd39"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x8f66bff6>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "359c41da1cbae573d2c99f7da9eeb03df135f018f6c660b4e44fbd2b4ddecd39"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0xd685405a>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "e6c7eee304dfc29b19012ef6d31848c0b5bb07362691e4e9633c8581f1c2d65b"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Dropped files"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xd685405a>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "e6c7eee304dfc29b19012ef6d31848c0b5bb07362691e4e9633c8581f1c2d65b"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xd685405a>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "e6c7eee304dfc29b19012ef6d31848c0b5bb07362691e4e9633c8581f1c2d65b"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xd685405a>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "e6c7eee304dfc29b19012ef6d31848c0b5bb07362691e4e9633c8581f1c2d65b"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7ee7cd76>",
                            "type": "UnknownWord",
                            "value": "bin kagbjahdic"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0xe00d8c4>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "ef0a4c12d98dc0ad4db86aadd641389c7219f57f15642ed35b4443daf3ff8c1e"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Dropped files"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xe00d8c4>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "ef0a4c12d98dc0ad4db86aadd641389c7219f57f15642ed35b4443daf3ff8c1e"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8149d1b0>",
                            "type": "UnknownWord",
                            "value": "kkldnszwvq"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xe00d8c4>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "ef0a4c12d98dc0ad4db86aadd641389c7219f57f15642ed35b4443daf3ff8c1e"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xe00d8c4>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "ef0a4c12d98dc0ad4db86aadd641389c7219f57f15642ed35b4443daf3ff8c1e"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0xc8b7ae0c>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "b5fba27a8e457c1ab6573c378171f057d151dc615d6a8d339195716fa9ac277a"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Dropped files"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xc8b7ae0c>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "b5fba27a8e457c1ab6573c378171f057d151dc615d6a8d339195716fa9ac277a"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xc8b7ae0c>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "b5fba27a8e457c1ab6573c378171f057d151dc615d6a8d339195716fa9ac277a"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xc8b7ae0c>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "b5fba27a8e457c1ab6573c378171f057d151dc615d6a8d339195716fa9ac277a"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa237fe76>",
                            "type": "UnknownWord",
                            "value": "bin kndmhuqmah"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0x3dca1e53>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "d71ea3b98286d39a711b626f687f0d3fc852c3e3a05de3f51450fb8f7bd2b0d7"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Dropped files"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x3dca1e53>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "d71ea3b98286d39a711b626f687f0d3fc852c3e3a05de3f51450fb8f7bd2b0d7"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x3dca1e53>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "d71ea3b98286d39a711b626f687f0d3fc852c3e3a05de3f51450fb8f7bd2b0d7"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa63218a2>",
                            "type": "UnknownWord",
                            "value": "qkxqoelrfa"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x3dca1e53>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "d71ea3b98286d39a711b626f687f0d3fc852c3e3a05de3f51450fb8f7bd2b0d7"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0x4ab535f0>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "9d6f115f31ee71089cc85b18852974e349c68fad3276145dafd0076951f32489"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Dropped files"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x4ab535f0>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "9d6f115f31ee71089cc85b18852974e349c68fad3276145dafd0076951f32489"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x4ab535f0>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "9d6f115f31ee71089cc85b18852974e349c68fad3276145dafd0076951f32489"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x4ab535f0>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "9d6f115f31ee71089cc85b18852974e349c68fad3276145dafd0076951f32489"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x70222711>",
                            "type": "UnknownWord",
                            "value": "sykhrxsazz"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0xd1a508ed>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "360a6258dd66a3ba595a93896d9b55d22406d02e5c02100e5a18382c54e7d5cd"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Dropped files"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xd1a508ed>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "360a6258dd66a3ba595a93896d9b55d22406d02e5c02100e5a18382c54e7d5cd"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xd1a508ed>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "360a6258dd66a3ba595a93896d9b55d22406d02e5c02100e5a18382c54e7d5cd"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5684c029>",
                            "type": "UnknownWord",
                            "value": "tcnszvmpqn"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xd1a508ed>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "360a6258dd66a3ba595a93896d9b55d22406d02e5c02100e5a18382c54e7d5cd"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0xb15ba76>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "dc2b1cee161ebe90be68561755d99e66f454ad80b27cebe3d4773518ac45cbb7"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Dropped files"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xb15ba76>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "dc2b1cee161ebe90be68561755d99e66f454ad80b27cebe3d4773518ac45cbb7"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x49484bbc>",
                            "type": "UnknownWord",
                            "value": "bin zalkpggsgh"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xb15ba76>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "dc2b1cee161ebe90be68561755d99e66f454ad80b27cebe3d4773518ac45cbb7"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xb15ba76>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "dc2b1cee161ebe90be68561755d99e66f454ad80b27cebe3d4773518ac45cbb7"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0xe7de3a04>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "175667933088fbebcb62c8450993422ccc876495299173c646779a9e67501ff4"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Dropped files"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xe7de3a04>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "175667933088fbebcb62c8450993422ccc876495299173c646779a9e67501ff4"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xe7de3a04>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "175667933088fbebcb62c8450993422ccc876495299173c646779a9e67501ff4"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xe7de3a04>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "175667933088fbebcb62c8450993422ccc876495299173c646779a9e67501ff4"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x39e1865a>",
                            "type": "UnknownWord",
                            "value": "bin zvcarxfquk"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<SHA256_0xe528394f>",
                    "type": "Hash",
                    "hash_type": "SHA256",
                    "value": "c8f761d3ef7cd16ebe41042a0daf901c2fdffce96c8e9e1fa0d422c6e31332ea"
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Dropped files"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xe528394f>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "c8f761d3ef7cd16ebe41042a0daf901c2fdffce96c8e9e1fa0d422c6e31332ea"
                        },
                        "relation": "has_category",
                        "dst": {
                            "id": "<CATEGORY_0x1c03897b>",
                            "type": "Category",
                            "value": "rootkit"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xe528394f>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "c8f761d3ef7cd16ebe41042a0daf901c2fdffce96c8e9e1fa0d422c6e31332ea"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xe528394f>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "c8f761d3ef7cd16ebe41042a0daf901c2fdffce96c8e9e1fa0d422c6e31332ea"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x230cac2f>",
                            "type": "UnknownWord",
                            "value": "bin 3200"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<HASHSET_0xb853bf31>",
                    "type": "HashSet",
                    "value": [
                        {
                            "id": "<MD5_0xbd34a140>",
                            "type": "Hash",
                            "hash_type": "MD5",
                            "value": "2dc6225a9d104a950fb33a74da262b93"
                        },
                        {
                            "id": "<SHA256_0xdfc31533>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "f2df54eb827f3c733d481ebb167a5bc77c5ae39a6bda7f340bb23b24dc9a4432"
                        },
                        {
                            "id": "<SHA1_0x69d4f3f4>",
                            "type": "Hash",
                            "hash_type": "SHA1",
                            "value": "f05194fb2b3978611b99cfbf5e5f1dd44cd5e04b"
                        }
                    ]
                },
                "references": {
                    "sentences": [],
                    "titles": [
                        "Dropped files",
                        "File information"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<HASHSET_0xb853bf31>",
                            "type": "HashSet",
                            "value": [
                                {
                                    "id": "<MD5_0xbd34a140>",
                                    "type": "Hash",
                                    "hash_type": "MD5",
                                    "value": "2dc6225a9d104a950fb33a74da262b93"
                                },
                                {
                                    "id": "<SHA256_0xdfc31533>",
                                    "type": "Hash",
                                    "hash_type": "SHA256",
                                    "value": "f2df54eb827f3c733d481ebb167a5bc77c5ae39a6bda7f340bb23b24dc9a4432"
                                },
                                {
                                    "id": "<SHA1_0x69d4f3f4>",
                                    "type": "Hash",
                                    "hash_type": "SHA1",
                                    "value": "f05194fb2b3978611b99cfbf5e5f1dd44cd5e04b"
                                }
                            ]
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    },
                    {
                        "src": {
                            "id": "<HASHSET_0xb853bf31>",
                            "type": "HashSet",
                            "value": [
                                {
                                    "id": "<MD5_0xbd34a140>",
                                    "type": "Hash",
                                    "hash_type": "MD5",
                                    "value": "2dc6225a9d104a950fb33a74da262b93"
                                },
                                {
                                    "id": "<SHA256_0xdfc31533>",
                                    "type": "Hash",
                                    "hash_type": "SHA256",
                                    "value": "f2df54eb827f3c733d481ebb167a5bc77c5ae39a6bda7f340bb23b24dc9a4432"
                                },
                                {
                                    "id": "<SHA1_0x69d4f3f4>",
                                    "type": "Hash",
                                    "hash_type": "SHA1",
                                    "value": "f05194fb2b3978611b99cfbf5e5f1dd44cd5e04b"
                                }
                            ]
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc16db613>",
                            "type": "UnknownWord",
                            "value": "lib libudev"
                        }
                    }
                ]
            }
        ],
        "Domain": [
            {
                "token": {
                    "id": "<DOMAIN_0x79214987>",
                    "type": "Domain",
                    "value": "www.enoan2107.com:3306"
                },
                "references": {
                    "sentences": [
                        "www[.]enoan2107[.]com:3306<crlf>www[.]gzcfr5axf6[.]com:3306<crlf>hxxp://aa[.]hostasa[.]org/config.rar"
                    ],
                    "titles": [
                        "Download URLs"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<DOMAIN_0x79214987>",
                            "type": "Domain",
                            "value": "www.enoan2107.com:3306"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<DOMAIN_0xaf85ca38>",
                    "type": "Domain",
                    "value": "www.gzcfr5axf6.com:3306"
                },
                "references": {
                    "sentences": [
                        "www[.]enoan2107[.]com:3306<crlf>www[.]gzcfr5axf6[.]com:3306<crlf>hxxp://aa[.]hostasa[.]org/config.rar"
                    ],
                    "titles": [
                        "Download URLs"
                    ]
                },
                "links": [
                    {
                        "src": {
                            "id": "<DOMAIN_0xaf85ca38>",
                            "type": "Domain",
                            "value": "www.gzcfr5axf6.com:3306"
                        },
                        "relation": "use_threat",
                        "dst": {
                            "id": "<THREAT_0x628e285a>",
                            "type": "Threat",
                            "value": "xorddos"
                        }
                    }
                ]
            }
        ]
    },
    "unknownwords": {
        "UnknownWord": [
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbda2c4f2>",
                    "type": "UnknownWord",
                    "value": "argument-based"
                },
                "references": {
                    "sentences": [
                        "Argument-based code-flow",
                        "Before handling the argument-based control, it calls the readlink API with the first parameter as /proc/self/exe to fetch its full process path. The full path is used later to create auto-start service entries and read the files content."
                    ],
                    "titles": [
                        "Argument-based code-flow"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x83ffc035>",
                    "type": "UnknownWord",
                    "value": "code-flow"
                },
                "references": {
                    "sentences": [
                        "Argument-based code-flow"
                    ],
                    "titles": [
                        "Argument-based code-flow"
                    ]
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc7e22489>",
                    "type": "UnknownWord",
                    "value": "denial-of-service-related"
                },
                "references": {
                    "sentences": [
                        "In the last six months, we observed a 254% increase in activity from a Linux trojan called XorDdos. First discovered in 2014 by the research group MalwareMustDie, XorDdos was named after its denial-of-service-related activities on Linux endpoints and servers as well as its usage of XOR-based encryption for its communications."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3a6ede7a>",
                    "type": "UnknownWord",
                    "value": "xor-based"
                },
                "references": {
                    "sentences": [
                        "In the last six months, we observed a 254% increase in activity from a Linux trojan called XorDdos. First discovered in 2014 by the research group MalwareMustDie, XorDdos was named after its denial-of-service-related activities on Linux endpoints and servers as well as its usage of XOR-based encryption for its communications.",
                        "XOR-based encryption",
                        "As its name suggests, XorDdos uses XOR-based encryption to obfuscate data. It calls the dec_conf function to decode encoded strings using the XOR key BB2FA36AAA9541F0. The table below shows the decoded values of the obfuscated data used across the malwares various modules to conduct its activities."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2ca70cc6>",
                    "type": "UnknownWord",
                    "value": "depicts"
                },
                "references": {
                    "sentences": [
                        "XorDdos depicts the trend of malware increasingly targeting Linux-based operating systems, which are commonly deployed on cloud infrastructures and Internet of Things (IoT) devices. By compromising IoT and other internet-connected devices, XorDdos amasses botnets that can be used to carry out distributed denial-of-service (DDoS) attacks. Using a botnet to perform DDoS attacks can potentially create significant disruptions, such as the 2.4 Tbps DDoS attack Microsoft mitigated in August 2021. DDoS attacks in and of themselves can be highly problematic for numerous reasons, but such attacks can also be used as cover to hide further malicious activities, like deploying malware and infiltrating target systems.",
                        "This code path depicts the malwares standard workflow, which is also the typical workflow where XorDdos runs as part of the entries created in system start-up locations."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4670b763>",
                    "type": "UnknownWord",
                    "value": "linux-based"
                },
                "references": {
                    "sentences": [
                        "XorDdos depicts the trend of malware increasingly targeting Linux-based operating systems, which are commonly deployed on cloud infrastructures and Internet of Things (IoT) devices. By compromising IoT and other internet-connected devices, XorDdos amasses botnets that can be used to carry out distributed denial-of-service (DDoS) attacks. Using a botnet to perform DDoS attacks can potentially create significant disruptions, such as the 2.4 Tbps DDoS attack Microsoft mitigated in August 2021. DDoS attacks in and of themselves can be highly problematic for numerous reasons, but such attacks can also be used as cover to hide further malicious activities, like deploying malware and infiltrating target systems."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb911f116>",
                    "type": "UnknownWord",
                    "value": "internet-connected"
                },
                "references": {
                    "sentences": [
                        "XorDdos depicts the trend of malware increasingly targeting Linux-based operating systems, which are commonly deployed on cloud infrastructures and Internet of Things (IoT) devices. By compromising IoT and other internet-connected devices, XorDdos amasses botnets that can be used to carry out distributed denial-of-service (DDoS) attacks. Using a botnet to perform DDoS attacks can potentially create significant disruptions, such as the 2.4 Tbps DDoS attack Microsoft mitigated in August 2021. DDoS attacks in and of themselves can be highly problematic for numerous reasons, but such attacks can also be used as cover to hide further malicious activities, like deploying malware and infiltrating target systems."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1cbbc309>",
                    "type": "UnknownWord",
                    "value": "amasses"
                },
                "references": {
                    "sentences": [
                        "XorDdos depicts the trend of malware increasingly targeting Linux-based operating systems, which are commonly deployed on cloud infrastructures and Internet of Things (IoT) devices. By compromising IoT and other internet-connected devices, XorDdos amasses botnets that can be used to carry out distributed denial-of-service (DDoS) attacks. Using a botnet to perform DDoS attacks can potentially create significant disruptions, such as the 2.4 Tbps DDoS attack Microsoft mitigated in August 2021. DDoS attacks in and of themselves can be highly problematic for numerous reasons, but such attacks can also be used as cover to hide further malicious activities, like deploying malware and infiltrating target systems."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x89f91124>",
                    "type": "UnknownWord",
                    "value": "denial-of-service"
                },
                "references": {
                    "sentences": [
                        "XorDdos depicts the trend of malware increasingly targeting Linux-based operating systems, which are commonly deployed on cloud infrastructures and Internet of Things (IoT) devices. By compromising IoT and other internet-connected devices, XorDdos amasses botnets that can be used to carry out distributed denial-of-service (DDoS) attacks. Using a botnet to perform DDoS attacks can potentially create significant disruptions, such as the 2.4 Tbps DDoS attack Microsoft mitigated in August 2021. DDoS attacks in and of themselves can be highly problematic for numerous reasons, but such attacks can also be used as cover to hide further malicious activities, like deploying malware and infiltrating target systems."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3fff9d35>",
                    "type": "UnknownWord",
                    "value": "tbps"
                },
                "references": {
                    "sentences": [
                        "XorDdos depicts the trend of malware increasingly targeting Linux-based operating systems, which are commonly deployed on cloud infrastructures and Internet of Things (IoT) devices. By compromising IoT and other internet-connected devices, XorDdos amasses botnets that can be used to carry out distributed denial-of-service (DDoS) attacks. Using a botnet to perform DDoS attacks can potentially create significant disruptions, such as the 2.4 Tbps DDoS attack Microsoft mitigated in August 2021. DDoS attacks in and of themselves can be highly problematic for numerous reasons, but such attacks can also be used as cover to hide further malicious activities, like deploying malware and infiltrating target systems."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x33057df2>",
                    "type": "UnknownWord",
                    "value": "problematic"
                },
                "references": {
                    "sentences": [
                        "XorDdos depicts the trend of malware increasingly targeting Linux-based operating systems, which are commonly deployed on cloud infrastructures and Internet of Things (IoT) devices. By compromising IoT and other internet-connected devices, XorDdos amasses botnets that can be used to carry out distributed denial-of-service (DDoS) attacks. Using a botnet to perform DDoS attacks can potentially create significant disruptions, such as the 2.4 Tbps DDoS attack Microsoft mitigated in August 2021. DDoS attacks in and of themselves can be highly problematic for numerous reasons, but such attacks can also be used as cover to hide further malicious activities, like deploying malware and infiltrating target systems."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6b5b7db5>",
                    "type": "UnknownWord",
                    "value": "rule-based"
                },
                "references": {
                    "sentences": [
                        "Iterates the following folders to find a writable directory:/bin /home /root /tmp /usr /etc<crlf>If a writable directory is found, changes the working directory to the discovered writable directory.<crlf>Uses the curl command to download the ELF file payload from the remote location hxxp://Ipv4PII_777789ffaa5b68638cdaea8ecfa10b24b326ed7d/1[.]txt and saves the file as ygljglkjgfg0.<crlf>Changes the file mode to executable.<crlf>Runs the ELF file payload.<crlf>Moves and renames the Wget binary to evade rule-based detections triggered by malicious usage of the Wget binary. In this case, it renames the Wget binary to good and moves the file to the following locations:mv /usr/bin/wget /usr/bin/good mv /bin/wget /bin/good<crlf>Attempts to download the ELF file payload for a second time, now only using the file good and not the Wget binary.<crlf>After running the ELF file, uses an anti-forensic technique that hides its past activity by overwriting the content of the following sensitive files with a newline character:",
                        "The malware tries to hide its processes and ports using its kernel rootkit component. Hiding a process assists the malware in evading rule-based detections.",
                        "XorDdos uses evasion and persistence mechanisms that allow its operations to remain robust and stealthy. Its evasion capabilities include obfuscating the malwares activities, evading rule-based detection mechanisms and hash-based malicious file lookup, as well as using anti-forensic techniques to break process tree-based analysis. We observed in recent campaigns that XorDdos hides malicious activities from analysis by overwriting sensitive files with a null byte. It also includes various persistence mechanisms to support different Linux distributions."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd1a6fa6>",
                    "type": "UnknownWord",
                    "value": "hash-based"
                },
                "references": {
                    "sentences": [
                        "It also creates a copy of itself at the location /lib/libudev.so. To evade hash-based malicious file lookup, it performs the following steps, which modify the file hash to make every file unique:",
                        "XorDdos uses evasion and persistence mechanisms that allow its operations to remain robust and stealthy. Its evasion capabilities include obfuscating the malwares activities, evading rule-based detection mechanisms and hash-based malicious file lookup, as well as using anti-forensic techniques to break process tree-based analysis. We observed in recent campaigns that XorDdos hides malicious activities from analysis by overwriting sensitive files with a null byte. It also includes various persistence mechanisms to support different Linux distributions."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x60cf3f31>",
                    "type": "UnknownWord",
                    "value": "lookup"
                },
                "references": {
                    "sentences": [
                        "XorDdos uses evasion and persistence mechanisms that allow its operations to remain robust and stealthy. Its evasion capabilities include obfuscating the malwares activities, evading rule-based detection mechanisms and hash-based malicious file lookup, as well as using anti-forensic techniques to break process tree-based analysis. We observed in recent campaigns that XorDdos hides malicious activities from analysis by overwriting sensitive files with a null byte. It also includes various persistence mechanisms to support different Linux distributions."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x42935e66>",
                    "type": "UnknownWord",
                    "value": "break"
                },
                "references": {
                    "sentences": [
                        "A daemon process is a process that runs in the background rather than under the control of users and detaches itself from the controlling terminal, terminating only when the system is shut down. Similar to some Linux malware families, the XorDdos trojan uses daemon processes, as detailed below, to break process tree-based analysis:",
                        "XorDdos uses evasion and persistence mechanisms that allow its operations to remain robust and stealthy. Its evasion capabilities include obfuscating the malwares activities, evading rule-based detection mechanisms and hash-based malicious file lookup, as well as using anti-forensic techniques to break process tree-based analysis. We observed in recent campaigns that XorDdos hides malicious activities from analysis by overwriting sensitive files with a null byte. It also includes various persistence mechanisms to support different Linux distributions."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc62551aa>",
                    "type": "UnknownWord",
                    "value": "tree-based"
                },
                "references": {
                    "sentences": [
                        "A daemon process is a process that runs in the background rather than under the control of users and detaches itself from the controlling terminal, terminating only when the system is shut down. Similar to some Linux malware families, the XorDdos trojan uses daemon processes, as detailed below, to break process tree-based analysis:",
                        "XorDdos uses evasion and persistence mechanisms that allow its operations to remain robust and stealthy. Its evasion capabilities include obfuscating the malwares activities, evading rule-based detection mechanisms and hash-based malicious file lookup, as well as using anti-forensic techniques to break process tree-based analysis. We observed in recent campaigns that XorDdos hides malicious activities from analysis by overwriting sensitive files with a null byte. It also includes various persistence mechanisms to support different Linux distributions."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe7e6d002>",
                    "type": "UnknownWord",
                    "value": "remediating"
                },
                "references": {
                    "sentences": [
                        "Microsoft Defender for Endpoint protects against XorDdos by detecting and remediating the trojans multi-stage, modular attacks throughout its entire attack chain and any potential follow-on activities on endpoints. In this blog post, we detail our in-depth analysis of XorDdos to help defenders understand its techniques and protect their networks from this stealthy malware."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbe4a55>",
                    "type": "UnknownWord",
                    "value": "dev"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum.",
                        "Our analysis determined two of XorDdos methods for initial access. The first method involves copying a malicious ELF file to temporary file storage /dev/shm and then running it. Files written at /dev/shm are deleted during system restart, thus concealing the source of infection during forensic analysis."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xde6573c8>",
                    "type": "UnknownWord",
                    "value": "shm"
                },
                "references": {
                    "sentences": [
                        "Our analysis determined two of XorDdos methods for initial access. The first method involves copying a malicious ELF file to temporary file storage /dev/shm and then running it. Files written at /dev/shm are deleted during system restart, thus concealing the source of infection during forensic analysis."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x10866ca4>",
                    "type": "UnknownWord",
                    "value": "concealing"
                },
                "references": {
                    "sentences": [
                        "Our analysis determined two of XorDdos methods for initial access. The first method involves copying a malicious ELF file to temporary file storage /dev/shm and then running it. Files written at /dev/shm are deleted during system restart, thus concealing the source of infection during forensic analysis."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1470e3ba>",
                    "type": "UnknownWord",
                    "value": "writable"
                },
                "references": {
                    "sentences": [
                        "Iterates the following folders to find a writable directory:/bin /home /root /tmp /usr /etc<crlf>If a writable directory is found, changes the working directory to the discovered writable directory.<crlf>Uses the curl command to download the ELF file payload from the remote location hxxp://Ipv4PII_777789ffaa5b68638cdaea8ecfa10b24b326ed7d/1[.]txt and saves the file as ygljglkjgfg0.<crlf>Changes the file mode to executable.<crlf>Runs the ELF file payload.<crlf>Moves and renames the Wget binary to evade rule-based detections triggered by malicious usage of the Wget binary. In this case, it renames the Wget binary to good and moves the file to the following locations:mv /usr/bin/wget /usr/bin/good mv /bin/wget /bin/good<crlf>Attempts to download the ELF file payload for a second time, now only using the file good and not the Wget binary.<crlf>After running the ELF file, uses an anti-forensic technique that hides its past activity by overwriting the content of the following sensitive files with a newline character:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x42030cbf>",
                    "type": "UnknownWord",
                    "value": "usr"
                },
                "references": {
                    "sentences": [
                        "Iterates the following folders to find a writable directory:/bin /home /root /tmp /usr /etc<crlf>If a writable directory is found, changes the working directory to the discovered writable directory.<crlf>Uses the curl command to download the ELF file payload from the remote location hxxp://Ipv4PII_777789ffaa5b68638cdaea8ecfa10b24b326ed7d/1[.]txt and saves the file as ygljglkjgfg0.<crlf>Changes the file mode to executable.<crlf>Runs the ELF file payload.<crlf>Moves and renames the Wget binary to evade rule-based detections triggered by malicious usage of the Wget binary. In this case, it renames the Wget binary to good and moves the file to the following locations:mv /usr/bin/wget /usr/bin/good mv /bin/wget /bin/good<crlf>Attempts to download the ELF file payload for a second time, now only using the file good and not the Wget binary.<crlf>After running the ELF file, uses an anti-forensic technique that hides its past activity by overwriting the content of the following sensitive files with a newline character:",
                        "/usr/bin/<crlf>/bin/<crlf>/tmp/",
                        "/usr/bin/jwvwvxoupv 4849",
                        "The malware first checks whether its running from the locations /usr/bin/, /bin/, or /tmp/. If its not running from these locations, then it creates and copies itself using a 10-character string name on those locations, as well as /lib/ and /var/run/.",
                        "/usr/bin/jwvwvxoupv cat resolv.conf 4849<crlf>/usr/bin/jwvwvxoupv gnome-terminal 4849<crlf>/usr/bin/jwvwvxoupv top 4849<crlf>/usr/bin/jwvwvxoupv pwd 4849<crlf>/usr/bin/kagbjahdic id 4849",
                        "Fetches the file name specific to the $pid provided as part of the third argument by calling the readlink API on /proc/$pid/exe.If the readlink call fails, that likely indicates that the file on disk doesnt exist. In this case, it:Calls the stat API for the file /lib/libudev.so. If the stat API returns a non-zero value, then it attempts to copy the content of the current processs image-file fetched earlier to the following locations with a random name:If the readlink call is successful and returns the count of bytes copied, sleeps for one second and then loops for the remaining time out of five seconds.Unhides the current process and the $pid that was provided as part of the third argument.Deletes the on-disk file for the current process.Intends to delete all service-related entries for the $pid but fails. This appears to be due to a code flaw that allows a zeroed-out buffer to be passed as a service name when the buffer is supposed to be filled from a successful readlink API call.<crlf>Creates directories similar to the standard code path scenario.<crlf>/usr/bin/<crlf>/bin/<crlf>/tmp/<crlf>Copies the /lib/libudev.so file to the same three directories listed above if the stat API call is successful on /lib/libudev.so.<crlf>Changes the hash of the written or copied file and then runs it without passing any parameters."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x3dca1e53>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "d71ea3b98286d39a711b626f687f0d3fc852c3e3a05de3f51450fb8f7bd2b0d7"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xe7de3a04>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "175667933088fbebcb62c8450993422ccc876495299173c646779a9e67501ff4"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x3610f5de>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "2b4500987d50a24ba5c118f506f2507362d6b5c63c80b1984b4ae86641779ff3"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xc84f7c79>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "798577202477c0c233d4af51c4d8fb2f574ddb3c9d1d90325d359a84cb1bd51c"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xd1a508ed>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "360a6258dd66a3ba595a93896d9b55d22406d02e5c02100e5a18382c54e7d5cd"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xd685405a>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "e6c7eee304dfc29b19012ef6d31848c0b5bb07362691e4e9633c8581f1c2d65b"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x4ab535f0>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "9d6f115f31ee71089cc85b18852974e349c68fad3276145dafd0076951f32489"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xb15ba76>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "dc2b1cee161ebe90be68561755d99e66f454ad80b27cebe3d4773518ac45cbb7"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x8f66bff6>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "359c41da1cbae573d2c99f7da9eeb03df135f018f6c660b4e44fbd2b4ddecd39"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x235e860>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "53f062a93cf19aeaa2f8481b32118a31b658a126624abb8a7d82237884f0a394"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xc8b7ae0c>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "b5fba27a8e457c1ab6573c378171f057d151dc615d6a8d339195716fa9ac277a"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0xe00d8c4>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "ef0a4c12d98dc0ad4db86aadd641389c7219f57f15642ed35b4443daf3ff8c1e"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x42030cbf>",
                            "type": "UnknownWord",
                            "value": "usr"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa7239bd0>",
                    "type": "UnknownWord",
                    "value": "ipv4pii_777789ffaa5b68638cdaea8ecfa10b24b326ed7d"
                },
                "references": {
                    "sentences": [
                        "Iterates the following folders to find a writable directory:/bin /home /root /tmp /usr /etc<crlf>If a writable directory is found, changes the working directory to the discovered writable directory.<crlf>Uses the curl command to download the ELF file payload from the remote location hxxp://Ipv4PII_777789ffaa5b68638cdaea8ecfa10b24b326ed7d/1[.]txt and saves the file as ygljglkjgfg0.<crlf>Changes the file mode to executable.<crlf>Runs the ELF file payload.<crlf>Moves and renames the Wget binary to evade rule-based detections triggered by malicious usage of the Wget binary. In this case, it renames the Wget binary to good and moves the file to the following locations:mv /usr/bin/wget /usr/bin/good mv /bin/wget /bin/good<crlf>Attempts to download the ELF file payload for a second time, now only using the file good and not the Wget binary.<crlf>After running the ELF file, uses an anti-forensic technique that hides its past activity by overwriting the content of the following sensitive files with a newline character:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcb9d4841>",
                    "type": "UnknownWord",
                    "value": "ygljglkjgfg0"
                },
                "references": {
                    "sentences": [
                        "Iterates the following folders to find a writable directory:/bin /home /root /tmp /usr /etc<crlf>If a writable directory is found, changes the working directory to the discovered writable directory.<crlf>Uses the curl command to download the ELF file payload from the remote location hxxp://Ipv4PII_777789ffaa5b68638cdaea8ecfa10b24b326ed7d/1[.]txt and saves the file as ygljglkjgfg0.<crlf>Changes the file mode to executable.<crlf>Runs the ELF file payload.<crlf>Moves and renames the Wget binary to evade rule-based detections triggered by malicious usage of the Wget binary. In this case, it renames the Wget binary to good and moves the file to the following locations:mv /usr/bin/wget /usr/bin/good mv /bin/wget /bin/good<crlf>Attempts to download the ELF file payload for a second time, now only using the file good and not the Wget binary.<crlf>After running the ELF file, uses an anti-forensic technique that hides its past activity by overwriting the content of the following sensitive files with a newline character:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4bf9c596>",
                    "type": "UnknownWord",
                    "value": "newline"
                },
                "references": {
                    "sentences": [
                        "Iterates the following folders to find a writable directory:/bin /home /root /tmp /usr /etc<crlf>If a writable directory is found, changes the working directory to the discovered writable directory.<crlf>Uses the curl command to download the ELF file payload from the remote location hxxp://Ipv4PII_777789ffaa5b68638cdaea8ecfa10b24b326ed7d/1[.]txt and saves the file as ygljglkjgfg0.<crlf>Changes the file mode to executable.<crlf>Runs the ELF file payload.<crlf>Moves and renames the Wget binary to evade rule-based detections triggered by malicious usage of the Wget binary. In this case, it renames the Wget binary to good and moves the file to the following locations:mv /usr/bin/wget /usr/bin/good mv /bin/wget /bin/good<crlf>Attempts to download the ELF file payload for a second time, now only using the file good and not the Wget binary.<crlf>After running the ELF file, uses an anti-forensic technique that hides its past activity by overwriting the content of the following sensitive files with a newline character:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf1475ae0>",
                    "type": "UnknownWord",
                    "value": "bash_history"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc9740a34>",
                    "type": "UnknownWord",
                    "value": "var"
                },
                "references": {
                    "sentences": [
                        "Reads the content of the file /var/run/gcc.pid to get a unique 32-byte magic string that identifies the device while connecting with the C2 server; if the file doesnt exist, then it creates the file and updates it with a random 32-byte string.<crlf>Calculates the CRC header, including details of the device such as the magic string, OS release version, malware version, rootkit presence, memory stats, CPU information, and LAN speed.<crlf>Encrypts the data and sends it to the C2 server.<crlf>Waits to receive any of the following commands from the C2 server and then acts on the command using the exec_packet subroutine.",
                        "Decodes encrypted stringsFetches file stats for /var/run/gcc.pid or, if none exist, then creates the fileFetches file stats for /lib/libudev.so or, if none exist, then creates the directory /lib and creates a copy of itself at the location /lib/libudev.soFetches the on disk file information associated with the current process; if it fails, then exits the loop and stops the current processReads the content from kill_cfg and performs the corresponding actions, like stopping the process or deleting files, based on the matching specified keys in the configuration file, such as:md5=<crlf>filename=<crlf>rmfile=<crlf>denyip=",
                        "DeviceFileEvents<crlf>| extend FullPath=strcat(FolderPath, FileName)<crlf>| where FullPath in (\"/etc/cron.hourly/gcc.sh\", \"/lib/libudev.so.6\", \"/lib/libudev.so\", \"/var/run/gcc.pid\")",
                        "The malware first checks whether its running from the locations /usr/bin/, /bin/, or /tmp/. If its not running from these locations, then it creates and copies itself using a 10-character string name on those locations, as well as /lib/ and /var/run/."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc2b8a12a>",
                    "type": "UnknownWord",
                    "value": "wtmp"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdc89e727>",
                    "type": "UnknownWord",
                    "value": "btmp"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc6ad5565>",
                    "type": "UnknownWord",
                    "value": "lastlog"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x427bfb60>",
                    "type": "UnknownWord",
                    "value": "sudo"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8d5c83ff>",
                    "type": "UnknownWord",
                    "value": "logged"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa52dc0b1>",
                    "type": "UnknownWord",
                    "value": "dmesg"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf5cfc06a>",
                    "type": "UnknownWord",
                    "value": "ring"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x76a34ccf>",
                    "type": "UnknownWord",
                    "value": "firewalld"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa1b101cf>",
                    "type": "UnknownWord",
                    "value": "maillog"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x85ca5700>",
                    "type": "UnknownWord",
                    "value": "spooler"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x347f7382>",
                    "type": "UnknownWord",
                    "value": "usenet"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9aace932>",
                    "type": "UnknownWord",
                    "value": "syslog"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfd7b21ea>",
                    "type": "UnknownWord",
                    "value": "yum"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9dcea070>",
                    "type": "UnknownWord",
                    "value": "whichever"
                },
                "references": {
                    "sentences": [
                        "Whichever initial access method is used, the result is the same: the running of a malicious ELF file, which is the XorDdos malware. In the next section, we do a deep dive into the XorDdos payload."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbaf2832e>",
                    "type": "UnknownWord",
                    "value": "stripped"
                },
                "references": {
                    "sentences": [
                        "The XorDdos payload we analyzed for this research is a 32-bit ELF file that was not stripped, meaning it contained debug symbols that detailed the malwares dedicated code for each of its activities. The inclusion of debug symbols makes it easier to debug and reverse engineer non-stripped binaries, as compared to stripped binaries that discard these symbols. In this case, the non-stripped binary includes the following source-code file names associated with the symbol table entries as part of the .strtab section in the ELF file:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x94aa91d2>",
                    "type": "UnknownWord",
                    "value": "symbols"
                },
                "references": {
                    "sentences": [
                        "Based on the debug symbols found in the rootkit, its likely that XorDdos rootkit code was inspired by an open-source project called rooty. The following table describes the symbols found in the rootkit and their corresponding functionalities:",
                        "The XorDdos payload we analyzed for this research is a 32-bit ELF file that was not stripped, meaning it contained debug symbols that detailed the malwares dedicated code for each of its activities. The inclusion of debug symbols makes it easier to debug and reverse engineer non-stripped binaries, as compared to stripped binaries that discard these symbols. In this case, the non-stripped binary includes the following source-code file names associated with the symbol table entries as part of the .strtab section in the ELF file:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7380d446>",
                    "type": "UnknownWord",
                    "value": "inclusion"
                },
                "references": {
                    "sentences": [
                        "The XorDdos payload we analyzed for this research is a 32-bit ELF file that was not stripped, meaning it contained debug symbols that detailed the malwares dedicated code for each of its activities. The inclusion of debug symbols makes it easier to debug and reverse engineer non-stripped binaries, as compared to stripped binaries that discard these symbols. In this case, the non-stripped binary includes the following source-code file names associated with the symbol table entries as part of the .strtab section in the ELF file:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6b0de68e>",
                    "type": "UnknownWord",
                    "value": "non-stripped"
                },
                "references": {
                    "sentences": [
                        "The XorDdos payload we analyzed for this research is a 32-bit ELF file that was not stripped, meaning it contained debug symbols that detailed the malwares dedicated code for each of its activities. The inclusion of debug symbols makes it easier to debug and reverse engineer non-stripped binaries, as compared to stripped binaries that discard these symbols. In this case, the non-stripped binary includes the following source-code file names associated with the symbol table entries as part of the .strtab section in the ELF file:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x386c324f>",
                    "type": "UnknownWord",
                    "value": "source-code"
                },
                "references": {
                    "sentences": [
                        "The XorDdos payload we analyzed for this research is a 32-bit ELF file that was not stripped, meaning it contained debug symbols that detailed the malwares dedicated code for each of its activities. The inclusion of debug symbols makes it easier to debug and reverse engineer non-stripped binaries, as compared to stripped binaries that discard these symbols. In this case, the non-stripped binary includes the following source-code file names associated with the symbol table entries as part of the .strtab section in the ELF file:",
                        "The above list of source-code file names indicate that the binary is programmed in C/C++ and that its code is modular."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x452d5150>",
                    "type": "UnknownWord",
                    "value": "symbol"
                },
                "references": {
                    "sentences": [
                        "The XorDdos payload we analyzed for this research is a 32-bit ELF file that was not stripped, meaning it contained debug symbols that detailed the malwares dedicated code for each of its activities. The inclusion of debug symbols makes it easier to debug and reverse engineer non-stripped binaries, as compared to stripped binaries that discard these symbols. In this case, the non-stripped binary includes the following source-code file names associated with the symbol table entries as part of the .strtab section in the ELF file:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc1b65d34>",
                    "type": "UnknownWord",
                    "value": "strtab"
                },
                "references": {
                    "sentences": [
                        "The XorDdos payload we analyzed for this research is a 32-bit ELF file that was not stripped, meaning it contained debug symbols that detailed the malwares dedicated code for each of its activities. The inclusion of debug symbols makes it easier to debug and reverse engineer non-stripped binaries, as compared to stripped binaries that discard these symbols. In this case, the non-stripped binary includes the following source-code file names associated with the symbol table entries as part of the .strtab section in the ELF file:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdbb53d36>",
                    "type": "UnknownWord",
                    "value": "crtstuff"
                },
                "references": {
                    "sentences": [
                        "crtstuff.c<crlf>autorun.c<crlf>crc32.c<crlf>encrypt.c<crlf>execpacket.c<crlf>buildnet.c<crlf>hide.c<crlf>http.c<crlf>kill.c<crlf>main.c<crlf>proc.c<crlf>socket.c<crlf>tcp.c<crlf>thread.c<crlf>findip.c<crlf>dns.c"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x22631241>",
                    "type": "UnknownWord",
                    "value": "execpacket"
                },
                "references": {
                    "sentences": [
                        "crtstuff.c<crlf>autorun.c<crlf>crc32.c<crlf>encrypt.c<crlf>execpacket.c<crlf>buildnet.c<crlf>hide.c<crlf>http.c<crlf>kill.c<crlf>main.c<crlf>proc.c<crlf>socket.c<crlf>tcp.c<crlf>thread.c<crlf>findip.c<crlf>dns.c"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5761a39f>",
                    "type": "UnknownWord",
                    "value": "buildnet"
                },
                "references": {
                    "sentences": [
                        "crtstuff.c<crlf>autorun.c<crlf>crc32.c<crlf>encrypt.c<crlf>execpacket.c<crlf>buildnet.c<crlf>hide.c<crlf>http.c<crlf>kill.c<crlf>main.c<crlf>proc.c<crlf>socket.c<crlf>tcp.c<crlf>thread.c<crlf>findip.c<crlf>dns.c"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4bb64151>",
                    "type": "UnknownWord",
                    "value": "proc"
                },
                "references": {
                    "sentences": [
                        "crtstuff.c<crlf>autorun.c<crlf>crc32.c<crlf>encrypt.c<crlf>execpacket.c<crlf>buildnet.c<crlf>hide.c<crlf>http.c<crlf>kill.c<crlf>main.c<crlf>proc.c<crlf>socket.c<crlf>tcp.c<crlf>thread.c<crlf>findip.c<crlf>dns.c",
                        "The /proc filesystem contains information related to all running processes. A user-mode process can get any process specific information by reading the /proc directory that contains the subdirectory for each running process on the system, such as:",
                        "> strace -e open ps<crlf>open(/proc/3922/status, O_RDONLY) = 6<crlf>open(/proc/4324/stat, O_RDONLY) = 6<crlf>open(/proc/4324/status, O_RDONLY) = 6<crlf>open(/proc/5559/stat, O_RDONLY) = 6<crlf>open(/proc/5559/status, O_RDONLY) = 6<crlf>open(/proc/5960/stat, O_RDONLY) = 6<crlf>open(/proc/5960/status, O_RDONLY) = 6<crlf>open(/proc/5978/stat, O_RDONLY) = 6<crlf>open(/proc/5978/status, O_RDONLY) = 6",
                        "In this case, the malware has a provision for communicating with its rootkit component /proc/rs_dev by sending input and output control (IOCTL) calls with additional information to take appropriate action. IOCTL is one way to communicate between the user-mode service and kernel device driver. The malware uses the number 0x9748712 to uniquely identify its IOCTL calls from other IOCTL calls in the system.",
                        "Fetches the file name specific to the $pid provided as part of the third argument by calling the readlink API on /proc/$pid/exe.If the readlink call fails, that likely indicates that the file on disk doesnt exist. In this case, it:Calls the stat API for the file /lib/libudev.so. If the stat API returns a non-zero value, then it attempts to copy the content of the current processs image-file fetched earlier to the following locations with a random name:If the readlink call is successful and returns the count of bytes copied, sleeps for one second and then loops for the remaining time out of five seconds.Unhides the current process and the $pid that was provided as part of the third argument.Deletes the on-disk file for the current process.Intends to delete all service-related entries for the $pid but fails. This appears to be due to a code flaw that allows a zeroed-out buffer to be passed as a service name when the buffer is supposed to be filled from a successful readlink API call.<crlf>Creates directories similar to the standard code path scenario.<crlf>/usr/bin/<crlf>/bin/<crlf>/tmp/<crlf>Copies the /lib/libudev.so file to the same three directories listed above if the stat API call is successful on /lib/libudev.so.<crlf>Changes the hash of the written or copied file and then runs it without passing any parameters.",
                        "Before handling the argument-based control, it calls the readlink API with the first parameter as /proc/self/exe to fetch its full process path. The full path is used later to create auto-start service entries and read the files content.",
                        "Running the strace -e open ps command checks the traces of the open call on /proc/$pid to fetch information on running processes as part of the ps command.",
                        "/proc/7728 Contains process-id (PID) 7728-related information<crlf>/proc/698 Contains PID 698-related information"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe5699cbe>",
                    "type": "UnknownWord",
                    "value": "findip"
                },
                "references": {
                    "sentences": [
                        "crtstuff.c<crlf>autorun.c<crlf>crc32.c<crlf>encrypt.c<crlf>execpacket.c<crlf>buildnet.c<crlf>hide.c<crlf>http.c<crlf>kill.c<crlf>main.c<crlf>proc.c<crlf>socket.c<crlf>tcp.c<crlf>thread.c<crlf>findip.c<crlf>dns.c"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xeeaea89>",
                    "type": "UnknownWord",
                    "value": "detaches"
                },
                "references": {
                    "sentences": [
                        "A daemon process is a process that runs in the background rather than under the control of users and detaches itself from the controlling terminal, terminating only when the system is shut down. Similar to some Linux malware families, the XorDdos trojan uses daemon processes, as detailed below, to break process tree-based analysis:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x642c5d03>",
                    "type": "UnknownWord",
                    "value": "subroutine"
                },
                "references": {
                    "sentences": [
                        "Reads the content of the file /var/run/gcc.pid to get a unique 32-byte magic string that identifies the device while connecting with the C2 server; if the file doesnt exist, then it creates the file and updates it with a random 32-byte string.<crlf>Calculates the CRC header, including details of the device such as the magic string, OS release version, malware version, rootkit presence, memory stats, CPU information, and LAN speed.<crlf>Encrypts the data and sends it to the C2 server.<crlf>Waits to receive any of the following commands from the C2 server and then acts on the command using the exec_packet subroutine.",
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum.",
                        "The malware runs a command to install startup services that automatically run XorDdos at boot. The malwares LinuxExec_Argv2 subroutine runs the system API with the provided arguments."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe4d29e9e>",
                    "type": "UnknownWord",
                    "value": "__nochdir"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9025e70b>",
                    "type": "UnknownWord",
                    "value": "__noclose"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x77e6cd09>",
                    "type": "UnknownWord",
                    "value": "fork"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum.",
                        "Using the above example, the malware shares the 64-byte size memory segment with the IPC key 0xDA718716 to check for another malware process provided as an argument. If not found, it runs its own binary without any argument and calls the fork() API twice to make sure the grandchild process has no parent. This results in the grandchild process being adopted by the init process, which disconnects it from the process tree and acts as an anti-forensic technique.",
                        "After modifying the file, it runs the binary, performs a double fork(), and deletes its file from the disk."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2b0bdc73>",
                    "type": "UnknownWord",
                    "value": "setsid"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x550dea88>",
                    "type": "UnknownWord",
                    "value": "group-id"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5bdd30f>",
                    "type": "UnknownWord",
                    "value": "returning"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x780c1e8>",
                    "type": "UnknownWord",
                    "value": "exit_success"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x845bc7d6>",
                    "type": "UnknownWord",
                    "value": "prerequisite"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf0156bd5>",
                    "type": "UnknownWord",
                    "value": "detach"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc46f50d5>",
                    "type": "UnknownWord",
                    "value": "provision"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum.",
                        "In this case, the malware has a provision for communicating with its rootkit component /proc/rs_dev by sending input and output control (IOCTL) calls with additional information to take appropriate action. IOCTL is one way to communicate between the user-mode service and kernel device driver. The malware uses the number 0x9748712 to uniquely identify its IOCTL calls from other IOCTL calls in the system."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x77da1dcb>",
                    "type": "UnknownWord",
                    "value": "equal"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3162801f>",
                    "type": "UnknownWord",
                    "value": "unmounting"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe94e3e8f>",
                    "type": "UnknownWord",
                    "value": "dup2"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x545642c3>",
                    "type": "UnknownWord",
                    "value": "descriptor"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4c3fddbd>",
                    "type": "UnknownWord",
                    "value": "hangup"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc9a1c449>",
                    "type": "UnknownWord",
                    "value": "sighup"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5e82afee>",
                    "type": "UnknownWord",
                    "value": "disconnected"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7d1a27aa>",
                    "type": "UnknownWord",
                    "value": "suppression"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfb031d11>",
                    "type": "UnknownWord",
                    "value": "disposition"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4daad741>",
                    "type": "UnknownWord",
                    "value": "signum"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd6e4e2d5>",
                    "type": "UnknownWord",
                    "value": "handler"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2e949b00>",
                    "type": "UnknownWord",
                    "value": "sig_ign"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2ef8dc3a>",
                    "type": "UnknownWord",
                    "value": "sig_dfl"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xef8769f9>",
                    "type": "UnknownWord",
                    "value": "programmer-defined"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdbe88277>",
                    "type": "UnknownWord",
                    "value": "terminal-related"
                },
                "references": {
                    "sentences": [
                        "Figure 4. Ignore signals associated with the terminal-related operations"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6829c979>",
                    "type": "UnknownWord",
                    "value": "dec_conf"
                },
                "references": {
                    "sentences": [
                        "As its name suggests, XorDdos uses XOR-based encryption to obfuscate data. It calls the dec_conf function to decode encoded strings using the XOR key BB2FA36AAA9541F0. The table below shows the decoded values of the obfuscated data used across the malwares various modules to conduct its activities."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x102bb0e3>",
                    "type": "UnknownWord",
                    "value": "bb2fa36aaa9541f0"
                },
                "references": {
                    "sentences": [
                        "As its name suggests, XorDdos uses XOR-based encryption to obfuscate data. It calls the dec_conf function to decode encoded strings using the XOR key BB2FA36AAA9541F0. The table below shows the decoded values of the obfuscated data used across the malwares various modules to conduct its activities.",
                        "AddService Creates the persistent auto-start entries previously mentioned so that the malware runs when the system starts.<crlf>HidePidPort Hides the malwares ports and processes.<crlf>CheckLKM Checks whether the rootkit device is active or not. It uses a similar IOCTL call with the number 0x9748712 and command 0 to find if the rootkit is active. If the rootkit is active, it uses the owner value 0xAD1473B8 and group value 0xAD1473B8 to change the ownership of dropped files with the function lchown(<filename>, 0xAD1473B8, 0xAD1473B8).<crlf>decrypt_remotestr Decodes remote URLs using the same XOR key, BB2FA36AAA9541F0, to decode config.rar and the other directories. After decoding the URLs, it adds them into a remote list, which is later used to communicate and fetch commands from the command and control (C2) server:www[.]enoan2107[.]com:3306www[.]gzcfr5axf6[.]com:3306"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x102bb0e3>",
                            "type": "UnknownWord",
                            "value": "bb2fa36aaa9541f0"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfc1cd2ff>",
                    "type": "UnknownWord",
                    "value": "m7a4nq_"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7ba9c70d>",
                    "type": "UnknownWord",
                    "value": "bin"
                },
                "references": {
                    "sentences": [
                        "Fetches the file name specific to the $pid provided as part of the third argument by calling the readlink API on /proc/$pid/exe.If the readlink call fails, that likely indicates that the file on disk doesnt exist. In this case, it:Calls the stat API for the file /lib/libudev.so. If the stat API returns a non-zero value, then it attempts to copy the content of the current processs image-file fetched earlier to the following locations with a random name:If the readlink call is successful and returns the count of bytes copied, sleeps for one second and then loops for the remaining time out of five seconds.Unhides the current process and the $pid that was provided as part of the third argument.Deletes the on-disk file for the current process.Intends to delete all service-related entries for the $pid but fails. This appears to be due to a code flaw that allows a zeroed-out buffer to be passed as a service name when the buffer is supposed to be filled from a successful readlink API call.<crlf>Creates directories similar to the standard code path scenario.<crlf>/usr/bin/<crlf>/bin/<crlf>/tmp/<crlf>Copies the /lib/libudev.so file to the same three directories listed above if the stat API call is successful on /lib/libudev.so.<crlf>Changes the hash of the written or copied file and then runs it without passing any parameters.",
                        "/usr/bin/<crlf>/bin/<crlf>/tmp/"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4f9bde1b>",
                    "type": "UnknownWord",
                    "value": "m6_6n3"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd023527c>",
                    "type": "UnknownWord",
                    "value": "m4s4nac"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x10eb46f>",
                    "type": "UnknownWord",
                    "value": "x1aa"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xaca99cc6>",
                    "type": "UnknownWord",
                    "value": "gcc"
                },
                "references": {
                    "sentences": [
                        "The malware creates a cron script at the location /etc/cron.hourly/gcc.sh.The cron script passes parameters with the following content:",
                        "Figure 9. System command to delete the /etc/cron.hourly/gcc.sh entry from the /etc/crontab file and add a new entry",
                        "It then creates a /etc/crontab file to run /etc/cron.hourly/gcc.sh every three minutes:",
                        "Decodes encrypted stringsFetches file stats for /var/run/gcc.pid or, if none exist, then creates the fileFetches file stats for /lib/libudev.so or, if none exist, then creates the directory /lib and creates a copy of itself at the location /lib/libudev.soFetches the on disk file information associated with the current process; if it fails, then exits the loop and stops the current processReads the content from kill_cfg and performs the corresponding actions, like stopping the process or deleting files, based on the matching specified keys in the configuration file, such as:md5=<crlf>filename=<crlf>rmfile=<crlf>denyip=",
                        "Reads the content of the file /var/run/gcc.pid to get a unique 32-byte magic string that identifies the device while connecting with the C2 server; if the file doesnt exist, then it creates the file and updates it with a random 32-byte string.<crlf>Calculates the CRC header, including details of the device such as the magic string, OS release version, malware version, rootkit presence, memory stats, CPU information, and LAN speed.<crlf>Encrypts the data and sends it to the C2 server.<crlf>Waits to receive any of the following commands from the C2 server and then acts on the command using the exec_packet subroutine.",
                        "DeviceFileEvents<crlf>| extend FullPath=strcat(FolderPath, FileName)<crlf>| where FullPath in (\"/etc/cron.hourly/gcc.sh\", \"/lib/libudev.so.6\", \"/lib/libudev.so\", \"/var/run/gcc.pid\")"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x133026e0>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "cbb72e542e8f19240130fc9381c2351730d437d42926c6e68e056907c8456459"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xaca99cc6>",
                            "type": "UnknownWord",
                            "value": "gcc"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x38bac132>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "932feef3ab6fccb3502f900619b1f87e1cb44a7adab48f2c927ecdd67ff6830a"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xaca99cc6>",
                            "type": "UnknownWord",
                            "value": "gcc"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe539604a>",
                    "type": "UnknownWord",
                    "value": "pid"
                },
                "references": {
                    "sentences": [
                        "Along with this number, it also passes an integer array. The first entry in the array corresponds to the command, and the second entry stores the value to act on, such as $pid.",
                        "Fetches the file name specific to the $pid provided as part of the third argument by calling the readlink API on /proc/$pid/exe.If the readlink call fails, that likely indicates that the file on disk doesnt exist. In this case, it:Calls the stat API for the file /lib/libudev.so. If the stat API returns a non-zero value, then it attempts to copy the content of the current processs image-file fetched earlier to the following locations with a random name:If the readlink call is successful and returns the count of bytes copied, sleeps for one second and then loops for the remaining time out of five seconds.Unhides the current process and the $pid that was provided as part of the third argument.Deletes the on-disk file for the current process.Intends to delete all service-related entries for the $pid but fails. This appears to be due to a code flaw that allows a zeroed-out buffer to be passed as a service name when the buffer is supposed to be filled from a successful readlink API call.<crlf>Creates directories similar to the standard code path scenario.<crlf>/usr/bin/<crlf>/bin/<crlf>/tmp/<crlf>Copies the /lib/libudev.so file to the same three directories listed above if the stat API call is successful on /lib/libudev.so.<crlf>Changes the hash of the written or copied file and then runs it without passing any parameters.",
                        "Decodes encrypted stringsFetches file stats for /var/run/gcc.pid or, if none exist, then creates the fileFetches file stats for /lib/libudev.so or, if none exist, then creates the directory /lib and creates a copy of itself at the location /lib/libudev.soFetches the on disk file information associated with the current process; if it fails, then exits the loop and stops the current processReads the content from kill_cfg and performs the corresponding actions, like stopping the process or deleting files, based on the matching specified keys in the configuration file, such as:md5=<crlf>filename=<crlf>rmfile=<crlf>denyip=",
                        "Additionally, it performs the following tasks on a provided $pid:",
                        "If the malware hides the $pid specific directory, it can conceal fetching the corresponding process from a user mode.",
                        "Reads the content of the file /var/run/gcc.pid to get a unique 32-byte magic string that identifies the device while connecting with the C2 server; if the file doesnt exist, then it creates the file and updates it with a random 32-byte string.<crlf>Calculates the CRC header, including details of the device such as the magic string, OS release version, malware version, rootkit presence, memory stats, CPU information, and LAN speed.<crlf>Encrypts the data and sends it to the C2 server.<crlf>Waits to receive any of the following commands from the C2 server and then acts on the command using the exec_packet subroutine.",
                        "Running the strace -e open ps command checks the traces of the open call on /proc/$pid to fetch information on running processes as part of the ps command.",
                        "In this code path, the malware runs with another argument provided as the PID, for example:",
                        "DeviceFileEvents<crlf>| extend FullPath=strcat(FolderPath, FileName)<crlf>| where FullPath in (\"/etc/cron.hourly/gcc.sh\", \"/lib/libudev.so.6\", \"/lib/libudev.so\", \"/var/run/gcc.pid\")",
                        "/proc/7728 Contains process-id (PID) 7728-related information<crlf>/proc/698 Contains PID 698-related information"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe539604a>",
                            "type": "UnknownWord",
                            "value": "pid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7373bc55>",
                            "type": "File",
                            "value": "seconds.unhides"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe539604a>",
                            "type": "UnknownWord",
                            "value": "pid"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xbb3f44ca>",
                            "type": "File",
                            "value": "process.intends"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe539604a>",
                            "type": "UnknownWord",
                            "value": "pid"
                        }
                    },
                    {
                        "src": {
                            "id": "<SHA256_0x38bac132>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "932feef3ab6fccb3502f900619b1f87e1cb44a7adab48f2c927ecdd67ff6830a"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe539604a>",
                            "type": "UnknownWord",
                            "value": "pid"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd1ae8d04>",
                    "type": "UnknownWord",
                    "value": "n__"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xde18d38b>",
                    "type": "UnknownWord",
                    "value": "x1ab"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc16db613>",
                    "type": "UnknownWord",
                    "value": "lib libudev"
                },
                "references": {
                    "sentences": [
                        "It also creates a copy of itself at the location /lib/libudev.so. To evade hash-based malicious file lookup, it performs the following steps, which modify the file hash to make every file unique:",
                        "Fetches the file name specific to the $pid provided as part of the third argument by calling the readlink API on /proc/$pid/exe.If the readlink call fails, that likely indicates that the file on disk doesnt exist. In this case, it:Calls the stat API for the file /lib/libudev.so. If the stat API returns a non-zero value, then it attempts to copy the content of the current processs image-file fetched earlier to the following locations with a random name:If the readlink call is successful and returns the count of bytes copied, sleeps for one second and then loops for the remaining time out of five seconds.Unhides the current process and the $pid that was provided as part of the third argument.Deletes the on-disk file for the current process.Intends to delete all service-related entries for the $pid but fails. This appears to be due to a code flaw that allows a zeroed-out buffer to be passed as a service name when the buffer is supposed to be filled from a successful readlink API call.<crlf>Creates directories similar to the standard code path scenario.<crlf>/usr/bin/<crlf>/bin/<crlf>/tmp/<crlf>Copies the /lib/libudev.so file to the same three directories listed above if the stat API call is successful on /lib/libudev.so.<crlf>Changes the hash of the written or copied file and then runs it without passing any parameters.",
                        "Decodes encrypted stringsFetches file stats for /var/run/gcc.pid or, if none exist, then creates the fileFetches file stats for /lib/libudev.so or, if none exist, then creates the directory /lib and creates a copy of itself at the location /lib/libudev.soFetches the on disk file information associated with the current process; if it fails, then exits the loop and stops the current processReads the content from kill_cfg and performs the corresponding actions, like stopping the process or deleting files, based on the matching specified keys in the configuration file, such as:md5=<crlf>filename=<crlf>rmfile=<crlf>denyip=",
                        "DeviceFileEvents<crlf>| extend FullPath=strcat(FolderPath, FileName)<crlf>| where FullPath in (\"/etc/cron.hourly/gcc.sh\", \"/lib/libudev.so.6\", \"/lib/libudev.so\", \"/var/run/gcc.pid\")"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<HASHSET_0xb853bf31>",
                            "type": "HashSet",
                            "value": [
                                {
                                    "id": "<MD5_0xbd34a140>",
                                    "type": "Hash",
                                    "hash_type": "MD5",
                                    "value": "2dc6225a9d104a950fb33a74da262b93"
                                },
                                {
                                    "id": "<SHA256_0xdfc31533>",
                                    "type": "Hash",
                                    "hash_type": "SHA256",
                                    "value": "f2df54eb827f3c733d481ebb167a5bc77c5ae39a6bda7f340bb23b24dc9a4432"
                                },
                                {
                                    "id": "<SHA1_0x69d4f3f4>",
                                    "type": "Hash",
                                    "hash_type": "SHA1",
                                    "value": "f05194fb2b3978611b99cfbf5e5f1dd44cd5e04b"
                                }
                            ]
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc16db613>",
                            "type": "UnknownWord",
                            "value": "lib libudev"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xffeecf29>",
                    "type": "UnknownWord",
                    "value": "lib"
                },
                "references": {
                    "sentences": [
                        "The malware first checks whether its running from the locations /usr/bin/, /bin/, or /tmp/. If its not running from these locations, then it creates and copies itself using a 10-character string name on those locations, as well as /lib/ and /var/run/."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa6ac9dd4>",
                    "type": "UnknownWord",
                    "value": "x17v"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa6ac9dd4>",
                            "type": "UnknownWord",
                            "value": "x17v"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd682ee5f>",
                    "type": "UnknownWord",
                    "value": "ff3ve"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd682ee5f>",
                            "type": "UnknownWord",
                            "value": "ff3ve"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcfffbed9>",
                    "type": "UnknownWord",
                    "value": "-7"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xcfffbed9>",
                            "type": "UnknownWord",
                            "value": "-7"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9454329b>",
                    "type": "UnknownWord",
                    "value": "_"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9454329b>",
                            "type": "UnknownWord",
                            "value": "_"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x43215109>",
                    "type": "UnknownWord",
                    "value": "cat"
                },
                "references": {
                    "sentences": [
                        "cat resolv.conf<crlf>netstat -an<crlf>bash<crlf>whoami<crlf>id<crlf>cd /etc<crlf>ifconfig eth0<crlf>ifconfig<crlf>echo find<crlf>uptime<crlf>sh<crlf>top<crlf>gnome-terminal<crlf>su<crlf>netstat -antop<crlf>grep A<crlf>who<crlf>ls -la<crlf>pwd<crlf>route -n<crlf>ps -ef<crlf>ls<crlf>sleep 1",
                        "Figure 6. Output of the ps -aef contains an entry for cat resolv.conf",
                        "/usr/bin/jwvwvxoupv cat resolv.conf 4849<crlf>/usr/bin/jwvwvxoupv gnome-terminal 4849<crlf>/usr/bin/jwvwvxoupv top 4849<crlf>/usr/bin/jwvwvxoupv pwd 4849<crlf>/usr/bin/kagbjahdic id 4849",
                        "DeviceProcessEvents<crlf>| where ProcessCommandLine contains \"cat resolv.conf\"",
                        "When a process is launched, arguments are provided to its main function as null-terminated strings, where the first argument is always the process image path. To spoof its process name, XorDdos zeroes out all argument buffers while running and overrides its first argument buffer containing the image path with a fake command line, such as cat resolv.conf."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x43215109>",
                            "type": "UnknownWord",
                            "value": "cat"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xee30f9bd>",
                    "type": "UnknownWord",
                    "value": "<encrypted_remote_url>"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<URL_0x78e18023>",
                            "type": "Url",
                            "value": "http://aa.hostasa.org/config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xee30f9bd>",
                            "type": "UnknownWord",
                            "value": "<encrypted_remote_url>"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xddcb1ba6>",
                    "type": "UnknownWord",
                    "value": "null-terminated"
                },
                "references": {
                    "sentences": [
                        "When a process is launched, arguments are provided to its main function as null-terminated strings, where the first argument is always the process image path. To spoof its process name, XorDdos zeroes out all argument buffers while running and overrides its first argument buffer containing the image path with a fake command line, such as cat resolv.conf."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x38e3d7d7>",
                    "type": "UnknownWord",
                    "value": "zeroes"
                },
                "references": {
                    "sentences": [
                        "When a process is launched, arguments are provided to its main function as null-terminated strings, where the first argument is always the process image path. To spoof its process name, XorDdos zeroes out all argument buffers while running and overrides its first argument buffer containing the image path with a fake command line, such as cat resolv.conf."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x38e3d7d7>",
                            "type": "UnknownWord",
                            "value": "zeroes"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x405af380>",
                    "type": "UnknownWord",
                    "value": "overrides"
                },
                "references": {
                    "sentences": [
                        "When a process is launched, arguments are provided to its main function as null-terminated strings, where the first argument is always the process image path. To spoof its process name, XorDdos zeroes out all argument buffers while running and overrides its first argument buffer containing the image path with a fake command line, such as cat resolv.conf."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x405af380>",
                            "type": "UnknownWord",
                            "value": "overrides"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2d11d5d5>",
                    "type": "UnknownWord",
                    "value": "-aef"
                },
                "references": {
                    "sentences": [
                        "Figure 6. Output of the ps -aef contains an entry for cat resolv.conf"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x2d11d5d5>",
                            "type": "UnknownWord",
                            "value": "-aef"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8fbb818e>",
                    "type": "UnknownWord",
                    "value": "inspired"
                },
                "references": {
                    "sentences": [
                        "Based on the debug symbols found in the rootkit, its likely that XorDdos rootkit code was inspired by an open-source project called rooty. The following table describes the symbols found in the rootkit and their corresponding functionalities:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8ab84d84>",
                    "type": "UnknownWord",
                    "value": "rooty"
                },
                "references": {
                    "sentences": [
                        "Based on the debug symbols found in the rootkit, its likely that XorDdos rootkit code was inspired by an open-source project called rooty. The following table describes the symbols found in the rootkit and their corresponding functionalities:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x24429ce9>",
                    "type": "UnknownWord",
                    "value": "give_root"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xefdbf00b>",
                    "type": "UnknownWord",
                    "value": "assigning"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x829d75b7>",
                    "type": "UnknownWord",
                    "value": "uid"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x418f4f58>",
                    "type": "UnknownWord",
                    "value": "gid"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa9430f14>",
                    "type": "UnknownWord",
                    "value": "module_hide"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x14a45a49>",
                    "type": "UnknownWord",
                    "value": "module_show"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5a585af4>",
                    "type": "UnknownWord",
                    "value": "unhides"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6aa14e3d>",
                    "type": "UnknownWord",
                    "value": "get_udp_seq_show"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2d892b93>",
                    "type": "UnknownWord",
                    "value": "udp4"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x13043227>",
                    "type": "UnknownWord",
                    "value": "hooking"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x97d060e2>",
                    "type": "UnknownWord",
                    "value": "udphides"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd6e3befa>",
                    "type": "UnknownWord",
                    "value": "udp6"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x931a831>",
                    "type": "UnknownWord",
                    "value": "get_tcp_seq_show"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xfd932133>",
                    "type": "UnknownWord",
                    "value": "tcp4"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe93f8605>",
                    "type": "UnknownWord",
                    "value": "tcphides"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8cc53651>",
                    "type": "UnknownWord",
                    "value": "tcp6"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdb74492>",
                    "type": "UnknownWord",
                    "value": "hide_udp4_port"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x95a8e7c8>",
                    "type": "UnknownWord",
                    "value": "unhide_udp4_port"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x12214f26>",
                    "type": "UnknownWord",
                    "value": "hide_udp6_port"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb1d3d59e>",
                    "type": "UnknownWord",
                    "value": "unhide_udp6_port"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3f4f29f9>",
                    "type": "UnknownWord",
                    "value": "hide_tcp4_port"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x57ef186c>",
                    "type": "UnknownWord",
                    "value": "unhide_tcp4_port"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5618de5>",
                    "type": "UnknownWord",
                    "value": "hide_tcp6_port"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc7690ce0>",
                    "type": "UnknownWord",
                    "value": "unhide_tcp6_port"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2ecd8338>",
                    "type": "UnknownWord",
                    "value": "unhide_allz"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6b8b304e>",
                    "type": "UnknownWord",
                    "value": "subdirectory"
                },
                "references": {
                    "sentences": [
                        "The /proc filesystem contains information related to all running processes. A user-mode process can get any process specific information by reading the /proc directory that contains the subdirectory for each running process on the system, such as:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3627147e>",
                    "type": "UnknownWord",
                    "value": "process-id"
                },
                "references": {
                    "sentences": [
                        "/proc/7728 Contains process-id (PID) 7728-related information<crlf>/proc/698 Contains PID 698-related information"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xff29a009>",
                    "type": "UnknownWord",
                    "value": "7728-related"
                },
                "references": {
                    "sentences": [
                        "/proc/7728 Contains process-id (PID) 7728-related information<crlf>/proc/698 Contains PID 698-related information"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x71da94ea>",
                    "type": "UnknownWord",
                    "value": "698-related"
                },
                "references": {
                    "sentences": [
                        "/proc/7728 Contains process-id (PID) 7728-related information<crlf>/proc/698 Contains PID 698-related information"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9b4d9165>",
                    "type": "UnknownWord",
                    "value": "strace"
                },
                "references": {
                    "sentences": [
                        "> strace -e open ps<crlf>open(/proc/3922/status, O_RDONLY) = 6<crlf>open(/proc/4324/stat, O_RDONLY) = 6<crlf>open(/proc/4324/status, O_RDONLY) = 6<crlf>open(/proc/5559/stat, O_RDONLY) = 6<crlf>open(/proc/5559/status, O_RDONLY) = 6<crlf>open(/proc/5960/stat, O_RDONLY) = 6<crlf>open(/proc/5960/status, O_RDONLY) = 6<crlf>open(/proc/5978/stat, O_RDONLY) = 6<crlf>open(/proc/5978/status, O_RDONLY) = 6",
                        "Running the strace -e open ps command checks the traces of the open call on /proc/$pid to fetch information on running processes as part of the ps command."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xacc7c351>",
                    "type": "UnknownWord",
                    "value": "-e"
                },
                "references": {
                    "sentences": [
                        "> strace -e open ps<crlf>open(/proc/3922/status, O_RDONLY) = 6<crlf>open(/proc/4324/stat, O_RDONLY) = 6<crlf>open(/proc/4324/status, O_RDONLY) = 6<crlf>open(/proc/5559/stat, O_RDONLY) = 6<crlf>open(/proc/5559/status, O_RDONLY) = 6<crlf>open(/proc/5960/stat, O_RDONLY) = 6<crlf>open(/proc/5960/status, O_RDONLY) = 6<crlf>open(/proc/5978/stat, O_RDONLY) = 6<crlf>open(/proc/5978/status, O_RDONLY) = 6",
                        "Running the strace -e open ps command checks the traces of the open call on /proc/$pid to fetch information on running processes as part of the ps command."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd3ba6bd9>",
                    "type": "UnknownWord",
                    "value": "o_rdonly"
                },
                "references": {
                    "sentences": [
                        "> strace -e open ps<crlf>open(/proc/3922/status, O_RDONLY) = 6<crlf>open(/proc/4324/stat, O_RDONLY) = 6<crlf>open(/proc/4324/status, O_RDONLY) = 6<crlf>open(/proc/5559/stat, O_RDONLY) = 6<crlf>open(/proc/5559/status, O_RDONLY) = 6<crlf>open(/proc/5960/stat, O_RDONLY) = 6<crlf>open(/proc/5960/status, O_RDONLY) = 6<crlf>open(/proc/5978/stat, O_RDONLY) = 6<crlf>open(/proc/5978/status, O_RDONLY) = 6"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbace30a4>",
                    "type": "UnknownWord",
                    "value": "stat"
                },
                "references": {
                    "sentences": [
                        "> strace -e open ps<crlf>open(/proc/3922/status, O_RDONLY) = 6<crlf>open(/proc/4324/stat, O_RDONLY) = 6<crlf>open(/proc/4324/status, O_RDONLY) = 6<crlf>open(/proc/5559/stat, O_RDONLY) = 6<crlf>open(/proc/5559/status, O_RDONLY) = 6<crlf>open(/proc/5960/stat, O_RDONLY) = 6<crlf>open(/proc/5960/status, O_RDONLY) = 6<crlf>open(/proc/5978/stat, O_RDONLY) = 6<crlf>open(/proc/5978/status, O_RDONLY) = 6",
                        "Fetches the file name specific to the $pid provided as part of the third argument by calling the readlink API on /proc/$pid/exe.If the readlink call fails, that likely indicates that the file on disk doesnt exist. In this case, it:Calls the stat API for the file /lib/libudev.so. If the stat API returns a non-zero value, then it attempts to copy the content of the current processs image-file fetched earlier to the following locations with a random name:If the readlink call is successful and returns the count of bytes copied, sleeps for one second and then loops for the remaining time out of five seconds.Unhides the current process and the $pid that was provided as part of the third argument.Deletes the on-disk file for the current process.Intends to delete all service-related entries for the $pid but fails. This appears to be due to a code flaw that allows a zeroed-out buffer to be passed as a service name when the buffer is supposed to be filled from a successful readlink API call.<crlf>Creates directories similar to the standard code path scenario.<crlf>/usr/bin/<crlf>/bin/<crlf>/tmp/<crlf>Copies the /lib/libudev.so file to the same three directories listed above if the stat API call is successful on /lib/libudev.so.<crlf>Changes the hash of the written or copied file and then runs it without passing any parameters."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbace30a4>",
                            "type": "UnknownWord",
                            "value": "stat"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7373bc55>",
                            "type": "File",
                            "value": "seconds.unhides"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbace30a4>",
                            "type": "UnknownWord",
                            "value": "stat"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xbb3f44ca>",
                            "type": "File",
                            "value": "process.intends"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbace30a4>",
                            "type": "UnknownWord",
                            "value": "stat"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf36ba403>",
                    "type": "UnknownWord",
                    "value": "conceal"
                },
                "references": {
                    "sentences": [
                        "If the malware hides the $pid specific directory, it can conceal fetching the corresponding process from a user mode."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb12a8729>",
                    "type": "UnknownWord",
                    "value": "fetching"
                },
                "references": {
                    "sentences": [
                        "If the malware hides the $pid specific directory, it can conceal fetching the corresponding process from a user mode."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x327698f>",
                    "type": "UnknownWord",
                    "value": "rs_dev"
                },
                "references": {
                    "sentences": [
                        "In this case, the malware has a provision for communicating with its rootkit component /proc/rs_dev by sending input and output control (IOCTL) calls with additional information to take appropriate action. IOCTL is one way to communicate between the user-mode service and kernel device driver. The malware uses the number 0x9748712 to uniquely identify its IOCTL calls from other IOCTL calls in the system."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2c39d05e>",
                    "type": "UnknownWord",
                    "value": "uniquely"
                },
                "references": {
                    "sentences": [
                        "In this case, the malware has a provision for communicating with its rootkit component /proc/rs_dev by sending input and output control (IOCTL) calls with additional information to take appropriate action. IOCTL is one way to communicate between the user-mode service and kernel device driver. The malware uses the number 0x9748712 to uniquely identify its IOCTL calls from other IOCTL calls in the system."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5f9f889b>",
                    "type": "UnknownWord",
                    "value": "unhide"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x92d834e3>",
                    "type": "UnknownWord",
                    "value": "<pid>"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x57d79d51>",
                    "type": "UnknownWord",
                    "value": "<port>"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb23be5c4>",
                    "type": "UnknownWord",
                    "value": "lsb"
                },
                "references": {
                    "sentences": [
                        "The malware drops an init script at the location /etc/init.d. Init scripts are startup scripts used to run any program when the system starts up. They follow the Linux Standard Base (LSB)-style header section to include default runlevels, descriptions, and dependencies."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb2458ec6>",
                    "type": "UnknownWord",
                    "value": "-style"
                },
                "references": {
                    "sentences": [
                        "The malware drops an init script at the location /etc/init.d. Init scripts are startup scripts used to run any program when the system starts up. They follow the Linux Standard Base (LSB)-style header section to include default runlevels, descriptions, and dependencies."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe0d0443a>",
                    "type": "UnknownWord",
                    "value": "runlevels"
                },
                "references": {
                    "sentences": [
                        "The malware drops an init script at the location /etc/init.d. Init scripts are startup scripts used to run any program when the system starts up. They follow the Linux Standard Base (LSB)-style header section to include default runlevels, descriptions, and dependencies.",
                        "The malware creates a symlink for the init script dropped at the location /etc/init.d/<base_file_name> with the directories associated with runlevels 1 through 5 at /etc/rc<run_level>.d/S90<base_file_name> and /etc/rc.d/rc<run_level>.d/S90<base_file_name>.",
                        "Fetches the process file name corresponding to the provided $pidDeletes the file for the provided $pidDeletes the installed init services:Ends the process that was provided as an argument.Deletes /etc/init.d/<file_name><crlf>For runlevels 1-5, unlinks and deletes /etc/rc<runlevel>.d/S90<file_name><crlf>Performs the command chkconfig del <file_name><crlf>Performs the command update-rc.d <file_name> remove",
                        "A runlevel is a mode of init and the system that specifies what system services are operating for Unix System V-Style operating systems. Runlevels contain a value, typically numbered zero through six, which each designate a different system configuration and allows access to a different combination of processes. Some system administrators set a systems default runlevel according to their needs or use runlevels to identify which subsystems are working, such as whether the network is operational. The /etc/rc<run_level> directory contains symbolic links (symlinks), which are soft links that point to the original file. These symlinks point to the scripts that should run at the specified runlevel."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x67b8622d>",
                    "type": "UnknownWord",
                    "value": "hflggwyfsc"
                },
                "references": {
                    "sentences": [
                        "Figure 7. Content of the init script dropped at the location /etc/init.d/HFLgGwYfSC.elf"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x1a0456ec>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "6e506f32c6fb7b5d342d1382989ab191c6f21c2d311251d8f623814f468952cf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x67b8622d>",
                            "type": "UnknownWord",
                            "value": "hflggwyfsc"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x208a9862>",
                    "type": "UnknownWord",
                    "value": "hourly"
                },
                "references": {
                    "sentences": [
                        "The malware creates a cron script at the location /etc/cron.hourly/gcc.sh.The cron script passes parameters with the following content:",
                        "Figure 9. System command to delete the /etc/cron.hourly/gcc.sh entry from the /etc/crontab file and add a new entry",
                        "DeviceFileEvents<crlf>| extend FullPath=strcat(FolderPath, FileName)<crlf>| where FullPath in (\"/etc/cron.hourly/gcc.sh\", \"/lib/libudev.so.6\", \"/lib/libudev.so\", \"/var/run/gcc.pid\")",
                        "It then creates a /etc/crontab file to run /etc/cron.hourly/gcc.sh every three minutes:"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x133026e0>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "cbb72e542e8f19240130fc9381c2351730d437d42926c6e68e056907c8456459"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x208a9862>",
                            "type": "UnknownWord",
                            "value": "hourly"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x34d4aa96>",
                    "type": "UnknownWord",
                    "value": "runlevel"
                },
                "references": {
                    "sentences": [
                        "System V runlevel",
                        "A runlevel is a mode of init and the system that specifies what system services are operating for Unix System V-Style operating systems. Runlevels contain a value, typically numbered zero through six, which each designate a different system configuration and allows access to a different combination of processes. Some system administrators set a systems default runlevel according to their needs or use runlevels to identify which subsystems are working, such as whether the network is operational. The /etc/rc<run_level> directory contains symbolic links (symlinks), which are soft links that point to the original file. These symlinks point to the scripts that should run at the specified runlevel."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2095f311>",
                    "type": "UnknownWord",
                    "value": "specifies"
                },
                "references": {
                    "sentences": [
                        "A runlevel is a mode of init and the system that specifies what system services are operating for Unix System V-Style operating systems. Runlevels contain a value, typically numbered zero through six, which each designate a different system configuration and allows access to a different combination of processes. Some system administrators set a systems default runlevel according to their needs or use runlevels to identify which subsystems are working, such as whether the network is operational. The /etc/rc<run_level> directory contains symbolic links (symlinks), which are soft links that point to the original file. These symlinks point to the scripts that should run at the specified runlevel."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xedc7db2c>",
                    "type": "UnknownWord",
                    "value": "unix"
                },
                "references": {
                    "sentences": [
                        "A runlevel is a mode of init and the system that specifies what system services are operating for Unix System V-Style operating systems. Runlevels contain a value, typically numbered zero through six, which each designate a different system configuration and allows access to a different combination of processes. Some system administrators set a systems default runlevel according to their needs or use runlevels to identify which subsystems are working, such as whether the network is operational. The /etc/rc<run_level> directory contains symbolic links (symlinks), which are soft links that point to the original file. These symlinks point to the scripts that should run at the specified runlevel."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa7c867be>",
                    "type": "UnknownWord",
                    "value": "v-style"
                },
                "references": {
                    "sentences": [
                        "A runlevel is a mode of init and the system that specifies what system services are operating for Unix System V-Style operating systems. Runlevels contain a value, typically numbered zero through six, which each designate a different system configuration and allows access to a different combination of processes. Some system administrators set a systems default runlevel according to their needs or use runlevels to identify which subsystems are working, such as whether the network is operational. The /etc/rc<run_level> directory contains symbolic links (symlinks), which are soft links that point to the original file. These symlinks point to the scripts that should run at the specified runlevel."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc7b15800>",
                    "type": "UnknownWord",
                    "value": "subsystems"
                },
                "references": {
                    "sentences": [
                        "A runlevel is a mode of init and the system that specifies what system services are operating for Unix System V-Style operating systems. Runlevels contain a value, typically numbered zero through six, which each designate a different system configuration and allows access to a different combination of processes. Some system administrators set a systems default runlevel according to their needs or use runlevels to identify which subsystems are working, such as whether the network is operational. The /etc/rc<run_level> directory contains symbolic links (symlinks), which are soft links that point to the original file. These symlinks point to the scripts that should run at the specified runlevel."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x674c6617>",
                    "type": "UnknownWord",
                    "value": "rc<run_level>"
                },
                "references": {
                    "sentences": [
                        "The malware creates a symlink for the init script dropped at the location /etc/init.d/<base_file_name> with the directories associated with runlevels 1 through 5 at /etc/rc<run_level>.d/S90<base_file_name> and /etc/rc.d/rc<run_level>.d/S90<base_file_name>.",
                        "A runlevel is a mode of init and the system that specifies what system services are operating for Unix System V-Style operating systems. Runlevels contain a value, typically numbered zero through six, which each designate a different system configuration and allows access to a different combination of processes. Some system administrators set a systems default runlevel according to their needs or use runlevels to identify which subsystems are working, such as whether the network is operational. The /etc/rc<run_level> directory contains symbolic links (symlinks), which are soft links that point to the original file. These symlinks point to the scripts that should run at the specified runlevel."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa772a71>",
                    "type": "UnknownWord",
                    "value": "symbolic"
                },
                "references": {
                    "sentences": [
                        "A runlevel is a mode of init and the system that specifies what system services are operating for Unix System V-Style operating systems. Runlevels contain a value, typically numbered zero through six, which each designate a different system configuration and allows access to a different combination of processes. Some system administrators set a systems default runlevel according to their needs or use runlevels to identify which subsystems are working, such as whether the network is operational. The /etc/rc<run_level> directory contains symbolic links (symlinks), which are soft links that point to the original file. These symlinks point to the scripts that should run at the specified runlevel."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcd841c77>",
                    "type": "UnknownWord",
                    "value": "symlinks"
                },
                "references": {
                    "sentences": [
                        "A runlevel is a mode of init and the system that specifies what system services are operating for Unix System V-Style operating systems. Runlevels contain a value, typically numbered zero through six, which each designate a different system configuration and allows access to a different combination of processes. Some system administrators set a systems default runlevel according to their needs or use runlevels to identify which subsystems are working, such as whether the network is operational. The /etc/rc<run_level> directory contains symbolic links (symlinks), which are soft links that point to the original file. These symlinks point to the scripts that should run at the specified runlevel."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1cd21c02>",
                    "type": "UnknownWord",
                    "value": "symlink"
                },
                "references": {
                    "sentences": [
                        "The malware creates a symlink for the init script dropped at the location /etc/init.d/<base_file_name> with the directories associated with runlevels 1 through 5 at /etc/rc<run_level>.d/S90<base_file_name> and /etc/rc.d/rc<run_level>.d/S90<base_file_name>.",
                        "Figure 11. Installation of rc.d directorys symlink scripts with /etc/init.d/<base_file_name>"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf4b58c76>",
                    "type": "UnknownWord",
                    "value": "<base_file_name>"
                },
                "references": {
                    "sentences": [
                        "The malware creates a symlink for the init script dropped at the location /etc/init.d/<base_file_name> with the directories associated with runlevels 1 through 5 at /etc/rc<run_level>.d/S90<base_file_name> and /etc/rc.d/rc<run_level>.d/S90<base_file_name>.",
                        "Figure 11. Installation of rc.d directorys symlink scripts with /etc/init.d/<base_file_name>"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x228e0847>",
                    "type": "UnknownWord",
                    "value": "s90<base_file_name>"
                },
                "references": {
                    "sentences": [
                        "The malware creates a symlink for the init script dropped at the location /etc/init.d/<base_file_name> with the directories associated with runlevels 1 through 5 at /etc/rc<run_level>.d/S90<base_file_name> and /etc/rc.d/rc<run_level>.d/S90<base_file_name>."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc85e443f>",
                    "type": "UnknownWord",
                    "value": "linuxexec_argv2"
                },
                "references": {
                    "sentences": [
                        "The malware runs a command to install startup services that automatically run XorDdos at boot. The malwares LinuxExec_Argv2 subroutine runs the system API with the provided arguments."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x89d0426e>",
                    "type": "UnknownWord",
                    "value": "chkconfig"
                },
                "references": {
                    "sentences": [
                        "Figure 12. chkconfig and update-rc.d commands install the startup service",
                        "Fetches the process file name corresponding to the provided $pidDeletes the file for the provided $pidDeletes the installed init services:Ends the process that was provided as an argument.Deletes /etc/init.d/<file_name><crlf>For runlevels 1-5, unlinks and deletes /etc/rc<runlevel>.d/S90<file_name><crlf>Performs the command chkconfig del <file_name><crlf>Performs the command update-rc.d <file_name> remove",
                        "The commands chkconfig add <service_name> and update-rc.d then add a service that starts the daemon process at boot."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x57e2f34d>",
                    "type": "UnknownWord",
                    "value": "<service_name>"
                },
                "references": {
                    "sentences": [
                        "The commands chkconfig add <service_name> and update-rc.d then add a service that starts the daemon process at boot."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9d78630>",
                    "type": "UnknownWord",
                    "value": "update-rc"
                },
                "references": {
                    "sentences": [
                        "Figure 12. chkconfig and update-rc.d commands install the startup service",
                        "Fetches the process file name corresponding to the provided $pidDeletes the file for the provided $pidDeletes the installed init services:Ends the process that was provided as an argument.Deletes /etc/init.d/<file_name><crlf>For runlevels 1-5, unlinks and deletes /etc/rc<runlevel>.d/S90<file_name><crlf>Performs the command chkconfig del <file_name><crlf>Performs the command update-rc.d <file_name> remove",
                        "The commands chkconfig add <service_name> and update-rc.d then add a service that starts the daemon process at boot."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf07e958>",
                    "type": "UnknownWord",
                    "value": "pids"
                },
                "references": {
                    "sentences": [
                        "The malware spawns new dropped binaries with two additional arguments: a fake command line and its PIDs, for example:",
                        "XorDdos has specific code paths corresponding to the number of arguments provided to the program. This flexibility makes its operation more robust and stealthy. The malware first runs without any argument and then later runs another instance with different arguments, such as PIDs and fake commands, to perform capabilities like clean-up, spoofing, and persistence."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5f8ac00c>",
                    "type": "UnknownWord",
                    "value": "clean-up"
                },
                "references": {
                    "sentences": [
                        "2: Clean-up code path",
                        "XorDdos has specific code paths corresponding to the number of arguments provided to the program. This flexibility makes its operation more robust and stealthy. The malware first runs without any argument and then later runs another instance with different arguments, such as PIDs and fake commands, to perform capabilities like clean-up, spoofing, and persistence."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1e4c0bd7>",
                    "type": "UnknownWord",
                    "value": "readlink"
                },
                "references": {
                    "sentences": [
                        "Fetches the file name specific to the $pid provided as part of the third argument by calling the readlink API on /proc/$pid/exe.If the readlink call fails, that likely indicates that the file on disk doesnt exist. In this case, it:Calls the stat API for the file /lib/libudev.so. If the stat API returns a non-zero value, then it attempts to copy the content of the current processs image-file fetched earlier to the following locations with a random name:If the readlink call is successful and returns the count of bytes copied, sleeps for one second and then loops for the remaining time out of five seconds.Unhides the current process and the $pid that was provided as part of the third argument.Deletes the on-disk file for the current process.Intends to delete all service-related entries for the $pid but fails. This appears to be due to a code flaw that allows a zeroed-out buffer to be passed as a service name when the buffer is supposed to be filled from a successful readlink API call.<crlf>Creates directories similar to the standard code path scenario.<crlf>/usr/bin/<crlf>/bin/<crlf>/tmp/<crlf>Copies the /lib/libudev.so file to the same three directories listed above if the stat API call is successful on /lib/libudev.so.<crlf>Changes the hash of the written or copied file and then runs it without passing any parameters.",
                        "Before handling the argument-based control, it calls the readlink API with the first parameter as /proc/self/exe to fetch its full process path. The full path is used later to create auto-start service entries and read the files content."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xbb3f44ca>",
                            "type": "File",
                            "value": "process.intends"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1e4c0bd7>",
                            "type": "UnknownWord",
                            "value": "readlink"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7373bc55>",
                            "type": "File",
                            "value": "seconds.unhides"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1e4c0bd7>",
                            "type": "UnknownWord",
                            "value": "readlink"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1e4c0bd7>",
                            "type": "UnknownWord",
                            "value": "readlink"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x653dddfa>",
                    "type": "UnknownWord",
                    "value": "self"
                },
                "references": {
                    "sentences": [
                        "Before handling the argument-based control, it calls the readlink API with the first parameter as /proc/self/exe to fetch its full process path. The full path is used later to create auto-start service entries and read the files content."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x81ecc100>",
                    "type": "UnknownWord",
                    "value": "bin bin"
                },
                "references": {
                    "sentences": [
                        "The malware first checks whether its running from the locations /usr/bin/, /bin/, or /tmp/. If its not running from these locations, then it creates and copies itself using a 10-character string name on those locations, as well as /lib/ and /var/run/."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4866af3>",
                    "type": "UnknownWord",
                    "value": "10-character"
                },
                "references": {
                    "sentences": [
                        "Opens the file for writing only<crlf>Calls lseek (fd, 0, SEEK_END) to point at the last position in the file<crlf>Creates a random 10-character string<crlf>Writes the string at the end of the file with an additional null byte",
                        "The malware first checks whether its running from the locations /usr/bin/, /bin/, or /tmp/. If its not running from these locations, then it creates and copies itself using a 10-character string name on those locations, as well as /lib/ and /var/run/."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x162f93ea>",
                    "type": "UnknownWord",
                    "value": "lseek"
                },
                "references": {
                    "sentences": [
                        "Opens the file for writing only<crlf>Calls lseek (fd, 0, SEEK_END) to point at the last position in the file<crlf>Creates a random 10-character string<crlf>Writes the string at the end of the file with an additional null byte"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5d3a5cdb>",
                    "type": "UnknownWord",
                    "value": "seek_end"
                },
                "references": {
                    "sentences": [
                        "Opens the file for writing only<crlf>Calls lseek (fd, 0, SEEK_END) to point at the last position in the file<crlf>Creates a random 10-character string<crlf>Writes the string at the end of the file with an additional null byte"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x871aab5e>",
                    "type": "UnknownWord",
                    "value": "wieegnexuk"
                },
                "references": {
                    "sentences": [
                        "Figure 13. The end of the malware file contains two random strings, wieegnexuk and yybrdajydg, indicating that the original malware binary was modified twice"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9f811b50>",
                    "type": "UnknownWord",
                    "value": "yybrdajydg"
                },
                "references": {
                    "sentences": [
                        "Figure 13. The end of the malware file contains two random strings, wieegnexuk and yybrdajydg, indicating that the original malware binary was modified twice"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x11c34425>",
                    "type": "UnknownWord",
                    "value": "jwvwvxoupv"
                },
                "references": {
                    "sentences": [
                        "/usr/bin/jwvwvxoupv cat resolv.conf 4849<crlf>/usr/bin/jwvwvxoupv gnome-terminal 4849<crlf>/usr/bin/jwvwvxoupv top 4849<crlf>/usr/bin/jwvwvxoupv pwd 4849<crlf>/usr/bin/kagbjahdic id 4849",
                        "/usr/bin/jwvwvxoupv 4849"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x8f66bff6>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "359c41da1cbae573d2c99f7da9eeb03df135f018f6c660b4e44fbd2b4ddecd39"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x11c34425>",
                            "type": "UnknownWord",
                            "value": "jwvwvxoupv"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x11c34425>",
                            "type": "UnknownWord",
                            "value": "jwvwvxoupv"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5967b4ae>",
                    "type": "UnknownWord",
                    "value": "64-byte"
                },
                "references": {
                    "sentences": [
                        "Using the above example, the malware shares the 64-byte size memory segment with the IPC key 0xDA718716 to check for another malware process provided as an argument. If not found, it runs its own binary without any argument and calls the fork() API twice to make sure the grandchild process has no parent. This results in the grandchild process being adopted by the init process, which disconnects it from the process tree and acts as an anti-forensic technique."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x86c97e0c>",
                    "type": "UnknownWord",
                    "value": "ipc"
                },
                "references": {
                    "sentences": [
                        "Using the above example, the malware shares the 64-byte size memory segment with the IPC key 0xDA718716 to check for another malware process provided as an argument. If not found, it runs its own binary without any argument and calls the fork() API twice to make sure the grandchild process has no parent. This results in the grandchild process being adopted by the init process, which disconnects it from the process tree and acts as an anti-forensic technique."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x36471338>",
                    "type": "UnknownWord",
                    "value": "grandchild"
                },
                "references": {
                    "sentences": [
                        "Using the above example, the malware shares the 64-byte size memory segment with the IPC key 0xDA718716 to check for another malware process provided as an argument. If not found, it runs its own binary without any argument and calls the fork() API twice to make sure the grandchild process has no parent. This results in the grandchild process being adopted by the init process, which disconnects it from the process tree and acts as an anti-forensic technique."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd0752dd8>",
                    "type": "UnknownWord",
                    "value": "tree"
                },
                "references": {
                    "sentences": [
                        "Using the above example, the malware shares the 64-byte size memory segment with the IPC key 0xDA718716 to check for another malware process provided as an argument. If not found, it runs its own binary without any argument and calls the fork() API twice to make sure the grandchild process has no parent. This results in the grandchild process being adopted by the init process, which disconnects it from the process tree and acts as an anti-forensic technique.",
                        "In this code path, the malware uses process name spoofing to hide from the process tree by modifying its fake command line at runtime. It then hides its process by calling HidePidPort with command 1 and reads the content of the file on disk related to the current process.",
                        "When XorDdos is detected on a device, Microsoft 365 Defender raises an alert, which shows the complete attack chain, including the process tree, file information, user information, and prevention details."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x90299db1>",
                    "type": "UnknownWord",
                    "value": "piddeletes"
                },
                "references": {
                    "sentences": [
                        "Fetches the process file name corresponding to the provided $pidDeletes the file for the provided $pidDeletes the installed init services:Ends the process that was provided as an argument.Deletes /etc/init.d/<file_name><crlf>For runlevels 1-5, unlinks and deletes /etc/rc<runlevel>.d/S90<file_name><crlf>Performs the command chkconfig del <file_name><crlf>Performs the command update-rc.d <file_name> remove"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x90299db1>",
                            "type": "UnknownWord",
                            "value": "piddeletes"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x665b92c6>",
                    "type": "UnknownWord",
                    "value": "<file_name>"
                },
                "references": {
                    "sentences": [
                        "Fetches the process file name corresponding to the provided $pidDeletes the file for the provided $pidDeletes the installed init services:Ends the process that was provided as an argument.Deletes /etc/init.d/<file_name><crlf>For runlevels 1-5, unlinks and deletes /etc/rc<runlevel>.d/S90<file_name><crlf>Performs the command chkconfig del <file_name><crlf>Performs the command update-rc.d <file_name> remove"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x665b92c6>",
                            "type": "UnknownWord",
                            "value": "<file_name>"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc7d84d0e>",
                    "type": "UnknownWord",
                    "value": "1-5"
                },
                "references": {
                    "sentences": [
                        "Fetches the process file name corresponding to the provided $pidDeletes the file for the provided $pidDeletes the installed init services:Ends the process that was provided as an argument.Deletes /etc/init.d/<file_name><crlf>For runlevels 1-5, unlinks and deletes /etc/rc<runlevel>.d/S90<file_name><crlf>Performs the command chkconfig del <file_name><crlf>Performs the command update-rc.d <file_name> remove"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x51cdd79b>",
                    "type": "UnknownWord",
                    "value": "unlinks"
                },
                "references": {
                    "sentences": [
                        "Fetches the process file name corresponding to the provided $pidDeletes the file for the provided $pidDeletes the installed init services:Ends the process that was provided as an argument.Deletes /etc/init.d/<file_name><crlf>For runlevels 1-5, unlinks and deletes /etc/rc<runlevel>.d/S90<file_name><crlf>Performs the command chkconfig del <file_name><crlf>Performs the command update-rc.d <file_name> remove"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4ea7e787>",
                    "type": "UnknownWord",
                    "value": "rc<runlevel>"
                },
                "references": {
                    "sentences": [
                        "Fetches the process file name corresponding to the provided $pidDeletes the file for the provided $pidDeletes the installed init services:Ends the process that was provided as an argument.Deletes /etc/init.d/<file_name><crlf>For runlevels 1-5, unlinks and deletes /etc/rc<runlevel>.d/S90<file_name><crlf>Performs the command chkconfig del <file_name><crlf>Performs the command update-rc.d <file_name> remove"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe072247>",
                    "type": "UnknownWord",
                    "value": "s90<file_name>"
                },
                "references": {
                    "sentences": [
                        "Fetches the process file name corresponding to the provided $pidDeletes the file for the provided $pidDeletes the installed init services:Ends the process that was provided as an argument.Deletes /etc/init.d/<file_name><crlf>For runlevels 1-5, unlinks and deletes /etc/rc<runlevel>.d/S90<file_name><crlf>Performs the command chkconfig del <file_name><crlf>Performs the command update-rc.d <file_name> remove"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7f85edb3>",
                    "type": "UnknownWord",
                    "value": "del"
                },
                "references": {
                    "sentences": [
                        "Fetches the process file name corresponding to the provided $pidDeletes the file for the provided $pidDeletes the installed init services:Ends the process that was provided as an argument.Deletes /etc/init.d/<file_name><crlf>For runlevels 1-5, unlinks and deletes /etc/rc<runlevel>.d/S90<file_name><crlf>Performs the command chkconfig del <file_name><crlf>Performs the command update-rc.d <file_name> remove"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1b8113cd>",
                    "type": "UnknownWord",
                    "value": "gnome-terminal"
                },
                "references": {
                    "sentences": [
                        "cat resolv.conf<crlf>netstat -an<crlf>bash<crlf>whoami<crlf>id<crlf>cd /etc<crlf>ifconfig eth0<crlf>ifconfig<crlf>echo find<crlf>uptime<crlf>sh<crlf>top<crlf>gnome-terminal<crlf>su<crlf>netstat -antop<crlf>grep A<crlf>who<crlf>ls -la<crlf>pwd<crlf>route -n<crlf>ps -ef<crlf>ls<crlf>sleep 1",
                        "/usr/bin/jwvwvxoupv cat resolv.conf 4849<crlf>/usr/bin/jwvwvxoupv gnome-terminal 4849<crlf>/usr/bin/jwvwvxoupv top 4849<crlf>/usr/bin/jwvwvxoupv pwd 4849<crlf>/usr/bin/kagbjahdic id 4849"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x987c99af>",
                    "type": "UnknownWord",
                    "value": "usr bin kagbjahdic"
                },
                "references": {
                    "sentences": [
                        "/usr/bin/jwvwvxoupv cat resolv.conf 4849<crlf>/usr/bin/jwvwvxoupv gnome-terminal 4849<crlf>/usr/bin/jwvwvxoupv top 4849<crlf>/usr/bin/jwvwvxoupv pwd 4849<crlf>/usr/bin/kagbjahdic id 4849"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2b17fb1b>",
                    "type": "UnknownWord",
                    "value": "netstat"
                },
                "references": {
                    "sentences": [
                        "cat resolv.conf<crlf>netstat -an<crlf>bash<crlf>whoami<crlf>id<crlf>cd /etc<crlf>ifconfig eth0<crlf>ifconfig<crlf>echo find<crlf>uptime<crlf>sh<crlf>top<crlf>gnome-terminal<crlf>su<crlf>netstat -antop<crlf>grep A<crlf>who<crlf>ls -la<crlf>pwd<crlf>route -n<crlf>ps -ef<crlf>ls<crlf>sleep 1"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe7974793>",
                    "type": "UnknownWord",
                    "value": "-an"
                },
                "references": {
                    "sentences": [
                        "cat resolv.conf<crlf>netstat -an<crlf>bash<crlf>whoami<crlf>id<crlf>cd /etc<crlf>ifconfig eth0<crlf>ifconfig<crlf>echo find<crlf>uptime<crlf>sh<crlf>top<crlf>gnome-terminal<crlf>su<crlf>netstat -antop<crlf>grep A<crlf>who<crlf>ls -la<crlf>pwd<crlf>route -n<crlf>ps -ef<crlf>ls<crlf>sleep 1"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8d72ed02>",
                    "type": "UnknownWord",
                    "value": "ifconfig"
                },
                "references": {
                    "sentences": [
                        "cat resolv.conf<crlf>netstat -an<crlf>bash<crlf>whoami<crlf>id<crlf>cd /etc<crlf>ifconfig eth0<crlf>ifconfig<crlf>echo find<crlf>uptime<crlf>sh<crlf>top<crlf>gnome-terminal<crlf>su<crlf>netstat -antop<crlf>grep A<crlf>who<crlf>ls -la<crlf>pwd<crlf>route -n<crlf>ps -ef<crlf>ls<crlf>sleep 1",
                        "The content of libudev.so was collected into libudev.so.6<crlf>bash process performed System Information Discovery by invoking ifconfig<crlf>gcc.sh was executed after being dropped by HFLgGwYfSC.elf<crlf>A shell command was executed by crond<crlf>SUID/SGID process unix_chkpwd executed"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x556509e0>",
                    "type": "UnknownWord",
                    "value": "echo"
                },
                "references": {
                    "sentences": [
                        "cat resolv.conf<crlf>netstat -an<crlf>bash<crlf>whoami<crlf>id<crlf>cd /etc<crlf>ifconfig eth0<crlf>ifconfig<crlf>echo find<crlf>uptime<crlf>sh<crlf>top<crlf>gnome-terminal<crlf>su<crlf>netstat -antop<crlf>grep A<crlf>who<crlf>ls -la<crlf>pwd<crlf>route -n<crlf>ps -ef<crlf>ls<crlf>sleep 1"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9e1b6290>",
                    "type": "UnknownWord",
                    "value": "su"
                },
                "references": {
                    "sentences": [
                        "cat resolv.conf<crlf>netstat -an<crlf>bash<crlf>whoami<crlf>id<crlf>cd /etc<crlf>ifconfig eth0<crlf>ifconfig<crlf>echo find<crlf>uptime<crlf>sh<crlf>top<crlf>gnome-terminal<crlf>su<crlf>netstat -antop<crlf>grep A<crlf>who<crlf>ls -la<crlf>pwd<crlf>route -n<crlf>ps -ef<crlf>ls<crlf>sleep 1"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb65ae31b>",
                    "type": "UnknownWord",
                    "value": "-antop"
                },
                "references": {
                    "sentences": [
                        "cat resolv.conf<crlf>netstat -an<crlf>bash<crlf>whoami<crlf>id<crlf>cd /etc<crlf>ifconfig eth0<crlf>ifconfig<crlf>echo find<crlf>uptime<crlf>sh<crlf>top<crlf>gnome-terminal<crlf>su<crlf>netstat -antop<crlf>grep A<crlf>who<crlf>ls -la<crlf>pwd<crlf>route -n<crlf>ps -ef<crlf>ls<crlf>sleep 1"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6646d5d>",
                    "type": "UnknownWord",
                    "value": "grep"
                },
                "references": {
                    "sentences": [
                        "cat resolv.conf<crlf>netstat -an<crlf>bash<crlf>whoami<crlf>id<crlf>cd /etc<crlf>ifconfig eth0<crlf>ifconfig<crlf>echo find<crlf>uptime<crlf>sh<crlf>top<crlf>gnome-terminal<crlf>su<crlf>netstat -antop<crlf>grep A<crlf>who<crlf>ls -la<crlf>pwd<crlf>route -n<crlf>ps -ef<crlf>ls<crlf>sleep 1"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcd034058>",
                    "type": "UnknownWord",
                    "value": "-la"
                },
                "references": {
                    "sentences": [
                        "cat resolv.conf<crlf>netstat -an<crlf>bash<crlf>whoami<crlf>id<crlf>cd /etc<crlf>ifconfig eth0<crlf>ifconfig<crlf>echo find<crlf>uptime<crlf>sh<crlf>top<crlf>gnome-terminal<crlf>su<crlf>netstat -antop<crlf>grep A<crlf>who<crlf>ls -la<crlf>pwd<crlf>route -n<crlf>ps -ef<crlf>ls<crlf>sleep 1"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa6d88e03>",
                    "type": "UnknownWord",
                    "value": "route"
                },
                "references": {
                    "sentences": [
                        "cat resolv.conf<crlf>netstat -an<crlf>bash<crlf>whoami<crlf>id<crlf>cd /etc<crlf>ifconfig eth0<crlf>ifconfig<crlf>echo find<crlf>uptime<crlf>sh<crlf>top<crlf>gnome-terminal<crlf>su<crlf>netstat -antop<crlf>grep A<crlf>who<crlf>ls -la<crlf>pwd<crlf>route -n<crlf>ps -ef<crlf>ls<crlf>sleep 1"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf2aa496b>",
                    "type": "UnknownWord",
                    "value": "-n"
                },
                "references": {
                    "sentences": [
                        "cat resolv.conf<crlf>netstat -an<crlf>bash<crlf>whoami<crlf>id<crlf>cd /etc<crlf>ifconfig eth0<crlf>ifconfig<crlf>echo find<crlf>uptime<crlf>sh<crlf>top<crlf>gnome-terminal<crlf>su<crlf>netstat -antop<crlf>grep A<crlf>who<crlf>ls -la<crlf>pwd<crlf>route -n<crlf>ps -ef<crlf>ls<crlf>sleep 1"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf4437598>",
                    "type": "UnknownWord",
                    "value": "ps -ef"
                },
                "references": {
                    "sentences": [
                        "cat resolv.conf<crlf>netstat -an<crlf>bash<crlf>whoami<crlf>id<crlf>cd /etc<crlf>ifconfig eth0<crlf>ifconfig<crlf>echo find<crlf>uptime<crlf>sh<crlf>top<crlf>gnome-terminal<crlf>su<crlf>netstat -antop<crlf>grep A<crlf>who<crlf>ls -la<crlf>pwd<crlf>route -n<crlf>ps -ef<crlf>ls<crlf>sleep 1"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8121392f>",
                    "type": "UnknownWord",
                    "value": "hidepidport"
                },
                "references": {
                    "sentences": [
                        "In this code path, the malware uses process name spoofing to hide from the process tree by modifying its fake command line at runtime. It then hides its process by calling HidePidPort with command 1 and reads the content of the file on disk related to the current process.",
                        "AddService Creates the persistent auto-start entries previously mentioned so that the malware runs when the system starts.<crlf>HidePidPort Hides the malwares ports and processes.<crlf>CheckLKM Checks whether the rootkit device is active or not. It uses a similar IOCTL call with the number 0x9748712 and command 0 to find if the rootkit is active. If the rootkit is active, it uses the owner value 0xAD1473B8 and group value 0xAD1473B8 to change the ownership of dropped files with the function lchown(<filename>, 0xAD1473B8, 0xAD1473B8).<crlf>decrypt_remotestr Decodes remote URLs using the same XOR key, BB2FA36AAA9541F0, to decode config.rar and the other directories. After decoding the URLs, it adds them into a remote list, which is later used to communicate and fetch commands from the command and control (C2) server:www[.]enoan2107[.]com:3306www[.]gzcfr5axf6[.]com:3306"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb5edd421>",
                    "type": "UnknownWord",
                    "value": "five-second"
                },
                "references": {
                    "sentences": [
                        "It then enters a five-second loop to perform the following checks:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x4faa7172>",
                    "type": "UnknownWord",
                    "value": "non-zero"
                },
                "references": {
                    "sentences": [
                        "Fetches the file name specific to the $pid provided as part of the third argument by calling the readlink API on /proc/$pid/exe.If the readlink call fails, that likely indicates that the file on disk doesnt exist. In this case, it:Calls the stat API for the file /lib/libudev.so. If the stat API returns a non-zero value, then it attempts to copy the content of the current processs image-file fetched earlier to the following locations with a random name:If the readlink call is successful and returns the count of bytes copied, sleeps for one second and then loops for the remaining time out of five seconds.Unhides the current process and the $pid that was provided as part of the third argument.Deletes the on-disk file for the current process.Intends to delete all service-related entries for the $pid but fails. This appears to be due to a code flaw that allows a zeroed-out buffer to be passed as a service name when the buffer is supposed to be filled from a successful readlink API call.<crlf>Creates directories similar to the standard code path scenario.<crlf>/usr/bin/<crlf>/bin/<crlf>/tmp/<crlf>Copies the /lib/libudev.so file to the same three directories listed above if the stat API call is successful on /lib/libudev.so.<crlf>Changes the hash of the written or copied file and then runs it without passing any parameters."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xbb3f44ca>",
                            "type": "File",
                            "value": "process.intends"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4faa7172>",
                            "type": "UnknownWord",
                            "value": "non-zero"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4faa7172>",
                            "type": "UnknownWord",
                            "value": "non-zero"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7373bc55>",
                            "type": "File",
                            "value": "seconds.unhides"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x4faa7172>",
                            "type": "UnknownWord",
                            "value": "non-zero"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd67f6c51>",
                    "type": "UnknownWord",
                    "value": "image-file"
                },
                "references": {
                    "sentences": [
                        "Fetches the file name specific to the $pid provided as part of the third argument by calling the readlink API on /proc/$pid/exe.If the readlink call fails, that likely indicates that the file on disk doesnt exist. In this case, it:Calls the stat API for the file /lib/libudev.so. If the stat API returns a non-zero value, then it attempts to copy the content of the current processs image-file fetched earlier to the following locations with a random name:If the readlink call is successful and returns the count of bytes copied, sleeps for one second and then loops for the remaining time out of five seconds.Unhides the current process and the $pid that was provided as part of the third argument.Deletes the on-disk file for the current process.Intends to delete all service-related entries for the $pid but fails. This appears to be due to a code flaw that allows a zeroed-out buffer to be passed as a service name when the buffer is supposed to be filled from a successful readlink API call.<crlf>Creates directories similar to the standard code path scenario.<crlf>/usr/bin/<crlf>/bin/<crlf>/tmp/<crlf>Copies the /lib/libudev.so file to the same three directories listed above if the stat API call is successful on /lib/libudev.so.<crlf>Changes the hash of the written or copied file and then runs it without passing any parameters."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xbb3f44ca>",
                            "type": "File",
                            "value": "process.intends"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd67f6c51>",
                            "type": "UnknownWord",
                            "value": "image-file"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7373bc55>",
                            "type": "File",
                            "value": "seconds.unhides"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd67f6c51>",
                            "type": "UnknownWord",
                            "value": "image-file"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xd67f6c51>",
                            "type": "UnknownWord",
                            "value": "image-file"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x55b3a03a>",
                    "type": "UnknownWord",
                    "value": "fetched"
                },
                "references": {
                    "sentences": [
                        "Fetches the file name specific to the $pid provided as part of the third argument by calling the readlink API on /proc/$pid/exe.If the readlink call fails, that likely indicates that the file on disk doesnt exist. In this case, it:Calls the stat API for the file /lib/libudev.so. If the stat API returns a non-zero value, then it attempts to copy the content of the current processs image-file fetched earlier to the following locations with a random name:If the readlink call is successful and returns the count of bytes copied, sleeps for one second and then loops for the remaining time out of five seconds.Unhides the current process and the $pid that was provided as part of the third argument.Deletes the on-disk file for the current process.Intends to delete all service-related entries for the $pid but fails. This appears to be due to a code flaw that allows a zeroed-out buffer to be passed as a service name when the buffer is supposed to be filled from a successful readlink API call.<crlf>Creates directories similar to the standard code path scenario.<crlf>/usr/bin/<crlf>/bin/<crlf>/tmp/<crlf>Copies the /lib/libudev.so file to the same three directories listed above if the stat API call is successful on /lib/libudev.so.<crlf>Changes the hash of the written or copied file and then runs it without passing any parameters."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x55b3a03a>",
                            "type": "UnknownWord",
                            "value": "fetched"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xbb3f44ca>",
                            "type": "File",
                            "value": "process.intends"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x55b3a03a>",
                            "type": "UnknownWord",
                            "value": "fetched"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7373bc55>",
                            "type": "File",
                            "value": "seconds.unhides"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x55b3a03a>",
                            "type": "UnknownWord",
                            "value": "fetched"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbd76d9c5>",
                    "type": "UnknownWord",
                    "value": "on-disk"
                },
                "references": {
                    "sentences": [
                        "Fetches the file name specific to the $pid provided as part of the third argument by calling the readlink API on /proc/$pid/exe.If the readlink call fails, that likely indicates that the file on disk doesnt exist. In this case, it:Calls the stat API for the file /lib/libudev.so. If the stat API returns a non-zero value, then it attempts to copy the content of the current processs image-file fetched earlier to the following locations with a random name:If the readlink call is successful and returns the count of bytes copied, sleeps for one second and then loops for the remaining time out of five seconds.Unhides the current process and the $pid that was provided as part of the third argument.Deletes the on-disk file for the current process.Intends to delete all service-related entries for the $pid but fails. This appears to be due to a code flaw that allows a zeroed-out buffer to be passed as a service name when the buffer is supposed to be filled from a successful readlink API call.<crlf>Creates directories similar to the standard code path scenario.<crlf>/usr/bin/<crlf>/bin/<crlf>/tmp/<crlf>Copies the /lib/libudev.so file to the same three directories listed above if the stat API call is successful on /lib/libudev.so.<crlf>Changes the hash of the written or copied file and then runs it without passing any parameters."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0xbb3f44ca>",
                            "type": "File",
                            "value": "process.intends"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbd76d9c5>",
                            "type": "UnknownWord",
                            "value": "on-disk"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7373bc55>",
                            "type": "File",
                            "value": "seconds.unhides"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbd76d9c5>",
                            "type": "UnknownWord",
                            "value": "on-disk"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbd76d9c5>",
                            "type": "UnknownWord",
                            "value": "on-disk"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe93107f8>",
                    "type": "UnknownWord",
                    "value": "service-related"
                },
                "references": {
                    "sentences": [
                        "Fetches the file name specific to the $pid provided as part of the third argument by calling the readlink API on /proc/$pid/exe.If the readlink call fails, that likely indicates that the file on disk doesnt exist. In this case, it:Calls the stat API for the file /lib/libudev.so. If the stat API returns a non-zero value, then it attempts to copy the content of the current processs image-file fetched earlier to the following locations with a random name:If the readlink call is successful and returns the count of bytes copied, sleeps for one second and then loops for the remaining time out of five seconds.Unhides the current process and the $pid that was provided as part of the third argument.Deletes the on-disk file for the current process.Intends to delete all service-related entries for the $pid but fails. This appears to be due to a code flaw that allows a zeroed-out buffer to be passed as a service name when the buffer is supposed to be filled from a successful readlink API call.<crlf>Creates directories similar to the standard code path scenario.<crlf>/usr/bin/<crlf>/bin/<crlf>/tmp/<crlf>Copies the /lib/libudev.so file to the same three directories listed above if the stat API call is successful on /lib/libudev.so.<crlf>Changes the hash of the written or copied file and then runs it without passing any parameters."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x6aec4444>",
                            "type": "File",
                            "value": "argument.deletes"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe93107f8>",
                            "type": "UnknownWord",
                            "value": "service-related"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0xbb3f44ca>",
                            "type": "File",
                            "value": "process.intends"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe93107f8>",
                            "type": "UnknownWord",
                            "value": "service-related"
                        }
                    },
                    {
                        "src": {
                            "id": "<FILE_0x7373bc55>",
                            "type": "File",
                            "value": "seconds.unhides"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xe93107f8>",
                            "type": "UnknownWord",
                            "value": "service-related"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xab9391f1>",
                    "type": "UnknownWord",
                    "value": "zeroed-out"
                },
                "references": {
                    "sentences": [
                        "Fetches the file name specific to the $pid provided as part of the third argument by calling the readlink API on /proc/$pid/exe.If the readlink call fails, that likely indicates that the file on disk doesnt exist. In this case, it:Calls the stat API for the file /lib/libudev.so. If the stat API returns a non-zero value, then it attempts to copy the content of the current processs image-file fetched earlier to the following locations with a random name:If the readlink call is successful and returns the count of bytes copied, sleeps for one second and then loops for the remaining time out of five seconds.Unhides the current process and the $pid that was provided as part of the third argument.Deletes the on-disk file for the current process.Intends to delete all service-related entries for the $pid but fails. This appears to be due to a code flaw that allows a zeroed-out buffer to be passed as a service name when the buffer is supposed to be filled from a successful readlink API call.<crlf>Creates directories similar to the standard code path scenario.<crlf>/usr/bin/<crlf>/bin/<crlf>/tmp/<crlf>Copies the /lib/libudev.so file to the same three directories listed above if the stat API call is successful on /lib/libudev.so.<crlf>Changes the hash of the written or copied file and then runs it without passing any parameters."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8987889a>",
                    "type": "UnknownWord",
                    "value": "installsys"
                },
                "references": {
                    "sentences": [
                        "Figure 14. Dummy InstallSYS routine",
                        "InstallSYS The name suggests that this function is a wrapper that should deploy a rootkit driver, but it only zeroes-out two local arrays."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb9b6e6d2>",
                    "type": "UnknownWord",
                    "value": "zeroes-out"
                },
                "references": {
                    "sentences": [
                        "InstallSYS The name suggests that this function is a wrapper that should deploy a rootkit driver, but it only zeroes-out two local arrays."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3efd83c1>",
                    "type": "UnknownWord",
                    "value": "addservice"
                },
                "references": {
                    "sentences": [
                        "AddService Creates the persistent auto-start entries previously mentioned so that the malware runs when the system starts.<crlf>HidePidPort Hides the malwares ports and processes.<crlf>CheckLKM Checks whether the rootkit device is active or not. It uses a similar IOCTL call with the number 0x9748712 and command 0 to find if the rootkit is active. If the rootkit is active, it uses the owner value 0xAD1473B8 and group value 0xAD1473B8 to change the ownership of dropped files with the function lchown(<filename>, 0xAD1473B8, 0xAD1473B8).<crlf>decrypt_remotestr Decodes remote URLs using the same XOR key, BB2FA36AAA9541F0, to decode config.rar and the other directories. After decoding the URLs, it adds them into a remote list, which is later used to communicate and fetch commands from the command and control (C2) server:www[.]enoan2107[.]com:3306www[.]gzcfr5axf6[.]com:3306"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd743d385>",
                    "type": "UnknownWord",
                    "value": "checklkm"
                },
                "references": {
                    "sentences": [
                        "AddService Creates the persistent auto-start entries previously mentioned so that the malware runs when the system starts.<crlf>HidePidPort Hides the malwares ports and processes.<crlf>CheckLKM Checks whether the rootkit device is active or not. It uses a similar IOCTL call with the number 0x9748712 and command 0 to find if the rootkit is active. If the rootkit is active, it uses the owner value 0xAD1473B8 and group value 0xAD1473B8 to change the ownership of dropped files with the function lchown(<filename>, 0xAD1473B8, 0xAD1473B8).<crlf>decrypt_remotestr Decodes remote URLs using the same XOR key, BB2FA36AAA9541F0, to decode config.rar and the other directories. After decoding the URLs, it adds them into a remote list, which is later used to communicate and fetch commands from the command and control (C2) server:www[.]enoan2107[.]com:3306www[.]gzcfr5axf6[.]com:3306"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf2832597>",
                    "type": "UnknownWord",
                    "value": "0xad1473b8"
                },
                "references": {
                    "sentences": [
                        "AddService Creates the persistent auto-start entries previously mentioned so that the malware runs when the system starts.<crlf>HidePidPort Hides the malwares ports and processes.<crlf>CheckLKM Checks whether the rootkit device is active or not. It uses a similar IOCTL call with the number 0x9748712 and command 0 to find if the rootkit is active. If the rootkit is active, it uses the owner value 0xAD1473B8 and group value 0xAD1473B8 to change the ownership of dropped files with the function lchown(<filename>, 0xAD1473B8, 0xAD1473B8).<crlf>decrypt_remotestr Decodes remote URLs using the same XOR key, BB2FA36AAA9541F0, to decode config.rar and the other directories. After decoding the URLs, it adds them into a remote list, which is later used to communicate and fetch commands from the command and control (C2) server:www[.]enoan2107[.]com:3306www[.]gzcfr5axf6[.]com:3306"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x107ec87c>",
                    "type": "UnknownWord",
                    "value": "0xad1473b8 0xad1473b8"
                },
                "references": {
                    "sentences": [
                        "AddService Creates the persistent auto-start entries previously mentioned so that the malware runs when the system starts.<crlf>HidePidPort Hides the malwares ports and processes.<crlf>CheckLKM Checks whether the rootkit device is active or not. It uses a similar IOCTL call with the number 0x9748712 and command 0 to find if the rootkit is active. If the rootkit is active, it uses the owner value 0xAD1473B8 and group value 0xAD1473B8 to change the ownership of dropped files with the function lchown(<filename>, 0xAD1473B8, 0xAD1473B8).<crlf>decrypt_remotestr Decodes remote URLs using the same XOR key, BB2FA36AAA9541F0, to decode config.rar and the other directories. After decoding the URLs, it adds them into a remote list, which is later used to communicate and fetch commands from the command and control (C2) server:www[.]enoan2107[.]com:3306www[.]gzcfr5axf6[.]com:3306"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6d577a51>",
                    "type": "UnknownWord",
                    "value": "lchown"
                },
                "references": {
                    "sentences": [
                        "AddService Creates the persistent auto-start entries previously mentioned so that the malware runs when the system starts.<crlf>HidePidPort Hides the malwares ports and processes.<crlf>CheckLKM Checks whether the rootkit device is active or not. It uses a similar IOCTL call with the number 0x9748712 and command 0 to find if the rootkit is active. If the rootkit is active, it uses the owner value 0xAD1473B8 and group value 0xAD1473B8 to change the ownership of dropped files with the function lchown(<filename>, 0xAD1473B8, 0xAD1473B8).<crlf>decrypt_remotestr Decodes remote URLs using the same XOR key, BB2FA36AAA9541F0, to decode config.rar and the other directories. After decoding the URLs, it adds them into a remote list, which is later used to communicate and fetch commands from the command and control (C2) server:www[.]enoan2107[.]com:3306www[.]gzcfr5axf6[.]com:3306"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbb7e5503>",
                    "type": "UnknownWord",
                    "value": "<filename>"
                },
                "references": {
                    "sentences": [
                        "AddService Creates the persistent auto-start entries previously mentioned so that the malware runs when the system starts.<crlf>HidePidPort Hides the malwares ports and processes.<crlf>CheckLKM Checks whether the rootkit device is active or not. It uses a similar IOCTL call with the number 0x9748712 and command 0 to find if the rootkit is active. If the rootkit is active, it uses the owner value 0xAD1473B8 and group value 0xAD1473B8 to change the ownership of dropped files with the function lchown(<filename>, 0xAD1473B8, 0xAD1473B8).<crlf>decrypt_remotestr Decodes remote URLs using the same XOR key, BB2FA36AAA9541F0, to decode config.rar and the other directories. After decoding the URLs, it adds them into a remote list, which is later used to communicate and fetch commands from the command and control (C2) server:www[.]enoan2107[.]com:3306www[.]gzcfr5axf6[.]com:3306"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x76b2e5cf>",
                    "type": "UnknownWord",
                    "value": "decrypt_remotestr"
                },
                "references": {
                    "sentences": [
                        "The tcp_thread triggers the connection with the C2 server decoded earlier using decrypt_remotestr(). It performs the following tasks:",
                        "AddService Creates the persistent auto-start entries previously mentioned so that the malware runs when the system starts.<crlf>HidePidPort Hides the malwares ports and processes.<crlf>CheckLKM Checks whether the rootkit device is active or not. It uses a similar IOCTL call with the number 0x9748712 and command 0 to find if the rootkit is active. If the rootkit is active, it uses the owner value 0xAD1473B8 and group value 0xAD1473B8 to change the ownership of dropped files with the function lchown(<filename>, 0xAD1473B8, 0xAD1473B8).<crlf>decrypt_remotestr Decodes remote URLs using the same XOR key, BB2FA36AAA9541F0, to decode config.rar and the other directories. After decoding the URLs, it adds them into a remote list, which is later used to communicate and fetch commands from the command and control (C2) server:www[.]enoan2107[.]com:3306www[.]gzcfr5axf6[.]com:3306"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x76b2e5cf>",
                            "type": "UnknownWord",
                            "value": "decrypt_remotestr"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xed4d612>",
                    "type": "UnknownWord",
                    "value": "enoan2107"
                },
                "references": {
                    "sentences": [
                        "AddService Creates the persistent auto-start entries previously mentioned so that the malware runs when the system starts.<crlf>HidePidPort Hides the malwares ports and processes.<crlf>CheckLKM Checks whether the rootkit device is active or not. It uses a similar IOCTL call with the number 0x9748712 and command 0 to find if the rootkit is active. If the rootkit is active, it uses the owner value 0xAD1473B8 and group value 0xAD1473B8 to change the ownership of dropped files with the function lchown(<filename>, 0xAD1473B8, 0xAD1473B8).<crlf>decrypt_remotestr Decodes remote URLs using the same XOR key, BB2FA36AAA9541F0, to decode config.rar and the other directories. After decoding the URLs, it adds them into a remote list, which is later used to communicate and fetch commands from the command and control (C2) server:www[.]enoan2107[.]com:3306www[.]gzcfr5axf6[.]com:3306"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x152e39ee>",
                    "type": "UnknownWord",
                    "value": "3306www"
                },
                "references": {
                    "sentences": [
                        "AddService Creates the persistent auto-start entries previously mentioned so that the malware runs when the system starts.<crlf>HidePidPort Hides the malwares ports and processes.<crlf>CheckLKM Checks whether the rootkit device is active or not. It uses a similar IOCTL call with the number 0x9748712 and command 0 to find if the rootkit is active. If the rootkit is active, it uses the owner value 0xAD1473B8 and group value 0xAD1473B8 to change the ownership of dropped files with the function lchown(<filename>, 0xAD1473B8, 0xAD1473B8).<crlf>decrypt_remotestr Decodes remote URLs using the same XOR key, BB2FA36AAA9541F0, to decode config.rar and the other directories. After decoding the URLs, it adds them into a remote list, which is later used to communicate and fetch commands from the command and control (C2) server:www[.]enoan2107[.]com:3306www[.]gzcfr5axf6[.]com:3306"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc18c338a>",
                    "type": "UnknownWord",
                    "value": "gzcfr5axf6"
                },
                "references": {
                    "sentences": [
                        "AddService Creates the persistent auto-start entries previously mentioned so that the malware runs when the system starts.<crlf>HidePidPort Hides the malwares ports and processes.<crlf>CheckLKM Checks whether the rootkit device is active or not. It uses a similar IOCTL call with the number 0x9748712 and command 0 to find if the rootkit is active. If the rootkit is active, it uses the owner value 0xAD1473B8 and group value 0xAD1473B8 to change the ownership of dropped files with the function lchown(<filename>, 0xAD1473B8, 0xAD1473B8).<crlf>decrypt_remotestr Decodes remote URLs using the same XOR key, BB2FA36AAA9541F0, to decode config.rar and the other directories. After decoding the URLs, it adds them into a remote list, which is later used to communicate and fetch commands from the command and control (C2) server:www[.]enoan2107[.]com:3306www[.]gzcfr5axf6[.]com:3306"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x89147a11>",
                    "type": "UnknownWord",
                    "value": "initializes"
                },
                "references": {
                    "sentences": [
                        "The malware then initializes three threads to perform malicious activities, such as stopping a process, creating a TCP connection, and retrieving kill_cfg data.",
                        "After creating persistent entries, deleting evidence of its activities, and decoding config.rar, the malware initializes a cyclic redundancy check (CRC) table followed by an unnamed semaphore using the sem_init API. This semaphore is initialized with apshared value set to 0, making the resultant semaphore shared between all the threads. The semaphore is used to maintain concurrency between threads accessing a shared object, such as kill_cfg data."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x89147a11>",
                            "type": "UnknownWord",
                            "value": "initializes"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc4b1ceb>",
                    "type": "UnknownWord",
                    "value": "cyclic"
                },
                "references": {
                    "sentences": [
                        "After creating persistent entries, deleting evidence of its activities, and decoding config.rar, the malware initializes a cyclic redundancy check (CRC) table followed by an unnamed semaphore using the sem_init API. This semaphore is initialized with apshared value set to 0, making the resultant semaphore shared between all the threads. The semaphore is used to maintain concurrency between threads accessing a shared object, such as kill_cfg data."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc4b1ceb>",
                            "type": "UnknownWord",
                            "value": "cyclic"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3ff27b2>",
                    "type": "UnknownWord",
                    "value": "redundancy"
                },
                "references": {
                    "sentences": [
                        "After creating persistent entries, deleting evidence of its activities, and decoding config.rar, the malware initializes a cyclic redundancy check (CRC) table followed by an unnamed semaphore using the sem_init API. This semaphore is initialized with apshared value set to 0, making the resultant semaphore shared between all the threads. The semaphore is used to maintain concurrency between threads accessing a shared object, such as kill_cfg data."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3ff27b2>",
                            "type": "UnknownWord",
                            "value": "redundancy"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x9fe4dc66>",
                    "type": "UnknownWord",
                    "value": "crc"
                },
                "references": {
                    "sentences": [
                        "Reads the content of the file /var/run/gcc.pid to get a unique 32-byte magic string that identifies the device while connecting with the C2 server; if the file doesnt exist, then it creates the file and updates it with a random 32-byte string.<crlf>Calculates the CRC header, including details of the device such as the magic string, OS release version, malware version, rootkit presence, memory stats, CPU information, and LAN speed.<crlf>Encrypts the data and sends it to the C2 server.<crlf>Waits to receive any of the following commands from the C2 server and then acts on the command using the exec_packet subroutine.",
                        "After creating persistent entries, deleting evidence of its activities, and decoding config.rar, the malware initializes a cyclic redundancy check (CRC) table followed by an unnamed semaphore using the sem_init API. This semaphore is initialized with apshared value set to 0, making the resultant semaphore shared between all the threads. The semaphore is used to maintain concurrency between threads accessing a shared object, such as kill_cfg data."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x9fe4dc66>",
                            "type": "UnknownWord",
                            "value": "crc"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3293ee27>",
                    "type": "UnknownWord",
                    "value": "semaphore"
                },
                "references": {
                    "sentences": [
                        "Figure 15. Semaphore and malicious thread initialization",
                        "After creating persistent entries, deleting evidence of its activities, and decoding config.rar, the malware initializes a cyclic redundancy check (CRC) table followed by an unnamed semaphore using the sem_init API. This semaphore is initialized with apshared value set to 0, making the resultant semaphore shared between all the threads. The semaphore is used to maintain concurrency between threads accessing a shared object, such as kill_cfg data."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3293ee27>",
                            "type": "UnknownWord",
                            "value": "semaphore"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc69a003c>",
                    "type": "UnknownWord",
                    "value": "sem_init"
                },
                "references": {
                    "sentences": [
                        "After creating persistent entries, deleting evidence of its activities, and decoding config.rar, the malware initializes a cyclic redundancy check (CRC) table followed by an unnamed semaphore using the sem_init API. This semaphore is initialized with apshared value set to 0, making the resultant semaphore shared between all the threads. The semaphore is used to maintain concurrency between threads accessing a shared object, such as kill_cfg data."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xc69a003c>",
                            "type": "UnknownWord",
                            "value": "sem_init"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7242b74b>",
                    "type": "UnknownWord",
                    "value": "initialized"
                },
                "references": {
                    "sentences": [
                        "After creating persistent entries, deleting evidence of its activities, and decoding config.rar, the malware initializes a cyclic redundancy check (CRC) table followed by an unnamed semaphore using the sem_init API. This semaphore is initialized with apshared value set to 0, making the resultant semaphore shared between all the threads. The semaphore is used to maintain concurrency between threads accessing a shared object, such as kill_cfg data."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x64ce0e9e>",
                    "type": "UnknownWord",
                    "value": "apshared"
                },
                "references": {
                    "sentences": [
                        "After creating persistent entries, deleting evidence of its activities, and decoding config.rar, the malware initializes a cyclic redundancy check (CRC) table followed by an unnamed semaphore using the sem_init API. This semaphore is initialized with apshared value set to 0, making the resultant semaphore shared between all the threads. The semaphore is used to maintain concurrency between threads accessing a shared object, such as kill_cfg data."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd3460149>",
                    "type": "UnknownWord",
                    "value": "resultant"
                },
                "references": {
                    "sentences": [
                        "After creating persistent entries, deleting evidence of its activities, and decoding config.rar, the malware initializes a cyclic redundancy check (CRC) table followed by an unnamed semaphore using the sem_init API. This semaphore is initialized with apshared value set to 0, making the resultant semaphore shared between all the threads. The semaphore is used to maintain concurrency between threads accessing a shared object, such as kill_cfg data."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x67c50a2f>",
                    "type": "UnknownWord",
                    "value": "concurrency"
                },
                "references": {
                    "sentences": [
                        "After creating persistent entries, deleting evidence of its activities, and decoding config.rar, the malware initializes a cyclic redundancy check (CRC) table followed by an unnamed semaphore using the sem_init API. This semaphore is initialized with apshared value set to 0, making the resultant semaphore shared between all the threads. The semaphore is used to maintain concurrency between threads accessing a shared object, such as kill_cfg data."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x73a88e92>",
                    "type": "UnknownWord",
                    "value": "kill_cfg"
                },
                "references": {
                    "sentences": [
                        "The daemon_get_killed_processthread downloads the kill_cfg data from the remote URL decoded earlier (hxxp://aa[.]hostasa[.]org/config[.]rar) and decrypts it using the same XOR key previously mentioned. It then sleeps for 30 minutes.",
                        "Decodes encrypted stringsFetches file stats for /var/run/gcc.pid or, if none exist, then creates the fileFetches file stats for /lib/libudev.so or, if none exist, then creates the directory /lib and creates a copy of itself at the location /lib/libudev.soFetches the on disk file information associated with the current process; if it fails, then exits the loop and stops the current processReads the content from kill_cfg and performs the corresponding actions, like stopping the process or deleting files, based on the matching specified keys in the configuration file, such as:md5=<crlf>filename=<crlf>rmfile=<crlf>denyip=",
                        "After creating persistent entries, deleting evidence of its activities, and decoding config.rar, the malware initializes a cyclic redundancy check (CRC) table followed by an unnamed semaphore using the sem_init API. This semaphore is initialized with apshared value set to 0, making the resultant semaphore shared between all the threads. The semaphore is used to maintain concurrency between threads accessing a shared object, such as kill_cfg data.",
                        "Figure 17. daemon_get_killed_process thread function fetches and decodes the kill_cfg data from the remote URL",
                        "The malware then initializes three threads to perform malicious activities, such as stopping a process, creating a TCP connection, and retrieving kill_cfg data."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<URL_0x78e18023>",
                            "type": "Url",
                            "value": "http://aa.hostasa.org/config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x73a88e92>",
                            "type": "UnknownWord",
                            "value": "kill_cfg"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x92126161>",
                    "type": "UnknownWord",
                    "value": "kill_process"
                },
                "references": {
                    "sentences": [
                        "kill_process",
                        "The kill_process thread performs the following tasks:"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbf920a73>",
                    "type": "UnknownWord",
                    "value": "stringsfetches"
                },
                "references": {
                    "sentences": [
                        "Decodes encrypted stringsFetches file stats for /var/run/gcc.pid or, if none exist, then creates the fileFetches file stats for /lib/libudev.so or, if none exist, then creates the directory /lib and creates a copy of itself at the location /lib/libudev.soFetches the on disk file information associated with the current process; if it fails, then exits the loop and stops the current processReads the content from kill_cfg and performs the corresponding actions, like stopping the process or deleting files, based on the matching specified keys in the configuration file, such as:md5=<crlf>filename=<crlf>rmfile=<crlf>denyip="
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xed28c8d1>",
                    "type": "UnknownWord",
                    "value": "stats"
                },
                "references": {
                    "sentences": [
                        "Reads the content of the file /var/run/gcc.pid to get a unique 32-byte magic string that identifies the device while connecting with the C2 server; if the file doesnt exist, then it creates the file and updates it with a random 32-byte string.<crlf>Calculates the CRC header, including details of the device such as the magic string, OS release version, malware version, rootkit presence, memory stats, CPU information, and LAN speed.<crlf>Encrypts the data and sends it to the C2 server.<crlf>Waits to receive any of the following commands from the C2 server and then acts on the command using the exec_packet subroutine.",
                        "Decodes encrypted stringsFetches file stats for /var/run/gcc.pid or, if none exist, then creates the fileFetches file stats for /lib/libudev.so or, if none exist, then creates the directory /lib and creates a copy of itself at the location /lib/libudev.soFetches the on disk file information associated with the current process; if it fails, then exits the loop and stops the current processReads the content from kill_cfg and performs the corresponding actions, like stopping the process or deleting files, based on the matching specified keys in the configuration file, such as:md5=<crlf>filename=<crlf>rmfile=<crlf>denyip="
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x20e65324>",
                    "type": "UnknownWord",
                    "value": "filefetches"
                },
                "references": {
                    "sentences": [
                        "Decodes encrypted stringsFetches file stats for /var/run/gcc.pid or, if none exist, then creates the fileFetches file stats for /lib/libudev.so or, if none exist, then creates the directory /lib and creates a copy of itself at the location /lib/libudev.soFetches the on disk file information associated with the current process; if it fails, then exits the loop and stops the current processReads the content from kill_cfg and performs the corresponding actions, like stopping the process or deleting files, based on the matching specified keys in the configuration file, such as:md5=<crlf>filename=<crlf>rmfile=<crlf>denyip="
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8f82c444>",
                    "type": "UnknownWord",
                    "value": "sofetches"
                },
                "references": {
                    "sentences": [
                        "Decodes encrypted stringsFetches file stats for /var/run/gcc.pid or, if none exist, then creates the fileFetches file stats for /lib/libudev.so or, if none exist, then creates the directory /lib and creates a copy of itself at the location /lib/libudev.soFetches the on disk file information associated with the current process; if it fails, then exits the loop and stops the current processReads the content from kill_cfg and performs the corresponding actions, like stopping the process or deleting files, based on the matching specified keys in the configuration file, such as:md5=<crlf>filename=<crlf>rmfile=<crlf>denyip="
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdc85a3cc>",
                    "type": "UnknownWord",
                    "value": "processreads"
                },
                "references": {
                    "sentences": [
                        "Decodes encrypted stringsFetches file stats for /var/run/gcc.pid or, if none exist, then creates the fileFetches file stats for /lib/libudev.so or, if none exist, then creates the directory /lib and creates a copy of itself at the location /lib/libudev.soFetches the on disk file information associated with the current process; if it fails, then exits the loop and stops the current processReads the content from kill_cfg and performs the corresponding actions, like stopping the process or deleting files, based on the matching specified keys in the configuration file, such as:md5=<crlf>filename=<crlf>rmfile=<crlf>denyip="
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcea46709>",
                    "type": "UnknownWord",
                    "value": "rmfile"
                },
                "references": {
                    "sentences": [
                        "Decodes encrypted stringsFetches file stats for /var/run/gcc.pid or, if none exist, then creates the fileFetches file stats for /lib/libudev.so or, if none exist, then creates the directory /lib and creates a copy of itself at the location /lib/libudev.soFetches the on disk file information associated with the current process; if it fails, then exits the loop and stops the current processReads the content from kill_cfg and performs the corresponding actions, like stopping the process or deleting files, based on the matching specified keys in the configuration file, such as:md5=<crlf>filename=<crlf>rmfile=<crlf>denyip="
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x88dcbb5c>",
                    "type": "UnknownWord",
                    "value": "denyip"
                },
                "references": {
                    "sentences": [
                        "Decodes encrypted stringsFetches file stats for /var/run/gcc.pid or, if none exist, then creates the fileFetches file stats for /lib/libudev.so or, if none exist, then creates the directory /lib and creates a copy of itself at the location /lib/libudev.soFetches the on disk file information associated with the current process; if it fails, then exits the loop and stops the current processReads the content from kill_cfg and performs the corresponding actions, like stopping the process or deleting files, based on the matching specified keys in the configuration file, such as:md5=<crlf>filename=<crlf>rmfile=<crlf>denyip="
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x52c580f3>",
                    "type": "UnknownWord",
                    "value": "tcp_thread"
                },
                "references": {
                    "sentences": [
                        "The tcp_thread triggers the connection with the C2 server decoded earlier using decrypt_remotestr(). It performs the following tasks:",
                        "tcp_thread"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x187044d9>",
                    "type": "UnknownWord",
                    "value": "calculates"
                },
                "references": {
                    "sentences": [
                        "Reads the content of the file /var/run/gcc.pid to get a unique 32-byte magic string that identifies the device while connecting with the C2 server; if the file doesnt exist, then it creates the file and updates it with a random 32-byte string.<crlf>Calculates the CRC header, including details of the device such as the magic string, OS release version, malware version, rootkit presence, memory stats, CPU information, and LAN speed.<crlf>Encrypts the data and sends it to the C2 server.<crlf>Waits to receive any of the following commands from the C2 server and then acts on the command using the exec_packet subroutine."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7d21e2eb>",
                    "type": "UnknownWord",
                    "value": "lan"
                },
                "references": {
                    "sentences": [
                        "Reads the content of the file /var/run/gcc.pid to get a unique 32-byte magic string that identifies the device while connecting with the C2 server; if the file doesnt exist, then it creates the file and updates it with a random 32-byte string.<crlf>Calculates the CRC header, including details of the device such as the magic string, OS release version, malware version, rootkit presence, memory stats, CPU information, and LAN speed.<crlf>Encrypts the data and sends it to the C2 server.<crlf>Waits to receive any of the following commands from the C2 server and then acts on the command using the exec_packet subroutine."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd0c3a682>",
                    "type": "UnknownWord",
                    "value": "exec_packet"
                },
                "references": {
                    "sentences": [
                        "Reads the content of the file /var/run/gcc.pid to get a unique 32-byte magic string that identifies the device while connecting with the C2 server; if the file doesnt exist, then it creates the file and updates it with a random 32-byte string.<crlf>Calculates the CRC header, including details of the device such as the magic string, OS release version, malware version, rootkit presence, memory stats, CPU information, and LAN speed.<crlf>Encrypts the data and sends it to the C2 server.<crlf>Waits to receive any of the following commands from the C2 server and then acts on the command using the exec_packet subroutine."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x68cfc00f>",
                    "type": "UnknownWord",
                    "value": "daemon_get_killed_process"
                },
                "references": {
                    "sentences": [
                        "Figure 17. daemon_get_killed_process thread function fetches and decodes the kill_cfg data from the remote URL",
                        "daemon_get_killed_process"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8b8bd435>",
                    "type": "UnknownWord",
                    "value": "daemon_get_killed_processthread"
                },
                "references": {
                    "sentences": [
                        "The daemon_get_killed_processthread downloads the kill_cfg data from the remote URL decoded earlier (hxxp://aa[.]hostasa[.]org/config[.]rar) and decrypts it using the same XOR key previously mentioned. It then sleeps for 30 minutes."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<URL_0x78e18023>",
                            "type": "Url",
                            "value": "http://aa.hostasa.org/config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8b8bd435>",
                            "type": "UnknownWord",
                            "value": "daemon_get_killed_processthread"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x33512ba9>",
                    "type": "UnknownWord",
                    "value": "sysconf"
                },
                "references": {
                    "sentences": [
                        "The malware calls sysconf(_SC_NPROCESSORS_CONF) to fetch the number of processors in the device. It then creates threads with twice the number of processors found on the device."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb251b047>",
                    "type": "UnknownWord",
                    "value": "_sc_nprocessors_conf"
                },
                "references": {
                    "sentences": [
                        "The malware calls sysconf(_SC_NPROCESSORS_CONF) to fetch the number of processors in the device. It then creates threads with twice the number of processors found on the device."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x185a3476>",
                    "type": "UnknownWord",
                    "value": "invoking"
                },
                "references": {
                    "sentences": [
                        "The content of libudev.so was collected into libudev.so.6<crlf>bash process performed System Information Discovery by invoking ifconfig<crlf>gcc.sh was executed after being dropped by HFLgGwYfSC.elf<crlf>A shell command was executed by crond<crlf>SUID/SGID process unix_chkpwd executed",
                        "Invoking each thread internally calls the thread routine threadwork. Using the global variable g_stop and commands received from the C2 server, threadwork then sends crafted packets 65,535 times to perform a DDoS attack."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x23ce6d7c>",
                    "type": "UnknownWord",
                    "value": "threadwork"
                },
                "references": {
                    "sentences": [
                        "Invoking each thread internally calls the thread routine threadwork. Using the global variable g_stop and commands received from the C2 server, threadwork then sends crafted packets 65,535 times to perform a DDoS attack."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd9d64de5>",
                    "type": "UnknownWord",
                    "value": "g_stop"
                },
                "references": {
                    "sentences": [
                        "Invoking each thread internally calls the thread routine threadwork. Using the global variable g_stop and commands received from the C2 server, threadwork then sends crafted packets 65,535 times to perform a DDoS attack."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x20eac208>",
                    "type": "UnknownWord",
                    "value": "fix_syn"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x22ad8e17>",
                    "type": "UnknownWord",
                    "value": "syn"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2012a22a>",
                    "type": "UnknownWord",
                    "value": "fix_dns"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xda6812f2>",
                    "type": "UnknownWord",
                    "value": "fix_ack"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x161da0b2>",
                    "type": "UnknownWord",
                    "value": "ack"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8cecb4a6>",
                    "type": "UnknownWord",
                    "value": "emphasize"
                },
                "references": {
                    "sentences": [
                        "XorDdos and other threats targeting Linux devices emphasize how crucial it is to have security solutions with comprehensive capabilities and complete visibility spanning numerous distributions of Linux operating systems. Microsoft Defender for Endpoint offers such visibility and protection to catch these emerging threats with its next-generation antimalware and endpoint detection and response (EDR) capabilities. Leveraging threat intelligence from integrated threat data, including client and cloud heuristics, machine learning models, memory scanning, and behavioral monitoring, Microsoft Defender for Endpoint can detect and remediate XorDdos and its multi-stage, modular attacks. This includes detecting and protecting against its use of a malicious shell script for initial access, its drop-and-execution of binaries from a world-writable location, and any potential follow-on activities on endpoints."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x27310be>",
                    "type": "UnknownWord",
                    "value": "antimalware"
                },
                "references": {
                    "sentences": [
                        "XorDdos and other threats targeting Linux devices emphasize how crucial it is to have security solutions with comprehensive capabilities and complete visibility spanning numerous distributions of Linux operating systems. Microsoft Defender for Endpoint offers such visibility and protection to catch these emerging threats with its next-generation antimalware and endpoint detection and response (EDR) capabilities. Leveraging threat intelligence from integrated threat data, including client and cloud heuristics, machine learning models, memory scanning, and behavioral monitoring, Microsoft Defender for Endpoint can detect and remediate XorDdos and its multi-stage, modular attacks. This includes detecting and protecting against its use of a malicious shell script for initial access, its drop-and-execution of binaries from a world-writable location, and any potential follow-on activities on endpoints."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xcd163f3b>",
                    "type": "UnknownWord",
                    "value": "heuristics"
                },
                "references": {
                    "sentences": [
                        "XorDdos and other threats targeting Linux devices emphasize how crucial it is to have security solutions with comprehensive capabilities and complete visibility spanning numerous distributions of Linux operating systems. Microsoft Defender for Endpoint offers such visibility and protection to catch these emerging threats with its next-generation antimalware and endpoint detection and response (EDR) capabilities. Leveraging threat intelligence from integrated threat data, including client and cloud heuristics, machine learning models, memory scanning, and behavioral monitoring, Microsoft Defender for Endpoint can detect and remediate XorDdos and its multi-stage, modular attacks. This includes detecting and protecting against its use of a malicious shell script for initial access, its drop-and-execution of binaries from a world-writable location, and any potential follow-on activities on endpoints."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x69099010>",
                    "type": "UnknownWord",
                    "value": "drop-and-execution"
                },
                "references": {
                    "sentences": [
                        "XorDdos and other threats targeting Linux devices emphasize how crucial it is to have security solutions with comprehensive capabilities and complete visibility spanning numerous distributions of Linux operating systems. Microsoft Defender for Endpoint offers such visibility and protection to catch these emerging threats with its next-generation antimalware and endpoint detection and response (EDR) capabilities. Leveraging threat intelligence from integrated threat data, including client and cloud heuristics, machine learning models, memory scanning, and behavioral monitoring, Microsoft Defender for Endpoint can detect and remediate XorDdos and its multi-stage, modular attacks. This includes detecting and protecting against its use of a malicious shell script for initial access, its drop-and-execution of binaries from a world-writable location, and any potential follow-on activities on endpoints."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3cb76839>",
                    "type": "UnknownWord",
                    "value": "world-writable"
                },
                "references": {
                    "sentences": [
                        "Figure 19. Microsoft 365 Defender timeline displaying that HFLgGwYfSC.elf was run from a world-writable directory and the remediation of dropped binaries",
                        "XorDdos and other threats targeting Linux devices emphasize how crucial it is to have security solutions with comprehensive capabilities and complete visibility spanning numerous distributions of Linux operating systems. Microsoft Defender for Endpoint offers such visibility and protection to catch these emerging threats with its next-generation antimalware and endpoint detection and response (EDR) capabilities. Leveraging threat intelligence from integrated threat data, including client and cloud heuristics, machine learning models, memory scanning, and behavioral monitoring, Microsoft Defender for Endpoint can detect and remediate XorDdos and its multi-stage, modular attacks. This includes detecting and protecting against its use of a malicious shell script for initial access, its drop-and-execution of binaries from a world-writable location, and any potential follow-on activities on endpoints."
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x23485769>",
                            "type": "File",
                            "value": "hflggwyfsc.elf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3cb76839>",
                            "type": "UnknownWord",
                            "value": "world-writable"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf9e14cc8>",
                    "type": "UnknownWord",
                    "value": "edgeavailable"
                },
                "references": {
                    "sentences": [
                        "Encourage the use of Microsoft Edgeavailable on Linux and various platformsor other web browsers that support Microsoft Defender SmartScreen, which identifies and blocks malicious websites, including phishing sites, scam sites, and sites that contain exploits and host malware.<crlf>Use device discovery to find unmanaged Linux devices on your network and onboard them to Microsoft Defender for Endpoint.<crlf>Turn on cloud-delivered protection in Microsoft Defender Antivirus or the equivalent for your antivirus product to use cloud-based machine learning protections that can block a huge majority of new and unknown variants.<crlf>Run EDR in block mode so that Microsoft Defender for Endpoint can block malicious artifacts, even when your non-Microsoft antivirus doesnt detect the threat or when Microsoft Defender Antivirus is running in passive mode.<crlf>Enable network protection to prevent applications or users from accessing malicious domains and other malicious content on the internet.<crlf>Enable investigation and remediation in full automated mode to allow Microsoft Defender for Endpoint to take immediate action on alerts to resolve breaches, significantly reducing alert volume."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x31c3aab9>",
                    "type": "UnknownWord",
                    "value": "platformsor"
                },
                "references": {
                    "sentences": [
                        "Encourage the use of Microsoft Edgeavailable on Linux and various platformsor other web browsers that support Microsoft Defender SmartScreen, which identifies and blocks malicious websites, including phishing sites, scam sites, and sites that contain exploits and host malware.<crlf>Use device discovery to find unmanaged Linux devices on your network and onboard them to Microsoft Defender for Endpoint.<crlf>Turn on cloud-delivered protection in Microsoft Defender Antivirus or the equivalent for your antivirus product to use cloud-based machine learning protections that can block a huge majority of new and unknown variants.<crlf>Run EDR in block mode so that Microsoft Defender for Endpoint can block malicious artifacts, even when your non-Microsoft antivirus doesnt detect the threat or when Microsoft Defender Antivirus is running in passive mode.<crlf>Enable network protection to prevent applications or users from accessing malicious domains and other malicious content on the internet.<crlf>Enable investigation and remediation in full automated mode to allow Microsoft Defender for Endpoint to take immediate action on alerts to resolve breaches, significantly reducing alert volume."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3113186d>",
                    "type": "UnknownWord",
                    "value": "smartscreen"
                },
                "references": {
                    "sentences": [
                        "Encourage the use of Microsoft Edgeavailable on Linux and various platformsor other web browsers that support Microsoft Defender SmartScreen, which identifies and blocks malicious websites, including phishing sites, scam sites, and sites that contain exploits and host malware.<crlf>Use device discovery to find unmanaged Linux devices on your network and onboard them to Microsoft Defender for Endpoint.<crlf>Turn on cloud-delivered protection in Microsoft Defender Antivirus or the equivalent for your antivirus product to use cloud-based machine learning protections that can block a huge majority of new and unknown variants.<crlf>Run EDR in block mode so that Microsoft Defender for Endpoint can block malicious artifacts, even when your non-Microsoft antivirus doesnt detect the threat or when Microsoft Defender Antivirus is running in passive mode.<crlf>Enable network protection to prevent applications or users from accessing malicious domains and other malicious content on the internet.<crlf>Enable investigation and remediation in full automated mode to allow Microsoft Defender for Endpoint to take immediate action on alerts to resolve breaches, significantly reducing alert volume."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf8d432b6>",
                    "type": "UnknownWord",
                    "value": "unmanaged"
                },
                "references": {
                    "sentences": [
                        "Encourage the use of Microsoft Edgeavailable on Linux and various platformsor other web browsers that support Microsoft Defender SmartScreen, which identifies and blocks malicious websites, including phishing sites, scam sites, and sites that contain exploits and host malware.<crlf>Use device discovery to find unmanaged Linux devices on your network and onboard them to Microsoft Defender for Endpoint.<crlf>Turn on cloud-delivered protection in Microsoft Defender Antivirus or the equivalent for your antivirus product to use cloud-based machine learning protections that can block a huge majority of new and unknown variants.<crlf>Run EDR in block mode so that Microsoft Defender for Endpoint can block malicious artifacts, even when your non-Microsoft antivirus doesnt detect the threat or when Microsoft Defender Antivirus is running in passive mode.<crlf>Enable network protection to prevent applications or users from accessing malicious domains and other malicious content on the internet.<crlf>Enable investigation and remediation in full automated mode to allow Microsoft Defender for Endpoint to take immediate action on alerts to resolve breaches, significantly reducing alert volume."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe6cf1d9d>",
                    "type": "UnknownWord",
                    "value": "onboard"
                },
                "references": {
                    "sentences": [
                        "Encourage the use of Microsoft Edgeavailable on Linux and various platformsor other web browsers that support Microsoft Defender SmartScreen, which identifies and blocks malicious websites, including phishing sites, scam sites, and sites that contain exploits and host malware.<crlf>Use device discovery to find unmanaged Linux devices on your network and onboard them to Microsoft Defender for Endpoint.<crlf>Turn on cloud-delivered protection in Microsoft Defender Antivirus or the equivalent for your antivirus product to use cloud-based machine learning protections that can block a huge majority of new and unknown variants.<crlf>Run EDR in block mode so that Microsoft Defender for Endpoint can block malicious artifacts, even when your non-Microsoft antivirus doesnt detect the threat or when Microsoft Defender Antivirus is running in passive mode.<crlf>Enable network protection to prevent applications or users from accessing malicious domains and other malicious content on the internet.<crlf>Enable investigation and remediation in full automated mode to allow Microsoft Defender for Endpoint to take immediate action on alerts to resolve breaches, significantly reducing alert volume."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf0638ce5>",
                    "type": "UnknownWord",
                    "value": "cloud-based"
                },
                "references": {
                    "sentences": [
                        "Encourage the use of Microsoft Edgeavailable on Linux and various platformsor other web browsers that support Microsoft Defender SmartScreen, which identifies and blocks malicious websites, including phishing sites, scam sites, and sites that contain exploits and host malware.<crlf>Use device discovery to find unmanaged Linux devices on your network and onboard them to Microsoft Defender for Endpoint.<crlf>Turn on cloud-delivered protection in Microsoft Defender Antivirus or the equivalent for your antivirus product to use cloud-based machine learning protections that can block a huge majority of new and unknown variants.<crlf>Run EDR in block mode so that Microsoft Defender for Endpoint can block malicious artifacts, even when your non-Microsoft antivirus doesnt detect the threat or when Microsoft Defender Antivirus is running in passive mode.<crlf>Enable network protection to prevent applications or users from accessing malicious domains and other malicious content on the internet.<crlf>Enable investigation and remediation in full automated mode to allow Microsoft Defender for Endpoint to take immediate action on alerts to resolve breaches, significantly reducing alert volume."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xede5665>",
                    "type": "UnknownWord",
                    "value": "non-microsoft"
                },
                "references": {
                    "sentences": [
                        "Encourage the use of Microsoft Edgeavailable on Linux and various platformsor other web browsers that support Microsoft Defender SmartScreen, which identifies and blocks malicious websites, including phishing sites, scam sites, and sites that contain exploits and host malware.<crlf>Use device discovery to find unmanaged Linux devices on your network and onboard them to Microsoft Defender for Endpoint.<crlf>Turn on cloud-delivered protection in Microsoft Defender Antivirus or the equivalent for your antivirus product to use cloud-based machine learning protections that can block a huge majority of new and unknown variants.<crlf>Run EDR in block mode so that Microsoft Defender for Endpoint can block malicious artifacts, even when your non-Microsoft antivirus doesnt detect the threat or when Microsoft Defender Antivirus is running in passive mode.<crlf>Enable network protection to prevent applications or users from accessing malicious domains and other malicious content on the internet.<crlf>Enable investigation and remediation in full automated mode to allow Microsoft Defender for Endpoint to take immediate action on alerts to resolve breaches, significantly reducing alert volume."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xb7bb054f>",
                    "type": "UnknownWord",
                    "value": "passive"
                },
                "references": {
                    "sentences": [
                        "Encourage the use of Microsoft Edgeavailable on Linux and various platformsor other web browsers that support Microsoft Defender SmartScreen, which identifies and blocks malicious websites, including phishing sites, scam sites, and sites that contain exploits and host malware.<crlf>Use device discovery to find unmanaged Linux devices on your network and onboard them to Microsoft Defender for Endpoint.<crlf>Turn on cloud-delivered protection in Microsoft Defender Antivirus or the equivalent for your antivirus product to use cloud-based machine learning protections that can block a huge majority of new and unknown variants.<crlf>Run EDR in block mode so that Microsoft Defender for Endpoint can block malicious artifacts, even when your non-Microsoft antivirus doesnt detect the threat or when Microsoft Defender Antivirus is running in passive mode.<crlf>Enable network protection to prevent applications or users from accessing malicious domains and other malicious content on the internet.<crlf>Enable investigation and remediation in full automated mode to allow Microsoft Defender for Endpoint to take immediate action on alerts to resolve breaches, significantly reducing alert volume."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6685c780>",
                    "type": "UnknownWord",
                    "value": "reducing"
                },
                "references": {
                    "sentences": [
                        "Encourage the use of Microsoft Edgeavailable on Linux and various platformsor other web browsers that support Microsoft Defender SmartScreen, which identifies and blocks malicious websites, including phishing sites, scam sites, and sites that contain exploits and host malware.<crlf>Use device discovery to find unmanaged Linux devices on your network and onboard them to Microsoft Defender for Endpoint.<crlf>Turn on cloud-delivered protection in Microsoft Defender Antivirus or the equivalent for your antivirus product to use cloud-based machine learning protections that can block a huge majority of new and unknown variants.<crlf>Run EDR in block mode so that Microsoft Defender for Endpoint can block malicious artifacts, even when your non-Microsoft antivirus doesnt detect the threat or when Microsoft Defender Antivirus is running in passive mode.<crlf>Enable network protection to prevent applications or users from accessing malicious domains and other malicious content on the internet.<crlf>Enable investigation and remediation in full automated mode to allow Microsoft Defender for Endpoint to take immediate action on alerts to resolve breaches, significantly reducing alert volume."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x941e9416>",
                    "type": "UnknownWord",
                    "value": "grow"
                },
                "references": {
                    "sentences": [
                        "As threats across all platforms continue to grow in number and sophistication, security solutions must be capable of providing advanced protection on a wide range of devices, regardless of the operating system in use. Organizations will continue to face threats from a variety of entry points across devices, so Microsoft continues to heavily invest in protecting all the major platforms and providing extensive capabilities that organizations needed to protect their networks and systems."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x6a591f51>",
                    "type": "UnknownWord",
                    "value": "dos"
                },
                "references": {
                    "sentences": [
                        "DoS:Linux/Xorddos.A<crlf>DoS:Linux/Xorddos!rfn<crlf>Trojan:Linux/Xorddos<crlf>Trojan:Linux/Xorddos.AA<crlf>Trojan:Linux/Xorddos!rfn<crlf>Behavior:Linux/Xorddos.A"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x702e7930>",
                    "type": "UnknownWord",
                    "value": "rfn"
                },
                "references": {
                    "sentences": [
                        "DoS:Linux/Xorddos.A<crlf>DoS:Linux/Xorddos!rfn<crlf>Trojan:Linux/Xorddos<crlf>Trojan:Linux/Xorddos.AA<crlf>Trojan:Linux/Xorddos!rfn<crlf>Behavior:Linux/Xorddos.A"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xf542aa3a>",
                    "type": "UnknownWord",
                    "value": "raises"
                },
                "references": {
                    "sentences": [
                        "When XorDdos is detected on a device, Microsoft 365 Defender raises an alert, which shows the complete attack chain, including the process tree, file information, user information, and prevention details."
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa1646ff5>",
                    "type": "UnknownWord",
                    "value": "displaying"
                },
                "references": {
                    "sentences": [
                        "Figure 19. Microsoft 365 Defender timeline displaying that HFLgGwYfSC.elf was run from a world-writable directory and the remediation of dropped binaries"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x23485769>",
                            "type": "File",
                            "value": "hflggwyfsc.elf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa1646ff5>",
                            "type": "UnknownWord",
                            "value": "displaying"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xec447684>",
                    "type": "UnknownWord",
                    "value": "libudev"
                },
                "references": {
                    "sentences": [
                        "The content of libudev.so was collected into libudev.so.6<crlf>bash process performed System Information Discovery by invoking ifconfig<crlf>gcc.sh was executed after being dropped by HFLgGwYfSC.elf<crlf>A shell command was executed by crond<crlf>SUID/SGID process unix_chkpwd executed"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1c1586af>",
                    "type": "UnknownWord",
                    "value": "crond"
                },
                "references": {
                    "sentences": [
                        "The content of libudev.so was collected into libudev.so.6<crlf>bash process performed System Information Discovery by invoking ifconfig<crlf>gcc.sh was executed after being dropped by HFLgGwYfSC.elf<crlf>A shell command was executed by crond<crlf>SUID/SGID process unix_chkpwd executed",
                        "Figure 20. Microsoft 365 Defender timeline with an event on a suspicious shell command run by crond after it was dropped from HFLgGwYfSC.elf"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x23485769>",
                            "type": "File",
                            "value": "hflggwyfsc.elf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x1c1586af>",
                            "type": "UnknownWord",
                            "value": "crond"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1b7f046b>",
                    "type": "UnknownWord",
                    "value": "suid"
                },
                "references": {
                    "sentences": [
                        "The content of libudev.so was collected into libudev.so.6<crlf>bash process performed System Information Discovery by invoking ifconfig<crlf>gcc.sh was executed after being dropped by HFLgGwYfSC.elf<crlf>A shell command was executed by crond<crlf>SUID/SGID process unix_chkpwd executed"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe5e95e8a>",
                    "type": "UnknownWord",
                    "value": "sgid"
                },
                "references": {
                    "sentences": [
                        "The content of libudev.so was collected into libudev.so.6<crlf>bash process performed System Information Discovery by invoking ifconfig<crlf>gcc.sh was executed after being dropped by HFLgGwYfSC.elf<crlf>A shell command was executed by crond<crlf>SUID/SGID process unix_chkpwd executed"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xe62a62f4>",
                    "type": "UnknownWord",
                    "value": "unix_chkpwd"
                },
                "references": {
                    "sentences": [
                        "The content of libudev.so was collected into libudev.so.6<crlf>bash process performed System Information Discovery by invoking ifconfig<crlf>gcc.sh was executed after being dropped by HFLgGwYfSC.elf<crlf>A shell command was executed by crond<crlf>SUID/SGID process unix_chkpwd executed"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa4b802e9>",
                    "type": "UnknownWord",
                    "value": "devicelogonevents"
                },
                "references": {
                    "sentences": [
                        "DeviceLogonEvents<crlf>| where InitiatingProcessFileName == \"sshd\"<crlf>and ActionType == \"LogonFailed\"<crlf>| summarize count() by dayOfYear = datetime_part(\"dayOfYear\", Timestamp)<crlf>| sort by dayOfYear<crlf>| render linechart"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1ec0f006>",
                    "type": "UnknownWord",
                    "value": "initiatingprocessfilename"
                },
                "references": {
                    "sentences": [
                        "DeviceLogonEvents<crlf>| where InitiatingProcessFileName == \"sshd\"<crlf>and ActionType == \"LogonFailed\"<crlf>| summarize count() by dayOfYear = datetime_part(\"dayOfYear\", Timestamp)<crlf>| sort by dayOfYear<crlf>| render linechart"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x1ef201>",
                    "type": "UnknownWord",
                    "value": "sshd"
                },
                "references": {
                    "sentences": [
                        "DeviceLogonEvents<crlf>| where InitiatingProcessFileName == \"sshd\"<crlf>and ActionType == \"LogonFailed\"<crlf>| summarize count() by dayOfYear = datetime_part(\"dayOfYear\", Timestamp)<crlf>| sort by dayOfYear<crlf>| render linechart"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x41155cca>",
                    "type": "UnknownWord",
                    "value": "actiontype"
                },
                "references": {
                    "sentences": [
                        "DeviceLogonEvents<crlf>| where InitiatingProcessFileName == \"sshd\"<crlf>and ActionType == \"LogonFailed\"<crlf>| summarize count() by dayOfYear = datetime_part(\"dayOfYear\", Timestamp)<crlf>| sort by dayOfYear<crlf>| render linechart"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xed6eeb69>",
                    "type": "UnknownWord",
                    "value": "logonfailed"
                },
                "references": {
                    "sentences": [
                        "DeviceLogonEvents<crlf>| where InitiatingProcessFileName == \"sshd\"<crlf>and ActionType == \"LogonFailed\"<crlf>| summarize count() by dayOfYear = datetime_part(\"dayOfYear\", Timestamp)<crlf>| sort by dayOfYear<crlf>| render linechart"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7b8a538a>",
                    "type": "UnknownWord",
                    "value": "dayofyear"
                },
                "references": {
                    "sentences": [
                        "DeviceLogonEvents<crlf>| where InitiatingProcessFileName == \"sshd\"<crlf>and ActionType == \"LogonFailed\"<crlf>| summarize count() by dayOfYear = datetime_part(\"dayOfYear\", Timestamp)<crlf>| sort by dayOfYear<crlf>| render linechart"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd2042693>",
                    "type": "UnknownWord",
                    "value": "datetime_part"
                },
                "references": {
                    "sentences": [
                        "DeviceLogonEvents<crlf>| where InitiatingProcessFileName == \"sshd\"<crlf>and ActionType == \"LogonFailed\"<crlf>| summarize count() by dayOfYear = datetime_part(\"dayOfYear\", Timestamp)<crlf>| sort by dayOfYear<crlf>| render linechart"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7deab7cb>",
                    "type": "UnknownWord",
                    "value": "sort"
                },
                "references": {
                    "sentences": [
                        "DeviceLogonEvents<crlf>| where InitiatingProcessFileName == \"sshd\"<crlf>and ActionType == \"LogonFailed\"<crlf>| summarize count() by dayOfYear = datetime_part(\"dayOfYear\", Timestamp)<crlf>| sort by dayOfYear<crlf>| render linechart"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5b1a10de>",
                    "type": "UnknownWord",
                    "value": "linechart"
                },
                "references": {
                    "sentences": [
                        "DeviceLogonEvents<crlf>| where InitiatingProcessFileName == \"sshd\"<crlf>and ActionType == \"LogonFailed\"<crlf>| summarize count() by dayOfYear = datetime_part(\"dayOfYear\", Timestamp)<crlf>| sort by dayOfYear<crlf>| render linechart"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x62026fe6>",
                    "type": "UnknownWord",
                    "value": "xorddos-specific"
                },
                "references": {
                    "sentences": [
                        "Creation of the XorDdos-specific dropped files"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x40d3bd53>",
                    "type": "UnknownWord",
                    "value": "devicefileevents"
                },
                "references": {
                    "sentences": [
                        "DeviceFileEvents<crlf>| extend FullPath=strcat(FolderPath, FileName)<crlf>| where FullPath in (\"/etc/cron.hourly/gcc.sh\", \"/lib/libudev.so.6\", \"/lib/libudev.so\", \"/var/run/gcc.pid\")"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xdd2cedb4>",
                    "type": "UnknownWord",
                    "value": "fullpath"
                },
                "references": {
                    "sentences": [
                        "DeviceFileEvents<crlf>| extend FullPath=strcat(FolderPath, FileName)<crlf>| where FullPath in (\"/etc/cron.hourly/gcc.sh\", \"/lib/libudev.so.6\", \"/lib/libudev.so\", \"/var/run/gcc.pid\")"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd9499c8b>",
                    "type": "UnknownWord",
                    "value": "strcat"
                },
                "references": {
                    "sentences": [
                        "DeviceFileEvents<crlf>| extend FullPath=strcat(FolderPath, FileName)<crlf>| where FullPath in (\"/etc/cron.hourly/gcc.sh\", \"/lib/libudev.so.6\", \"/lib/libudev.so\", \"/var/run/gcc.pid\")"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xd0ad045a>",
                    "type": "UnknownWord",
                    "value": "deviceprocessevents"
                },
                "references": {
                    "sentences": [
                        "DeviceProcessEvents<crlf>| where ProcessCommandLine contains \"cat resolv.conf\""
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xbbe44895>",
                    "type": "UnknownWord",
                    "value": "processcommandline"
                },
                "references": {
                    "sentences": [
                        "DeviceProcessEvents<crlf>| where ProcessCommandLine contains \"cat resolv.conf\""
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbbe44895>",
                            "type": "UnknownWord",
                            "value": "processcommandline"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x86da866c>",
                    "type": "UnknownWord",
                    "value": "classification"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8ddcd994>",
                    "type": "UnknownWord",
                    "value": "sysv"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x2d8113e7>",
                    "type": "UnknownWord",
                    "value": "gnu"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x878437ca>",
                    "type": "UnknownWord",
                    "value": "djtctpzfdq"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x235e860>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "53f062a93cf19aeaa2f8481b32118a31b658a126624abb8a7d82237884f0a394"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x878437ca>",
                            "type": "UnknownWord",
                            "value": "djtctpzfdq"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x3992499e>",
                    "type": "UnknownWord",
                    "value": "dmpyuitfoq"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xc84f7c79>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "798577202477c0c233d4af51c4d8fb2f574ddb3c9d1d90325d359a84cb1bd51c"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x3992499e>",
                            "type": "UnknownWord",
                            "value": "dmpyuitfoq"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x90dc2b31>",
                    "type": "UnknownWord",
                    "value": "fdinprytpq"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x3610f5de>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "2b4500987d50a24ba5c118f506f2507362d6b5c63c80b1984b4ae86641779ff3"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x90dc2b31>",
                            "type": "UnknownWord",
                            "value": "fdinprytpq"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x7ee7cd76>",
                    "type": "UnknownWord",
                    "value": "bin kagbjahdic"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xd685405a>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "e6c7eee304dfc29b19012ef6d31848c0b5bb07362691e4e9633c8581f1c2d65b"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x7ee7cd76>",
                            "type": "UnknownWord",
                            "value": "bin kagbjahdic"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x8149d1b0>",
                    "type": "UnknownWord",
                    "value": "kkldnszwvq"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xe00d8c4>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "ef0a4c12d98dc0ad4db86aadd641389c7219f57f15642ed35b4443daf3ff8c1e"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x8149d1b0>",
                            "type": "UnknownWord",
                            "value": "kkldnszwvq"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa237fe76>",
                    "type": "UnknownWord",
                    "value": "bin kndmhuqmah"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xc8b7ae0c>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "b5fba27a8e457c1ab6573c378171f057d151dc615d6a8d339195716fa9ac277a"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa237fe76>",
                            "type": "UnknownWord",
                            "value": "bin kndmhuqmah"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa63218a2>",
                    "type": "UnknownWord",
                    "value": "qkxqoelrfa"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x3dca1e53>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "d71ea3b98286d39a711b626f687f0d3fc852c3e3a05de3f51450fb8f7bd2b0d7"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xa63218a2>",
                            "type": "UnknownWord",
                            "value": "qkxqoelrfa"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x70222711>",
                    "type": "UnknownWord",
                    "value": "sykhrxsazz"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0x4ab535f0>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "9d6f115f31ee71089cc85b18852974e349c68fad3276145dafd0076951f32489"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x70222711>",
                            "type": "UnknownWord",
                            "value": "sykhrxsazz"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x5684c029>",
                    "type": "UnknownWord",
                    "value": "tcnszvmpqn"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xd1a508ed>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "360a6258dd66a3ba595a93896d9b55d22406d02e5c02100e5a18382c54e7d5cd"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x5684c029>",
                            "type": "UnknownWord",
                            "value": "tcnszvmpqn"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x49484bbc>",
                    "type": "UnknownWord",
                    "value": "bin zalkpggsgh"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xb15ba76>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "dc2b1cee161ebe90be68561755d99e66f454ad80b27cebe3d4773518ac45cbb7"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x49484bbc>",
                            "type": "UnknownWord",
                            "value": "bin zalkpggsgh"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x39e1865a>",
                    "type": "UnknownWord",
                    "value": "bin zvcarxfquk"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xe7de3a04>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "175667933088fbebcb62c8450993422ccc876495299173c646779a9e67501ff4"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x39e1865a>",
                            "type": "UnknownWord",
                            "value": "bin zvcarxfquk"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x230cac2f>",
                    "type": "UnknownWord",
                    "value": "bin 3200"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<SHA256_0xe528394f>",
                            "type": "Hash",
                            "hash_type": "SHA256",
                            "value": "c8f761d3ef7cd16ebe41042a0daf901c2fdffce96c8e9e1fa0d422c6e31332ea"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x230cac2f>",
                            "type": "UnknownWord",
                            "value": "bin 3200"
                        }
                    }
                ]
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xc48920b>",
                    "type": "UnknownWord",
                    "value": "pandey yevgeny kulakov"
                },
                "references": {
                    "sentences": [
                        "Ratnesh Pandey, Yevgeny Kulakov, and Jonathan Bar Or<crlf>Microsoft 365 Defender Research Team"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0x64d31321>",
                    "type": "UnknownWord",
                    "value": "jonathan"
                },
                "references": {
                    "sentences": [
                        "Ratnesh Pandey, Yevgeny Kulakov, and Jonathan Bar Or<crlf>Microsoft 365 Defender Research Team"
                    ],
                    "titles": []
                }
            },
            {
                "token": {
                    "id": "<UNKNOWNWORD_0xa573c9c0>",
                    "type": "UnknownWord",
                    "value": "bar"
                },
                "references": {
                    "sentences": [
                        "Ratnesh Pandey, Yevgeny Kulakov, and Jonathan Bar Or<crlf>Microsoft 365 Defender Research Team"
                    ],
                    "titles": []
                }
            }
        ]
    },
    "other_links": [],
    "info": {
        "potential_threats": {
            "<UNKNOWNWORD_0x3a6ede7a>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x3a6ede7a>",
                    "type": "UnknownWord",
                    "value": "xor-based"
                },
                "references": {
                    "sentences": [
                        "In the last six months, we observed a 254% increase in activity from a Linux trojan called XorDdos. First discovered in 2014 by the research group MalwareMustDie, XorDdos was named after its denial-of-service-related activities on Linux endpoints and servers as well as its usage of XOR-based encryption for its communications.",
                        "XOR-based encryption",
                        "As its name suggests, XorDdos uses XOR-based encryption to obfuscate data. It calls the dec_conf function to decode encoded strings using the XOR key BB2FA36AAA9541F0. The table below shows the decoded values of the obfuscated data used across the malwares various modules to conduct its activities."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x4670b763>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x4670b763>",
                    "type": "UnknownWord",
                    "value": "linux-based"
                },
                "references": {
                    "sentences": [
                        "XorDdos depicts the trend of malware increasingly targeting Linux-based operating systems, which are commonly deployed on cloud infrastructures and Internet of Things (IoT) devices. By compromising IoT and other internet-connected devices, XorDdos amasses botnets that can be used to carry out distributed denial-of-service (DDoS) attacks. Using a botnet to perform DDoS attacks can potentially create significant disruptions, such as the 2.4 Tbps DDoS attack Microsoft mitigated in August 2021. DDoS attacks in and of themselves can be highly problematic for numerous reasons, but such attacks can also be used as cover to hide further malicious activities, like deploying malware and infiltrating target systems."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x780c1e8>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x780c1e8>",
                    "type": "UnknownWord",
                    "value": "exit_success"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x4c3fddbd>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x4c3fddbd>",
                    "type": "UnknownWord",
                    "value": "hangup"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xc9a1c449>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xc9a1c449>",
                    "type": "UnknownWord",
                    "value": "sighup"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x2e949b00>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x2e949b00>",
                    "type": "UnknownWord",
                    "value": "sig_ign"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x2ef8dc3a>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x2ef8dc3a>",
                    "type": "UnknownWord",
                    "value": "sig_dfl"
                },
                "references": {
                    "sentences": [
                        "The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which internally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling process.<crlf>After the successful call to the fork() API, the parent stops itself by returning EXIT_SUCCESS (0). The purpose is to ensure that the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then calls setsid() to detach itself from the controlling terminal.<crlf>The daemon subroutine also has a provision to change the directory to the root directory (/) if the first parameter __nochdir is called with a value equal to 0. One reason for the daemon process to change the directory to the root partition (/)is because running the process from the mounted file system prevents unmounting unless the process is stopped.<crlf>It passes the second parameter __noclose as 0 to redirect standard input, standard output, and standard error to /dev/null. It does this by calling dup2 on the file descriptor for /dev/null.<crlf>The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process from the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive signal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to read from standard input, which could stop the malwares child process. The API signal() sets the disposition of the signal signum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this case, the second parameter is set to SIG_IGN=1, which ignores the signal corresponding to signum."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x102bb0e3>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x102bb0e3>",
                    "type": "UnknownWord",
                    "value": "bb2fa36aaa9541f0"
                },
                "references": {
                    "sentences": [
                        "As its name suggests, XorDdos uses XOR-based encryption to obfuscate data. It calls the dec_conf function to decode encoded strings using the XOR key BB2FA36AAA9541F0. The table below shows the decoded values of the obfuscated data used across the malwares various modules to conduct its activities.",
                        "AddService Creates the persistent auto-start entries previously mentioned so that the malware runs when the system starts.<crlf>HidePidPort Hides the malwares ports and processes.<crlf>CheckLKM Checks whether the rootkit device is active or not. It uses a similar IOCTL call with the number 0x9748712 and command 0 to find if the rootkit is active. If the rootkit is active, it uses the owner value 0xAD1473B8 and group value 0xAD1473B8 to change the ownership of dropped files with the function lchown(<filename>, 0xAD1473B8, 0xAD1473B8).<crlf>decrypt_remotestr Decodes remote URLs using the same XOR key, BB2FA36AAA9541F0, to decode config.rar and the other directories. After decoding the URLs, it adds them into a remote list, which is later used to communicate and fetch commands from the command and control (C2) server:www[.]enoan2107[.]com:3306www[.]gzcfr5axf6[.]com:3306"
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x66e19c4e>",
                            "type": "File",
                            "value": "config.rar"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0x102bb0e3>",
                            "type": "UnknownWord",
                            "value": "bb2fa36aaa9541f0"
                        }
                    }
                ]
            },
            "<UNKNOWNWORD_0xd3ba6bd9>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xd3ba6bd9>",
                    "type": "UnknownWord",
                    "value": "o_rdonly"
                },
                "references": {
                    "sentences": [
                        "> strace -e open ps<crlf>open(/proc/3922/status, O_RDONLY) = 6<crlf>open(/proc/4324/stat, O_RDONLY) = 6<crlf>open(/proc/4324/status, O_RDONLY) = 6<crlf>open(/proc/5559/stat, O_RDONLY) = 6<crlf>open(/proc/5559/status, O_RDONLY) = 6<crlf>open(/proc/5960/stat, O_RDONLY) = 6<crlf>open(/proc/5960/status, O_RDONLY) = 6<crlf>open(/proc/5978/stat, O_RDONLY) = 6<crlf>open(/proc/5978/status, O_RDONLY) = 6"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x92d834e3>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x92d834e3>",
                    "type": "UnknownWord",
                    "value": "<pid>"
                },
                "references": {
                    "sentences": [],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xa7c867be>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xa7c867be>",
                    "type": "UnknownWord",
                    "value": "v-style"
                },
                "references": {
                    "sentences": [
                        "A runlevel is a mode of init and the system that specifies what system services are operating for Unix System V-Style operating systems. Runlevels contain a value, typically numbered zero through six, which each designate a different system configuration and allows access to a different combination of processes. Some system administrators set a systems default runlevel according to their needs or use runlevels to identify which subsystems are working, such as whether the network is operational. The /etc/rc<run_level> directory contains symbolic links (symlinks), which are soft links that point to the original file. These symlinks point to the scripts that should run at the specified runlevel."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xc85e443f>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xc85e443f>",
                    "type": "UnknownWord",
                    "value": "linuxexec_argv2"
                },
                "references": {
                    "sentences": [
                        "The malware runs a command to install startup services that automatically run XorDdos at boot. The malwares LinuxExec_Argv2 subroutine runs the system API with the provided arguments."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x5d3a5cdb>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x5d3a5cdb>",
                    "type": "UnknownWord",
                    "value": "seek_end"
                },
                "references": {
                    "sentences": [
                        "Opens the file for writing only<crlf>Calls lseek (fd, 0, SEEK_END) to point at the last position in the file<crlf>Creates a random 10-character string<crlf>Writes the string at the end of the file with an additional null byte"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x8121392f>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x8121392f>",
                    "type": "UnknownWord",
                    "value": "hidepidport"
                },
                "references": {
                    "sentences": [
                        "In this code path, the malware uses process name spoofing to hide from the process tree by modifying its fake command line at runtime. It then hides its process by calling HidePidPort with command 1 and reads the content of the file on disk related to the current process.",
                        "AddService Creates the persistent auto-start entries previously mentioned so that the malware runs when the system starts.<crlf>HidePidPort Hides the malwares ports and processes.<crlf>CheckLKM Checks whether the rootkit device is active or not. It uses a similar IOCTL call with the number 0x9748712 and command 0 to find if the rootkit is active. If the rootkit is active, it uses the owner value 0xAD1473B8 and group value 0xAD1473B8 to change the ownership of dropped files with the function lchown(<filename>, 0xAD1473B8, 0xAD1473B8).<crlf>decrypt_remotestr Decodes remote URLs using the same XOR key, BB2FA36AAA9541F0, to decode config.rar and the other directories. After decoding the URLs, it adds them into a remote list, which is later used to communicate and fetch commands from the command and control (C2) server:www[.]enoan2107[.]com:3306www[.]gzcfr5axf6[.]com:3306"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xbf920a73>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xbf920a73>",
                    "type": "UnknownWord",
                    "value": "stringsfetches"
                },
                "references": {
                    "sentences": [
                        "Decodes encrypted stringsFetches file stats for /var/run/gcc.pid or, if none exist, then creates the fileFetches file stats for /lib/libudev.so or, if none exist, then creates the directory /lib and creates a copy of itself at the location /lib/libudev.soFetches the on disk file information associated with the current process; if it fails, then exits the loop and stops the current processReads the content from kill_cfg and performs the corresponding actions, like stopping the process or deleting files, based on the matching specified keys in the configuration file, such as:md5=<crlf>filename=<crlf>rmfile=<crlf>denyip="
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x20e65324>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x20e65324>",
                    "type": "UnknownWord",
                    "value": "filefetches"
                },
                "references": {
                    "sentences": [
                        "Decodes encrypted stringsFetches file stats for /var/run/gcc.pid or, if none exist, then creates the fileFetches file stats for /lib/libudev.so or, if none exist, then creates the directory /lib and creates a copy of itself at the location /lib/libudev.soFetches the on disk file information associated with the current process; if it fails, then exits the loop and stops the current processReads the content from kill_cfg and performs the corresponding actions, like stopping the process or deleting files, based on the matching specified keys in the configuration file, such as:md5=<crlf>filename=<crlf>rmfile=<crlf>denyip="
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xdc85a3cc>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xdc85a3cc>",
                    "type": "UnknownWord",
                    "value": "processreads"
                },
                "references": {
                    "sentences": [
                        "Decodes encrypted stringsFetches file stats for /var/run/gcc.pid or, if none exist, then creates the fileFetches file stats for /lib/libudev.so or, if none exist, then creates the directory /lib and creates a copy of itself at the location /lib/libudev.soFetches the on disk file information associated with the current process; if it fails, then exits the loop and stops the current processReads the content from kill_cfg and performs the corresponding actions, like stopping the process or deleting files, based on the matching specified keys in the configuration file, such as:md5=<crlf>filename=<crlf>rmfile=<crlf>denyip="
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xb251b047>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xb251b047>",
                    "type": "UnknownWord",
                    "value": "_sc_nprocessors_conf"
                },
                "references": {
                    "sentences": [
                        "The malware calls sysconf(_SC_NPROCESSORS_CONF) to fetch the number of processors in the device. It then creates threads with twice the number of processors found on the device."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xf9e14cc8>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xf9e14cc8>",
                    "type": "UnknownWord",
                    "value": "edgeavailable"
                },
                "references": {
                    "sentences": [
                        "Encourage the use of Microsoft Edgeavailable on Linux and various platformsor other web browsers that support Microsoft Defender SmartScreen, which identifies and blocks malicious websites, including phishing sites, scam sites, and sites that contain exploits and host malware.<crlf>Use device discovery to find unmanaged Linux devices on your network and onboard them to Microsoft Defender for Endpoint.<crlf>Turn on cloud-delivered protection in Microsoft Defender Antivirus or the equivalent for your antivirus product to use cloud-based machine learning protections that can block a huge majority of new and unknown variants.<crlf>Run EDR in block mode so that Microsoft Defender for Endpoint can block malicious artifacts, even when your non-Microsoft antivirus doesnt detect the threat or when Microsoft Defender Antivirus is running in passive mode.<crlf>Enable network protection to prevent applications or users from accessing malicious domains and other malicious content on the internet.<crlf>Enable investigation and remediation in full automated mode to allow Microsoft Defender for Endpoint to take immediate action on alerts to resolve breaches, significantly reducing alert volume."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x3113186d>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x3113186d>",
                    "type": "UnknownWord",
                    "value": "smartscreen"
                },
                "references": {
                    "sentences": [
                        "Encourage the use of Microsoft Edgeavailable on Linux and various platformsor other web browsers that support Microsoft Defender SmartScreen, which identifies and blocks malicious websites, including phishing sites, scam sites, and sites that contain exploits and host malware.<crlf>Use device discovery to find unmanaged Linux devices on your network and onboard them to Microsoft Defender for Endpoint.<crlf>Turn on cloud-delivered protection in Microsoft Defender Antivirus or the equivalent for your antivirus product to use cloud-based machine learning protections that can block a huge majority of new and unknown variants.<crlf>Run EDR in block mode so that Microsoft Defender for Endpoint can block malicious artifacts, even when your non-Microsoft antivirus doesnt detect the threat or when Microsoft Defender Antivirus is running in passive mode.<crlf>Enable network protection to prevent applications or users from accessing malicious domains and other malicious content on the internet.<crlf>Enable investigation and remediation in full automated mode to allow Microsoft Defender for Endpoint to take immediate action on alerts to resolve breaches, significantly reducing alert volume."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xede5665>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xede5665>",
                    "type": "UnknownWord",
                    "value": "non-microsoft"
                },
                "references": {
                    "sentences": [
                        "Encourage the use of Microsoft Edgeavailable on Linux and various platformsor other web browsers that support Microsoft Defender SmartScreen, which identifies and blocks malicious websites, including phishing sites, scam sites, and sites that contain exploits and host malware.<crlf>Use device discovery to find unmanaged Linux devices on your network and onboard them to Microsoft Defender for Endpoint.<crlf>Turn on cloud-delivered protection in Microsoft Defender Antivirus or the equivalent for your antivirus product to use cloud-based machine learning protections that can block a huge majority of new and unknown variants.<crlf>Run EDR in block mode so that Microsoft Defender for Endpoint can block malicious artifacts, even when your non-Microsoft antivirus doesnt detect the threat or when Microsoft Defender Antivirus is running in passive mode.<crlf>Enable network protection to prevent applications or users from accessing malicious domains and other malicious content on the internet.<crlf>Enable investigation and remediation in full automated mode to allow Microsoft Defender for Endpoint to take immediate action on alerts to resolve breaches, significantly reducing alert volume."
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x1ec0f006>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x1ec0f006>",
                    "type": "UnknownWord",
                    "value": "initiatingprocessfilename"
                },
                "references": {
                    "sentences": [
                        "DeviceLogonEvents<crlf>| where InitiatingProcessFileName == \"sshd\"<crlf>and ActionType == \"LogonFailed\"<crlf>| summarize count() by dayOfYear = datetime_part(\"dayOfYear\", Timestamp)<crlf>| sort by dayOfYear<crlf>| render linechart"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x41155cca>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x41155cca>",
                    "type": "UnknownWord",
                    "value": "actiontype"
                },
                "references": {
                    "sentences": [
                        "DeviceLogonEvents<crlf>| where InitiatingProcessFileName == \"sshd\"<crlf>and ActionType == \"LogonFailed\"<crlf>| summarize count() by dayOfYear = datetime_part(\"dayOfYear\", Timestamp)<crlf>| sort by dayOfYear<crlf>| render linechart"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xed6eeb69>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xed6eeb69>",
                    "type": "UnknownWord",
                    "value": "logonfailed"
                },
                "references": {
                    "sentences": [
                        "DeviceLogonEvents<crlf>| where InitiatingProcessFileName == \"sshd\"<crlf>and ActionType == \"LogonFailed\"<crlf>| summarize count() by dayOfYear = datetime_part(\"dayOfYear\", Timestamp)<crlf>| sort by dayOfYear<crlf>| render linechart"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x7b8a538a>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x7b8a538a>",
                    "type": "UnknownWord",
                    "value": "dayofyear"
                },
                "references": {
                    "sentences": [
                        "DeviceLogonEvents<crlf>| where InitiatingProcessFileName == \"sshd\"<crlf>and ActionType == \"LogonFailed\"<crlf>| summarize count() by dayOfYear = datetime_part(\"dayOfYear\", Timestamp)<crlf>| sort by dayOfYear<crlf>| render linechart"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0x62026fe6>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x62026fe6>",
                    "type": "UnknownWord",
                    "value": "xorddos-specific"
                },
                "references": {
                    "sentences": [
                        "Creation of the XorDdos-specific dropped files"
                    ],
                    "titles": []
                }
            },
            "<UNKNOWNWORD_0xbbe44895>": {
                "token": {
                    "id": "<UNKNOWNWORD_0xbbe44895>",
                    "type": "UnknownWord",
                    "value": "processcommandline"
                },
                "references": {
                    "sentences": [
                        "DeviceProcessEvents<crlf>| where ProcessCommandLine contains \"cat resolv.conf\""
                    ],
                    "titles": []
                },
                "links": [
                    {
                        "src": {
                            "id": "<FILE_0x132cf0c2>",
                            "type": "File",
                            "value": "resolv.conf"
                        },
                        "relation": "related",
                        "dst": {
                            "id": "<UNKNOWNWORD_0xbbe44895>",
                            "type": "UnknownWord",
                            "value": "processcommandline"
                        }
                    }
                ]
            },
            "<UNKNOWNWORD_0x64d31321>": {
                "token": {
                    "id": "<UNKNOWNWORD_0x64d31321>",
                    "type": "UnknownWord",
                    "value": "jonathan"
                },
                "references": {
                    "sentences": [
                        "Ratnesh Pandey, Yevgeny Kulakov, and Jonathan Bar Or<crlf>Microsoft 365 Defender Research Team"
                    ],
                    "titles": []
                }
            }
        },
        "sigma": false,
        "yara": false
    },
    "keywords": {
        "classified": [],
        "dubbed": [],
        "associated": [
            "In this case, the non-stripped binary includes the following source-code file names associated with the symbol table entries as part of the .strtab section in the ELF file:",
            "Ignore signals associated with the terminal-related operations",
            "Process name spoofing achieved by modifying memory associated with argument vectors",
            "The malware creates a symlink for the init script dropped at the location /etc/init.d/<base_file_name> with the directories associated with runlevels 1 through 5 at /etc/rc<run_level>.d/S90<base_file_name> and /etc/rc.d/rc<run_level>.d/S90<base_file_name>.",
            "Decodes encrypted stringsFetches file stats for /var/run/gcc.pid or, if none exist, then creates the fileFetches file stats for /lib/libudev.so or, if none exist, then creates the directory /lib and creates a copy of itself at the location /lib/libudev.soFetches the on disk file information associated with the current process; if it fails, then exits the loop and stops the current processReads the content from kill_cfg and performs the corresponding actions, like stopping the process or deleting files, based on the matching specified keys in the configuration file, such as:md5=<crlf>filename=<crlf>rmfile=<crlf>denyip=",
            "The timeline view displays all of the detection and prevention events associated with XorDdos, providing details such as the MITRE ATT&CK techniques and tactics, remediation status, and event entities graph."
        ],
        "targets": [
            "Defending against Linux platform threats",
            "Microsoft Defender for Endpoint protects against XorDdos by detecting and remediating the trojans multi-stage, modular attacks throughout its entire attack chain and any potential follow-on activities on endpoints",
            "defending against linux platform threats",
            "Its SSH brute force attacks are a relatively simple yet effective technique for gaining root access over a number of potential targets",
            "This includes detecting and protecting against its use of a malicious shell script for initial access, its drop-and-execution of binaries from a world-writable location, and any potential follow-on activities on endpoints"
        ],
        "attributed": []
    },
    "resources": {
        "links": {
            "github": [
                "https://github.com/jermeyyy/rooty"
            ],
            "pastebin": [],
            "text_files": [],
            "other": [
                "https://azure.microsoft.com/blog/business-as-usual-for-azure-customers-despite-24-tbps-ddos-attack/?ranMID=24542&ranEAID=TnL5HPStwNw&ranSiteID=TnL5HPStwNw-QrFhTcj5NHbS49DwTEAxiA&epi=TnL5HPStwNw-QrFhTcj5NHbS49DwTEAxiA&irgwc=1&OCID=AID2200057_aff_7593_1243925&tduid=%28ir__f1adpj9cvckf62kijydwmqedqu2xtltt90ejoqbv00%29%287593%29%281243925%29%28TnL5HPStwNw-QrFhTcj5NHbS49DwTEAxiA%29%28%29&irclickid=_f1adpj9cvckf62kijydwmqedqu2xtltt90ejoqbv00",
                "https://www.microsoft.com/security/business/threat-protection/endpoint-defender?rtc=1",
                "https://www.microsoft.com/security/business/threat-protection/endpoint-defender?rtc=1",
                "https://docs.microsoft.com/microsoft-365/security/defender-endpoint/next-generation-protection?view=o365-worldwide",
                "https://docs.microsoft.com/microsoft-365/security/defender-endpoint/overview-endpoint-detection-response?view=o365-worldwide",
                "https://www.microsoft.com/edge",
                "https://docs.microsoft.com/deployedge/microsoft-edge-security-smartscreen",
                "https://docs.microsoft.com/microsoft-365/security/defender-endpoint/device-discovery?view=o365-worldwide",
                "https://docs.microsoft.com/microsoft-365/security/defender-endpoint/configure-block-at-first-sight-microsoft-defender-antivirus?view=o365-worldwide",
                "https://docs.microsoft.com/microsoft-365/security/defender-endpoint/edr-in-block-mode?view=o365-worldwide",
                "https://docs.microsoft.com/microsoft-365/security/defender-endpoint/enable-network-protection?view=o365-worldwide",
                "https://docs.microsoft.com/microsoft-365/security/defender-endpoint/automated-investigations?view=o365-worldwide"
            ]
        },
        "images": [
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/05/Figure-1.-Typical-attack-vector-for-XorDdos-malware_ccexpress-1024x747.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/05/Figure-2.-Failed-sign-in-attempts-on-a-device-affected-by-XorDdos.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/05/Figure-3.-Remote-bash-script-command-used-for-initial-access.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/05/Figure-4.-Ignore-signals-associated-with-the-terminal-related-operations.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/05/5-test_ccexpress.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/05/Figure-6.-Output-of-the-%E2%80%98ps-aef-contains-an-entry-for-cat-resolv.conf_.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/05/Figure-7.-Content-of-the-init-script-dropped-at-the-location-etc-init.d-HFLgGwYfSC.elf_.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/05/Figure-8.-Content-of-the-gcc.sh-script.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/05/Figure-9.-System-command-to-delete-the-etc-cron.hourly-gcc.sh-entry-from-the-etc-crontab-file-and-add-a-new-entry.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/05/Figure-10.-The-content-of-the-file-etc-crontab.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/05/Figure-11.-Installation-of-rc.d-directorys-symlink-scripts-with-etc-init.d-base_file_name.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/05/Figure-12.-chkconfig-and-update-rc.d-commands-install-the-startup-service.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/05/Figure-13.-The-end-of-the-malware-file-contains-two-random-strings-wieegnexuk-and-yybrdajydg-indicating-that-the-original-malware-binary-was-modified-twice.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/05/Figure-14.-Dummy-InstallSYS-routine.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/05/Figure-15.-Semaphore-and-malicious-thread-initialization.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/05/Figure-16.-Collection-of-system-information.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/05/Figure-17.-daemon_get_killed_process-thread-function-fetches-and-decodes-the-kill_cfg-data-from-remote-URL.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/05/Figure-18.-Microsoft-365-Defender-alert-for-detection-of-XorDdos-malware_ccexpress.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/05/Figure-19.-Microsoft-365-Defender-timeline-displaying-that-HFLgGwYfSC.elf-was-run-from-a-world-writable-directory-and-the-remediation-of-dropped-binaries_ccexpress.png",
            "https://www.microsoft.com/security/blog/uploads/securityprod/2022/05/Figure-20.-Microsoft-365-Defender-timeline-with-an-event-on-a-suspicious-shell-command-run-by-crond-after-it-was-dropped-from-HFLgGwYfSC.elf_ccexpress.png"
        ]
    }
}